<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <title>DTS Beam Group Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- DTS Canvas Engine -->
    <!-- DTS Core Modules -->
    <script src="core/DtsUI.js"></script>
    <script src="core/DtsState.js"></script>
    <script src="core/DtsPhysics.js"></script>
    <script src="core/DtsEvents.js"></script>
    <script src="core/DtsRenderer.js"></script>
    <!-- Beam Modules -->
    <script src="beam/BeamState.js"></script>
    <script src="beam/BeamRenderer.js"></script>
    <script src="beam/BeamTable.js"></script>
    <script src="beam/BeamActions.js"></script>
    <script src="beam/BeamInit.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        accent: '#f59e0b',
                        danger: '#ef4444',
                        success: '#22c55e'
                    }
                }
            }
        }
    </script>
    <style>
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        .span-row.highlighted {
            background: rgba(59, 130, 246, 0.15) !important;
        }

        .span-row:hover {
            background: rgba(59, 130, 246, 0.08);
        }

        .span-row.selected {
            background: rgba(34, 197, 94, 0.15);
        }

        .toast {
            animation: slideUp 0.3s ease, fadeOut 2.5s 0.5s forwards;
        }

        @keyframes slideUp {
            from {
                transform: translate(-50%, 100%);
                opacity: 0;
            }

            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
            }
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        /* Prevent text selection and ensure cursor during resize */
        body.resizing {
            cursor: ns-resize !important;
            user-select: none !important;
            -webkit-user-select: none !important;
        }

        body.resizing * {
            cursor: ns-resize !important;
        }
    </style>
</head>

<body class="bg-slate-100 text-slate-800 font-sans text-sm h-screen flex flex-col overflow-hidden">

    <!-- HEADER -->
    <header class="flex-none bg-slate-900 text-white shadow-md z-50">
        <div class="px-4 py-2 flex justify-between items-center gap-4">
            <div class="flex items-center gap-3">
                <i class="fa-solid fa-layer-group text-amber-500 text-xl"></i>
                <h1 class="text-lg font-bold">DTS Rebar Viewer</h1>
            </div>

            <div class="flex items-center gap-3">
                <button class="nav-btn px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded" onclick="prevGroup()">
                    <i class="fa-solid fa-chevron-left"></i>
                </button>
                <select id="groupSelect" onchange="loadGroup(this.value)"
                    class="bg-slate-800 border border-slate-600 text-white px-3 py-1 rounded min-w-[180px]"></select>
                <button class="nav-btn px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded" onclick="nextGroup()">
                    <i class="fa-solid fa-chevron-right"></i>
                </button>
            </div>

            <div class="flex items-center gap-2">
                <label class="text-xs text-slate-400">Ph∆∞∆°ng √°n:</label>
                <select id="optionSelect" onchange="selectOption(this.value)"
                    class="bg-slate-800 border border-slate-600 text-white px-2 py-1 rounded text-xs"></select>
                <button id="lockBtn" onclick="toggleLock()" title="Ch·ªët/M·ªü kh√≥a ph∆∞∆°ng √°n"
                    class="px-2 py-1 bg-amber-600 hover:bg-amber-500 text-white rounded text-xs flex items-center gap-1">
                    <i class="fa-solid fa-lock"></i> Ch·ªët
                </button>
                <button id="lockStatus" onclick="restoreLockedDesign()" title="Click ƒë·ªÉ restore ph∆∞∆°ng √°n ƒë√£ ch·ªët"
                    class="text-xs text-green-400 hover:text-green-300 cursor-pointer hidden flex items-center gap-1">
                    <i class="fa-solid fa-check-circle"></i> ƒê√£ ch·ªët
                </button>
            </div>

            <div class="flex gap-2 items-center">
                <!-- Undo/Redo Buttons -->
                <button onclick="Beam.History.undo()" title="Undo (Ctrl+Z)"
                    class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white rounded text-xs">
                    <i class="fa-solid fa-undo"></i>
                </button>
                <button onclick="Beam.History.redo()" title="Redo (Ctrl+Y)"
                    class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white rounded text-xs">
                    <i class="fa-solid fa-redo"></i>
                </button>
                <div class="w-px h-4 bg-slate-600"></div>
                <!-- Quick Calc Button -->
                <button onclick="quickCalc()" title="T√≠nh th√©p nhanh cho group n√†y"
                    class="px-2 py-1 bg-green-600 hover:bg-green-500 text-white rounded text-xs flex items-center gap-1">
                    <i class="fa-solid fa-calculator"></i> T√≠nh th√©p
                </button>
                <!-- Pull Data Button -->
                <button onclick="pullDataFromCad()" title="L·∫•y d·ªØ li·ªáu m·ªõi nh·∫•t t·ª´ XData (Pull)"
                    class="px-2 py-1 bg-cyan-600 hover:bg-cyan-500 text-white rounded text-xs flex items-center gap-1 border border-cyan-700 shadow-sm">
                    <i class="fa-solid fa-cloud-arrow-down"></i> Pull
                </button>
                <!-- Highlight CAD Toggle -->
                <label class="flex items-center gap-1 text-xs cursor-pointer">
                    <span class="text-slate-400">Highlight</span>
                    <div class="relative">
                        <input type="checkbox" id="highlightToggle" class="sr-only peer"
                            onchange="toggleHighlightMode(this.checked)">
                        <div class="w-8 h-4 bg-slate-600 rounded-full peer-checked:bg-blue-500 transition-colors"></div>
                        <div
                            class="absolute top-0.5 left-0.5 w-3 h-3 bg-white rounded-full peer-checked:translate-x-4 transition-transform">
                        </div>
                    </div>
                </label>
                <!-- FIX 5: Label Toggle Button -->
                <!-- Only copyFormat and Reset buttons in header now - Group controls moved to Plan toolbar -->
                <button class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white rounded text-xs"
                    onclick="copyFormat()" title="Copy Format"><i class="fa-solid fa-paintbrush"></i></button>
            </div>
        </div>
    </header>

    <!-- MAIN -->
    <main class="flex-1 flex overflow-hidden relative">
        <!-- PLAN CANVAS - Full window, behind overlays -->
        <div class="absolute inset-0 bg-white overflow-hidden" id="planCanvasContainer">
            <canvas id="beamCanvas"></canvas>
            <!-- Story dropdown (visible in Plan mode - default) -->
            <div id="storyDropdownContainer" class="absolute top-2 left-2 z-20">
                <select id="storySelect" onchange="loadStory(this.value)"
                    class="bg-slate-800 border border-slate-600 text-white px-2 py-1 rounded text-xs"></select>
            </div>
            <!-- Zoom indicator -->
            <div id="zoomIndicator"
                class="absolute bottom-2 right-2 bg-slate-800/70 text-white text-[10px] px-2 py-0.5 rounded z-20">100%
            </div>
            <!-- Plan View Toolbar (top right) -->
            <div
                class="absolute top-2 right-2 z-20 flex items-center gap-1 bg-white/90 rounded-md shadow-sm px-1 py-0.5 border border-slate-200">
                <!-- Toggle Rebar Mode button (SVG Eye Icon) -->
                <button id="btnToggleRebar" onclick="toggleRebarMode()" title="Rebar Display Mode"
                    class="w-7 h-7 hover:bg-slate-100 text-slate-500 hover:text-blue-600 text-sm rounded flex items-center justify-center transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path
                            d="M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0" />
                        <circle cx="12" cy="12" r="3" />
                    </svg>
                </button>
                <div class="w-px h-4 bg-slate-300"></div>
                <!-- Lock Text Zoom Toggle -->
                <label class="flex items-center gap-0.5 cursor-pointer" title="Lock text to zoom (scale with canvas)">
                    <div class="relative">
                        <input type="checkbox" id="lockTextZoom" class="sr-only peer"
                            onchange="toggleLockTextZoom(this.checked)">
                        <div class="w-6 h-3 bg-slate-300 rounded-full peer-checked:bg-blue-500 transition-colors"></div>
                        <div
                            class="absolute top-0.5 left-0.5 w-2 h-2 bg-white rounded-full peer-checked:translate-x-3 transition-transform shadow-sm">
                        </div>
                    </div>
                    <i class="fa-solid fa-lock text-[8px] text-slate-400"></i>
                </label>
                <!-- Label Scale Slider -->
                <span class="text-[9px] text-slate-500 font-bold select-none">Aa</span>
                <input type="range" id="labelScaleSlider" min="0.5" max="3" step="0.1" value="1"
                    oninput="planLabelScale = parseFloat(this.value); render();"
                    class="w-14 h-1 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-slate-400 hover:accent-blue-500">
                <span class="text-[11px] text-slate-500 font-bold select-none">Aa</span>
                <div class="w-px h-4 bg-slate-300"></div>
                <!-- Zoom Fit button -->
                <button onclick="resetPlanCanvasView()" title="Zoom to fit"
                    class="w-7 h-7 hover:bg-slate-100 text-slate-500 hover:text-blue-600 text-sm rounded flex items-center justify-center transition-colors">
                    <i class="fa-solid fa-arrows-to-dot"></i>
                </button>
            </div>
            <!-- Help overlay -->
            <div id="helpOverlay"
                class="absolute bottom-2 left-2 text-[9px] text-slate-400 bg-white/70 px-1 rounded z-20">
                Box: Select | Alt+Drag: Pan | Wheel: Zoom | Tab: Next beam | ESC: Clear Selection</div>

            <!-- ELEMENTS PANEL (Top-Left) - Like index.html -->
            <div id="elements-panel"
                class="absolute left-2 top-12 w-44 bg-white/95 rounded border border-slate-200 shadow-sm z-20 max-h-[60vh] overflow-hidden flex flex-col transition-all duration-300 opacity-40 hover:opacity-100">
                <div
                    class="bg-amber-100 px-2 py-1 text-[10px] font-bold text-amber-700 border-b flex justify-between items-center">
                    <span><i class="fa-solid fa-tag mr-1"></i>Sections</span>
                    <span id="elements-count" class="text-amber-500">0</span>
                </div>
                <div class="overflow-y-auto max-h-[400px] text-[10px]" id="elements-list-content">
                    <!-- Dynamic content -->
                </div>
                <!-- Selected count -->
                <div id="elements-selected-bar"
                    class="hidden bg-orange-50 px-2 py-1 text-[10px] text-orange-600 border-t">
                    <i class="fa-solid fa-check-square mr-1"></i>Selected: <span id="elements-selected-count">0</span>
                    <button onclick="Beam.State.clearHandleSelection();render();updateElementsPanel();"
                        class="ml-2 hover:text-red-500" title="Clear (ESC)"><i class="fa-solid fa-times"></i></button>
                </div>
            </div>

            <!-- Plan View Floating Toolbar (Group operations) -->
            <div id="planToolbar" class="absolute top-2 left-40 z-20 flex gap-1">
                <!-- Detach -->
                <button onclick="sendDetachSelected()" title="T√°ch d·∫ßm (Detach)"
                    class="w-8 h-8 bg-slate-600/80 hover:bg-slate-500 text-white text-sm rounded flex items-center justify-center">
                    <i class="fa-solid fa-scissors"></i>
                </button>
                <!-- Ungroup -->
                <button onclick="sendUngroup()" title="X√≥a group (Ungroup)"
                    class="w-8 h-8 bg-slate-600/80 hover:bg-slate-500 text-white text-sm rounded flex items-center justify-center">
                    <i class="fa-solid fa-unlink"></i>
                </button>
                <!-- Regroup -->
                <button onclick="sendRegroupSelected()" title="Gom group m·ªõi (Regroup)"
                    class="w-8 h-8 bg-slate-600/80 hover:bg-slate-500 text-white text-sm rounded flex items-center justify-center">
                    <i class="fa-solid fa-object-group"></i>
                </button>
                <!-- Beam Naming -->
                <button onclick="showAutoNameConfirm()" title="ƒê·∫∑t t√™n d·∫ßm t·ª± ƒë·ªông"
                    class="w-8 h-8 bg-slate-600/80 hover:bg-slate-500 text-white text-sm rounded flex items-center justify-center">
                    <i class="fa-solid fa-font"></i>
                </button>
                <!-- Labels Toggle (3 modes: OFF/GROUP/SECTION) -->
                <button id="btnToggleLabelsFloat" onclick="toggleGroupLabels()" title="B·∫≠t/t·∫Øt nh√£n (Labels)"
                    class="w-8 h-8 bg-blue-600/80 hover:bg-blue-500 text-white text-sm rounded flex items-center justify-center">
                    <i class="fa-solid fa-layer-group"></i>
                </button>
                <div class="w-px h-8 bg-slate-300 mx-1"></div>
                <!-- Batch Operations -->
                <button onclick="batchSetSectionLabel()" title="G√°n t√™n h√†ng lo·∫°t cho d·∫ßm ƒëang ch·ªçn (Set Name)"
                    class="w-8 h-8 bg-indigo-600/80 hover:bg-indigo-500 text-white text-sm rounded flex items-center justify-center">
                    <i class="fa-solid fa-tag"></i>
                </button>
                <button onclick="batchUnlockSection()" title="M·ªü kh√≥a h√†ng lo·∫°t d·∫ßm ƒëang ch·ªçn (Unlock)"
                    class="w-8 h-8 bg-orange-500/80 hover:bg-orange-400 text-white text-sm rounded flex items-center justify-center">
                    <i class="fa-solid fa-lock-open"></i>
                </button>
                <div class="w-px h-8 bg-slate-300 mx-1"></div>
                <!-- Report -->
                <button onclick="showCalculationReport()" title="Xem thuy·∫øt minh (Report)"
                    class="w-8 h-8 bg-emerald-600/80 hover:bg-emerald-500 text-white text-sm rounded flex items-center justify-center">
                    <i class="fa-solid fa-file-invoice"></i>
                </button>
            </div>
        </div>

        <!-- FLOATING TOGGLE BUTTONS - Visible when sidebars are collapsed -->
        <!-- Right Sidebar Toggle (when collapsed) -->
        <button id="rightSidebarFloatBtn" onclick="toggleRightSidebar()" title="M·ªü Metrics & Table"
            class="absolute right-0 top-16 w-6 h-16 bg-slate-700 hover:bg-slate-600 text-white rounded-l z-30 flex items-center justify-center">
            <i class="fa-solid fa-chevron-left text-xs"></i>
        </button>

        <!-- Detail Panel Toggle (when collapsed) -->
        <button id="detailPanelFloatBtn" onclick="toggleDetailPanel()" title="M·ªü Detail Panel"
            class="hidden absolute bottom-0 left-4 w-16 h-6 bg-slate-700 hover:bg-slate-600 text-white rounded-t z-30 flex items-center justify-center">
            <i class="fa-solid fa-chevron-up text-xs"></i>
        </button>

        <!-- RIGHT SIDEBAR - Collapsible overlay (Metrics + Table) -->
        <div id="rightSidebar"
            class="absolute right-0 top-0 bottom-0 w-80 bg-slate-50/95 backdrop-blur border-l border-slate-300 shadow-lg z-20 transition-transform duration-300 flex flex-col"
            style="transform: translateX(100%);">

            <!-- METRICS BAR - Top of sidebar with toggle in title -->
            <div id="metricsBar" class="flex-none bg-slate-100 border-b border-slate-200 p-3">
                <div onclick="toggleRightSidebar()"
                    class="flex justify-between items-center cursor-pointer hover:bg-slate-200 -m-2 p-2 rounded mb-2">
                    <span class="text-xs font-bold text-slate-600">üìä Metrics & Table</span>
                    <i id="rightSidebarIcon" class="fa-solid fa-chevron-left text-xs text-slate-400"></i>
                </div>
                <div class="grid grid-cols-2 gap-2 text-xs">
                    <div class="flex items-center gap-1">
                        <span class="text-slate-500">Backbone:</span>
                        <span class="font-bold text-blue-600" id="metricBackbone">-</span>
                    </div>
                    <div class="flex items-center gap-1">
                        <span class="text-slate-500">As:</span>
                        <span class="font-bold" id="metricAs">-</span>
                    </div>
                    <div class="flex items-center gap-1">
                        <span class="text-slate-500">Waste:</span>
                        <span class="font-bold" id="metricWaste">-</span>
                    </div>
                    <div class="flex items-center gap-1">
                        <span class="text-slate-500">Weight:</span>
                        <span class="font-bold" id="metricWeight">-</span>
                    </div>
                    <div class="flex items-center gap-1">
                        <span class="text-slate-500">Score:</span>
                        <span class="font-bold text-green-600" id="metricScore">-</span>
                    </div>
                </div>
                <!-- Visual Indicators -->
                <div id="visualIndicators" class="flex items-center gap-2 mt-2">
                    <span id="motherIndicator" class="hidden text-yellow-500 text-xs"
                        title="Mother beam (Span 0)">üëë</span>
                    <span id="lockedIndicator" class="hidden text-red-500 text-xs" title="Design locked">üîí</span>
                    <span id="brokenChainIndicator" class="hidden text-orange-500 text-xs"
                        title="SpanIndex gap detected">üîó‚ùå</span>
                    <span id="manualEditIndicator" class="hidden text-yellow-400 text-xs"
                        title="Manually edited">‚ö†Ô∏è</span>
                </div>
                <!-- Stale Geometry Warning -->
                <div id="staleGeometryBanner"
                    class="hidden mt-2 flex items-center gap-2 px-2 py-1 bg-amber-100 text-amber-800 rounded text-xs border border-amber-300">
                    <i class="fa-solid fa-triangle-exclamation"></i>
                    <span>Geometry ƒë√£ thay ƒë·ªïi!</span>
                    <button onclick="quickCalc()"
                        class="px-2 py-0.5 bg-amber-600 hover:bg-amber-500 text-white rounded text-xs">T√≠nh l·∫°i</button>
                </div>
                <div id="warningsContainer" class="flex gap-2 mt-2"></div>
            </div>

            <!-- TABLE SECTION - Scrollable -->
            <div id="tablePanel" class="flex-1 flex flex-col overflow-hidden">
                <div class="flex-none p-2 bg-slate-100 border-b border-slate-200">
                    <div class="flex items-center gap-2 text-xs">
                        <label class="flex items-center gap-1">
                            <input type="checkbox" id="autoApply" checked class="w-3.5 h-3.5">
                            Auto Apply
                        </label>
                        <button class="px-2 py-1 bg-slate-200 hover:bg-slate-300 rounded text-xs"
                            onclick="selectAllSpans()">All</button>
                        <button class="px-2 py-1 bg-slate-200 hover:bg-slate-300 rounded text-xs"
                            onclick="selectNoneSpans()">None</button>
                        <span id="groupInfo" class="ml-auto text-slate-500">-</span>
                    </div>
                </div>
                <div id="tablePanelContent" class="flex-1 overflow-auto p-2">
                    <div class="bg-white rounded border border-slate-200 overflow-hidden">
                        <table class="table-fixed w-max text-xs whitespace-nowrap">
                            <thead class="bg-slate-100 sticky top-0">
                                <tr>
                                    <th class="p-1 text-left w-14" rowspan="2">Nh·ªãp</th>
                                    <th class="p-1 text-center w-8" rowspan="2">‚úì</th>
                                    <th class="p-1 text-center w-10" rowspan="2">L(m)</th>
                                    <th class="p-1 text-center w-12" rowspan="2">b√óh</th>
                                    <th class="p-1 text-center w-8" rowspan="2">L·ªõp</th>
                                    <th colspan="3" class="p-1 text-center bg-red-50 text-red-700 text-[10px]">TH√âP TR√äN
                                    </th>
                                    <th colspan="3" class="p-1 text-center bg-blue-50 text-blue-700 text-[10px]">TH√âP
                                        D∆Ø·ªöI</th>
                                    <th colspan="3" class="p-1 text-center bg-slate-100 text-[10px]">ƒêAI</th>
                                    <th class="p-1 text-center w-12" rowspan="2">Sidebar</th>
                                </tr>
                                <tr class="text-[10px] text-slate-500">
                                    <th class="p-1 bg-red-50 w-12">G·ªëi T</th>
                                    <th class="p-1 bg-red-50 w-12">Gi·ªØa</th>
                                    <th class="p-1 bg-red-50 w-12">G·ªëi P</th>
                                    <th class="p-1 bg-blue-50 w-12">G·ªëi T</th>
                                    <th class="p-1 bg-blue-50 w-12">Gi·ªØa</th>
                                    <th class="p-1 bg-blue-50 w-12">G·ªëi P</th>
                                    <th class="p-1 w-12">L1</th>
                                    <th class="p-1 w-12">Mid</th>
                                    <th class="p-1 w-12">L2</th>
                                </tr>
                            </thead>
                            <tbody id="spanTableBody"></tbody>
                        </table>
                    </div>
                    <div class="mt-3 flex items-center gap-3">
                        <label class="text-xs text-slate-500">Stirrup pattern:</label>
                        <input type="text" id="stirrupPattern" value="d8a100/150/100"
                            class="border border-slate-300 rounded px-2 py-1 text-xs w-32">
                        <button class="px-2 py-1 bg-slate-200 hover:bg-slate-300 rounded text-xs"
                            onclick="applyStirrupPattern()">Apply</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- V5.0: Floating Properties Panel -->
        <div id="propertiesPanel" class="hidden absolute left-4 top-12 w-72 bg-white shadow-lg rounded border z-30">
            <div class="p-3 bg-slate-100 border-b font-bold text-xs flex justify-between items-center">
                <span>üèóÔ∏è Span Properties</span>
                <button onclick="closePropertiesPanel()" class="text-slate-500 hover:text-red-500">&times;</button>
            </div>
            <div class="p-3 space-y-2 text-xs">
                <!-- Beam Info -->
                <div class="grid grid-cols-2 gap-2">
                    <div>
                        <label class="text-slate-500">Handle</label>
                        <input id="propHandle" readonly class="w-full px-2 py-1 border rounded bg-slate-50 text-xs">
                    </div>
                    <div>
                        <label class="text-slate-500">SpanId</label>
                        <input id="propSpanId" readonly class="w-full px-2 py-1 border rounded bg-slate-50 text-xs">
                    </div>
                </div>
                <div class="grid grid-cols-3 gap-2">
                    <div>
                        <label class="text-slate-500">Width</label>
                        <input id="propWidth" readonly class="w-full px-2 py-1 border rounded bg-slate-50 text-xs">
                    </div>
                    <div>
                        <label class="text-slate-500">Height</label>
                        <input id="propHeight" readonly class="w-full px-2 py-1 border rounded bg-slate-50 text-xs">
                    </div>
                    <div>
                        <label class="text-slate-500">Length</label>
                        <input id="propLength" readonly class="w-full px-2 py-1 border rounded bg-slate-50 text-xs">
                    </div>
                </div>
                <!-- Group State -->
                <div class="border-t pt-2">
                    <div class="font-bold text-slate-600 mb-1">Group State</div>
                    <div class="flex items-center gap-2">
                        <label class="text-slate-500">Option</label>
                        <select id="propOption" onchange="onPropOptionChange(this.value)"
                            class="flex-1 px-2 py-1 border rounded text-xs"></select>
                    </div>
                    <div class="flex items-center gap-2 mt-2">
                        <label class="text-slate-500">Locked</label>
                        <input type="checkbox" id="propLocked" onchange="onPropLockedChange(this.checked)">
                        <span id="propLockedLabel" class="text-slate-400 text-xs">Ch∆∞a ch·ªët</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- BOTTOM DETAIL PANEL - Collapsible overlay (resizable) -->
        <div id="detailPanel"
            class="absolute left-0 bottom-0 bg-white border-t border-slate-300 shadow-lg z-20 transition-transform duration-300 flex flex-col"
            style="right: 0px; height: 40vh;">

            <!-- Resize Handle (drag to resize panel height) - larger hitbox for easy clicking -->
            <div id="detailPanelResizer"
                class="absolute top-0 left-0 right-0 h-2 -mt-1 bg-transparent hover:bg-blue-400/20 cursor-ns-resize z-50"
                style="touch-action: none;" title="K√©o ƒë·ªÉ thay ƒë·ªïi k√≠ch th∆∞·ªõc">
                <div class="w-full h-1 bg-slate-300 pointer-events-none mt-1"></div>
            </div>

            <!-- Simple title bar with toggle -->
            <div class="flex-none flex items-center gap-2 px-3 py-1 bg-slate-100 border-b border-slate-200">
                <button onclick="toggleDetailPanel()" title="Toggle Panel"
                    class="w-6 h-6 bg-slate-600 hover:bg-slate-500 text-white text-xs rounded flex items-center justify-center">
                    <i id="detailPanelIcon" class="fa-solid fa-chevron-down"></i>
                </button>
                <span class="text-xs font-bold text-slate-600">üìê Detail View</span>
            </div>

            <!-- Detail Canvas Container (relative for floating buttons) -->
            <div class="flex-1 overflow-hidden bg-white relative" id="detailCanvasContainer">
                <canvas id="detailCanvas"></canvas>

                <!-- Floating toolbar (bottom right) with tabs and zoom -->
                <div class="absolute bottom-2 right-2 z-20 flex gap-1">
                    <button onclick="setDetailMode('long')" id="tabLong"
                        class="w-8 h-8 bg-blue-600/80 hover:bg-blue-500 text-white text-xs rounded flex items-center justify-center"
                        title="Long Rebar">
                        <i class="fa-solid fa-grip-lines"></i>
                    </button>
                    <button onclick="setDetailMode('section')" id="tabSection"
                        class="w-8 h-8 bg-slate-600/80 hover:bg-slate-500 text-white text-xs rounded flex items-center justify-center"
                        title="Section">
                        <i class="fa-solid fa-clone"></i>
                    </button>
                    <button onclick="setDetailMode('shear')" id="tabShear"
                        class="w-8 h-8 bg-slate-600/80 hover:bg-slate-500 text-white text-xs rounded flex items-center justify-center"
                        title="Shear-Web">
                        <i class="fa-solid fa-bars"></i>
                    </button>
                    <button onclick="resetDetailCanvasView()" title="Zoom to fit"
                        class="w-8 h-8 bg-slate-600/80 hover:bg-slate-500 text-white text-xs rounded flex items-center justify-center">
                        <i class="fa-solid fa-arrows-to-dot"></i>
                    </button>
                </div>
            </div>
        </div>
    </main>

    <!-- FOOTER -->
    <footer class="flex-none bg-white border-t border-slate-200 px-4 py-2 flex justify-between items-center">
        <div class="flex gap-2">
            <button class="px-3 py-1.5 bg-slate-200 hover:bg-slate-300 rounded text-xs font-medium" onclick="doSave()">
                <i class="fa-solid fa-save mr-1"></i>Save
            </button>
            <button class="px-3 py-1.5 bg-slate-200 hover:bg-slate-300 rounded text-xs font-medium"
                onclick="doExport()">
                <i class="fa-solid fa-file-export mr-1"></i>Export
            </button>
            <button class="px-3 py-1.5 bg-slate-200 hover:bg-slate-300 rounded text-xs font-medium"
                onclick="doImport()">
                <i class="fa-solid fa-file-import mr-1"></i>Import
            </button>
        </div>
        <div class="flex gap-2">
            <button class="px-3 py-1.5 bg-slate-300 hover:bg-slate-400 rounded text-xs font-medium"
                onclick="doCancel()">
                Cancel
            </button>
            <button class="px-4 py-1.5 bg-blue-600 hover:bg-blue-500 text-white rounded text-xs font-bold"
                onclick="applyToDrawing()">
                <i class="fa-solid fa-check mr-1"></i>Apply to Drawing
            </button>
        </div>
    </footer>

    <script>
        // ============================================================
        // BEAM VIEWER - Modular Architecture
        // Uses Beam namespace for state and functions
        // Core modules (Dts.*) injected by C# if available
        // ============================================================

        // Data from C#
        const data = __DATA_JSON__;

        // [NEW] Global Data Sync Functions
        window.updateAllData = function (json) {
            try {
                const newData = (typeof json === 'string') ? JSON.parse(json) : json;
                if (!newData) return;

                // Sync to global data object
                data.groups = newData.groups || [];
                data.allBeams = newData.allBeams || [];
                data.allGrids = newData.allGrids || [];
                data.allColumns = newData.allColumns || [];
                if (newData.settings) data.settings = newData.settings;

                // Refresh all UI components
                refreshUI();
                console.log(`‚úÖ UI updated with new data: ${data.groups?.length} groups, ${data.allBeams?.length} beams`);
            } catch (e) {
                console.error('Failed to update data:', e);
            }
        };

        window.refreshUI = function () {
            // Ensure we have something to render
            if (!data.groups) return;

            // 1. Update Story Dropdown (Plan View)
            populateStoryDropdown();

            // 2. Filter Groups and update Dropdown
            populateGroupSelect();

            // 3. Sync currentGroup reference from data.groups
            if (data.groups.length > 0) {
                // Ensure index is valid
                if (currentGroupIndex < 0) currentGroupIndex = 0;
                if (currentGroupIndex >= data.groups.length) currentGroupIndex = data.groups.length - 1;

                currentGroup = data.groups[currentGroupIndex];
                Beam.State.currentGroup = currentGroup;
                Beam.State.currentGroupIndex = currentGroupIndex;

                // Update Group-specific UI
                populateOptionSelect();
                updateLockStatus();
                updateGroupInfo();
                updateMetrics();
                updateVisualIndicators();
                updateStaleGeometryBanner();
            }

            // 4. Render All Views
            renderPlanView();
            renderDetailCanvas();
            maybeRenderTable();
            updateElementsPanel();
            updateOverlayPositions();
        };


        // ============ BEAM NAMESPACE ============
        window.Beam = window.Beam || {};

        // State management
        Beam.State = {
            currentGroupIndex: 0,
            currentGroup: null,
            selectedOptionKey: null, // 'locked' | numeric index as string
            highlightedSpanIndex: -1,
            spanBounds: [],

            // Canvas mode: 'plan' | 'section' | 'long' | 'shear'
            canvasMode: 'long',
            currentStoryZ: null, // For Plan view: current story Z level

            // Canvas interaction
            zoom: 1.0,
            panX: 0,
            panY: 0,
            isDragging: false,
            lastX: 0,
            lastY: 0,

            // Box zoom
            boxZoomActive: false,
            boxZoomStartX: 0,
            boxZoomStartY: 0,
            boxZoomEndX: 0,
            boxZoomEndY: 0,

            // === BOX SELECTION (Window/Crossing) ===
            selectedHandles: new Set(),  // C√°c handle d·∫ßm ƒë∆∞·ª£c ch·ªçn
            boxSelectActive: false,
            boxSelectStart: { x: 0, y: 0 },
            boxSelectEnd: { x: 0, y: 0 },

            // Selection helper functions (OOP pattern t·ª´ index.html)
            toggleHandleSelection(handle, ctrlKey = false) {
                if (ctrlKey) {
                    if (this.selectedHandles.has(handle)) {
                        this.selectedHandles.delete(handle);
                    } else {
                        this.selectedHandles.add(handle);
                    }
                } else {
                    this.selectedHandles.clear();
                    this.selectedHandles.add(handle);
                }
            },

            isHandleSelected(handle) {
                return this.selectedHandles.has(handle);
            },

            clearHandleSelection() {
                this.selectedHandles.clear();
            },

            addHandlesToSelection(handles) {
                if (handles) handles.forEach(h => this.selectedHandles.add(h));
            },

            removeHandlesFromSelection(handles) {
                if (handles) handles.forEach(h => this.selectedHandles.delete(h));
            },

            // UI
            tablePanelCollapsed: false,
            highlightModeEnabled: false
        };

        // Constants
        Beam.Constants = {
            MIN_SPAN_WIDTH: 80,
            MAX_CANVAS_WIDTH: 1600,
            CANVAS_PADDING: 30,
            BEAM_HEIGHT: 120
        };

        // ============ HISTORY (UNDO/REDO) ============
        Beam.History = {
            stack: [],
            ptr: -1,
            maxSize: 20,
            isLocked: false, // When locked, edits are disabled

            // Take snapshot of current group rebar state
            snapshot() {
                if (!currentGroup) return null;
                return JSON.stringify({
                    spans: currentGroup.Spans?.map(s => ({
                        SpanId: s.SpanId,
                        TopRebar: s.TopRebar,
                        BotRebar: s.BotRebar,
                        Stirrup: s.Stirrup,
                        WebBar: s.WebBar
                    })),
                    selectedBackbone: currentGroup.SelectedBackboneIndex
                });
            },

            push() {
                if (this.isLocked) return false;
                const snap = this.snapshot();
                if (!snap) return false;
                // Skip if same as current
                if (this.ptr > -1 && this.stack[this.ptr] === snap) return false;
                // Truncate redo stack
                if (this.ptr < this.stack.length - 1) {
                    this.stack = this.stack.slice(0, this.ptr + 1);
                }
                this.stack.push(snap);
                this.ptr++;
                // Limit size
                if (this.stack.length > this.maxSize) {
                    this.stack.shift();
                    this.ptr--;
                }
                return true;
            },

            restore(snapshot) {
                if (!currentGroup || !snapshot) return;
                try {
                    const d = JSON.parse(snapshot);
                    if (d.spans) {
                        d.spans.forEach(sr => {
                            const span = currentGroup.Spans?.find(s => s.SpanId === sr.SpanId);
                            if (span) {
                                span.TopRebar = sr.TopRebar;
                                span.BotRebar = sr.BotRebar;
                                span.Stirrup = sr.Stirrup;
                                span.WebBar = sr.WebBar;
                            }
                        });
                    }
                    if (d.selectedBackbone !== undefined) {
                        currentGroup.SelectedBackboneIndex = d.selectedBackbone;
                    }
                    refreshUI();
                    maybeRenderTable();
                    updateMetrics();
                } catch (e) { console.error('History restore error', e); }
            },

            undo() {
                if (this.ptr > 0) {
                    this.ptr--;
                    this.restore(this.stack[this.ptr]);
                }
            },

            redo() {
                if (this.ptr < this.stack.length - 1) {
                    this.ptr++;
                    this.restore(this.stack[this.ptr]);
                }
            },

            clear() {
                this.stack = [];
                this.ptr = -1;
            }
        };

        // ============ LOCK/UNLOCK ============
        // V7.0: Delete SelectedDesign / lockedSnapshot obsolete

        function toggleLock() {
            if (!currentGroup) return;

            currentGroup.IsLocked = !currentGroup.IsLocked;

            // Notify C#
            if (currentGroup.IsLocked) {
                window.chrome.webview?.postMessage('LOCK_DESIGN|' + currentGroupIndex);
            } else {
                window.chrome.webview?.postMessage('UNLOCK_DESIGN|' + currentGroupIndex);
            }

            updateLockStatus();
        }

        function updateLockStatus() {
            const btn = document.getElementById('lockBtn');
            const status = document.getElementById('lockStatus');
            if (!currentGroup) return;

            const isLocked = !!currentGroup.IsLocked;

            if (isLocked) {
                btn.innerHTML = '<i class="fa-solid fa-lock-open"></i> Mo';
                btn.className = 'px-2 py-1 bg-slate-600 hover:bg-slate-500 text-white rounded text-xs flex items-center gap-1';
                status.classList.remove('hidden');
            } else {
                btn.innerHTML = '<i class="fa-solid fa-lock"></i> Chot';
                btn.className = 'px-2 py-1 bg-amber-600 hover:bg-amber-500 text-white rounded text-xs flex items-center gap-1';
                status.classList.add('hidden');
            }
        }

        // Aliases for backward compatibility (refactor gradually)
        let currentGroupIndex = 0;
        let currentGroup = null;
        let selectedOptionKey = null;
        let highlightedSpanIndex = -1;
        let spanBounds = [];
        let rebarLabelBounds = [];
        let detailSpanBounds = [];
        let detailRebarLabelBounds = [];
        let sectionLabelBounds = [];
        let planSectionLabelBounds = []; // V√πng bao nh√£n tr√™n m·∫∑t b·∫±ng
        let planLockBounds = []; // V√πng bao bi·ªÉu t∆∞·ª£ng kh√≥a tr√™n m·∫∑t b·∫±ng
        let labelHits = []; // For detailed label hit testing
        let isPanDragging = false; // Track if we actually dragged during a click
        let mouseDownButton = -1; // Specific button that started the click
        const MIN_SPAN_WIDTH = 80;
        const MAX_CANVAS_WIDTH = 1600;
        const CANVAS_PADDING = 30;
        const BEAM_HEIGHT = 120;
        const FIXED_SPAN_WIDTH = 473; // -25% from 630

        // Inline canvas label editor (DOM overlay)
        let labelEditorEl = null;
        let activeLabelEdit = null;
        let highlightModeEnabled = false;
        let canvasMode = 'plan'; // DEFAULT: Plan view is now main canvas mode
        let detailMode = 'long';  // Detail panel mode: 'long' | 'section' | 'shear'
        let canvasZoom = 1.0;
        let canvasPanX = 0;
        let canvasPanY = 0;
        let canvasDragging = false;
        let canvasLastX = 0;
        let canvasLastY = 0;
        let boxZoomActive = false;
        let boxZoomStartX = 0;
        let boxZoomStartY = 0;
        let boxZoomEndX = 0;
        let boxZoomEndY = 0;
        let tablePanelCollapsed = false;
        // NEW: Sidebar collapse states
        let rightSidebarCollapsed = true;
        let detailPanelCollapsed = false;
        // Detail canvas zoom/pan (separate from main canvas)
        let detailZoom = 1.0;
        let detailPanX = 0;
        let detailPanY = 0;
        // FIX 5: Toggle group name labels on plan view
        // Label Mode: 0=Off, 1=Group Name, 2=Section Name (bxh)
        let labelMode = 1; // M·∫∑c ƒë·ªãnh hi·ªÉn th·ªã Group Name
        // FIX 3: Track selected beam (single vs group mode)
        let selectedBeamHandle = null;  // null = full group selected, string = single beam selected
        let singleBeamMode = false;  // Tab toggles this
        let selectedBeamIndex = -1;   // -1 = all beams in group, >=0 = specific beam index

        // NEW: Shared plan view transform state for hit-testing
        let planTransform = {
            baseScale: 1.0,
            baseOffsetX: 0,
            baseOffsetY: 0,
            lw: 800,
            lh: 600
        };
        let planLabelScale = 1.0; // T·ª∑ l·ªá k√≠ch th∆∞·ªõc nh√£n m·∫∑t b·∫±ng
        // REBAR MODE: 0=Off, 1=Longitudinal (Top+Bot), 2=Stirrup/Web, 3=AsCompare, 4=Detailed
        let rebarMode = 0;
        // LOCK TEXT ZOOM: Khi b·∫≠t, text s·∫Ω zoom theo canvas (thay v√¨ c·ªë ƒë·ªãnh size)
        let lockTextZoom = false;

        // ============ INLINE LABEL EDIT FUNCTIONS (Restored from u7.7) ============

        function getLayerRebarText(span, type, layer, pos) {
            if (!span) return '';
            const arr = (type === 'Top') ? span.TopRebar : span.BotRebar;
            const layerArr = arr?.[layer] || [];
            const v = layerArr?.[pos];
            return (v === undefined || v === null) ? '' : String(v);
        }

        function getStirrupText(span, pos) {
            if (!span || !span.Stirrup) return '';
            return span.Stirrup[pos] || '';
        }

        function getWebBarText(span, pos) {
            if (!span || !span.WebBar) return '';
            return span.WebBar[pos] || '';
        }

        function updateLayerRebar(spanIndex, type, layer, pos, value) {
            const arr = type === 'Top' ? 'TopRebar' : 'BotRebar';

            // BACKBONE LOGIC: Layer 0 is continuous across ALL spans
            if (layer === 0) {
                currentGroup.Spans.forEach(span => {
                    if (!span[arr]) span[arr] = [];
                    while (span[arr].length <= layer) span[arr].push([]);
                    if (!span[arr][layer]) span[arr][layer] = [];
                    span[arr][layer][0] = value; // Left
                    span[arr][layer][2] = value; // Mid
                    span[arr][layer][4] = value; // Right
                });
                autoLockOnEdit();
                showToast(`‚úì C·ªët ch·ªß ${type} ƒë√£ c·∫≠p nh·∫≠t to√†n b·ªô nh·ªãp: ${value}`);
                maybeRenderTable();
                // N-way Sync: Update allBeams for all spans
                currentGroup.Spans.forEach(span => syncSpanDataToAllBeams(span));
                refreshUI();
                return;
            }

            // ADDON LOGIC: Layer 1+ is per-span, per-position
            const span = currentGroup.Spans[spanIndex];
            if (!span[arr]) span[arr] = [];
            while (span[arr].length <= layer) span[arr].push([]);
            if (!span[arr][layer]) span[arr][layer] = [];
            span[arr][layer][pos] = value;

            autoLockOnEdit();

            // Auto apply to subsequent spans
            const autoApply = document.getElementById('autoApply');
            if (autoApply && autoApply.checked) {
                for (let i = spanIndex + 1; i < currentGroup.Spans.length; i++) {
                    if (currentGroup.Spans[i].IsActive !== false) {
                        const s = currentGroup.Spans[i];
                        if (!s[arr]) s[arr] = [];
                        while (s[arr].length <= layer) s[arr].push([]);
                        if (!s[arr][layer]) s[arr][layer] = [];
                        s[arr][layer][pos] = value;
                    }
                }
                maybeRenderTable();
            }
            // N-way Sync: Update allBeams for this span
            syncSpanDataToAllBeams(currentGroup.Spans[spanIndex]);
            refreshUI();
        }

        function updateStirrup(spanIndex, pos, value) {
            const span = currentGroup.Spans[spanIndex];
            if (!span.Stirrup) span.Stirrup = [];
            span.Stirrup[pos] = value;
            autoLockOnEdit();
            maybeRenderTable();
            // N-way Sync
            syncSpanDataToAllBeams(span);
            refreshUI();
        }

        function updateWebBar(spanIndex, pos, value) {
            const span = currentGroup.Spans[spanIndex];
            if (!span.WebBar) span.WebBar = [];
            span.WebBar[pos] = value;
            autoLockOnEdit();
            maybeRenderTable();
            // N-way Sync
            syncSpanDataToAllBeams(span);
            refreshUI();
        }

        // ============ REBAR MODE & SYNC FUNCTIONS ============

        /**
         * Chuy·ªÉn ƒë·ªïi ch·∫ø ƒë·ªô hi·ªÉn th·ªã th√©p tr√™n Plan View.
         * Modes: 0=Off, 1=Longitudinal, 2=Stirrup/Web, 3=AsCompare, 4=Detailed
         */
        function toggleRebarMode() {
            rebarMode = (rebarMode + 1) % 5;
            // Mode mapping gi·ªëng DTS_REBAR_SHOW:
            // 0: Off, 1: Th√©p d·ªçc, 2: ƒêai/S∆∞·ªùn, 3: So s√°nh As, 4: Chi ti·∫øt ƒëai/s∆∞·ªùn
            const modeNames = ['Off', 'Th√©p d·ªçc', 'ƒêai/S∆∞·ªùn', 'So s√°nh As', 'Chi ti·∫øt'];
            showToast(`üëÅ Rebar Mode: ${modeNames[rebarMode]}`, 'info');
            updateRebarModeButton();
            render();
        }

        function updateRebarModeButton() {
            const btn = document.getElementById('btnToggleRebar');
            if (!btn) return;
            // Update title based on mode (gi·ªëng DTS_REBAR_SHOW)
            btn.title = ['Rebar Off', 'Th√©p d·ªçc', 'ƒêai + S∆∞·ªùn', 'So s√°nh As', 'Chi ti·∫øt ƒëai/s∆∞·ªùn'][rebarMode];
            // Change SVG color based on mode (active = blue, off = gray)
            const svg = btn.querySelector('svg');
            if (svg) {
                svg.style.stroke = rebarMode > 0 ? '#2563eb' : 'currentColor';
            }
        }

        /**
         * Toggle lock text zoom - khi b·∫≠t, text s·∫Ω zoom theo canvas.
         * Logic: Duy tr√¨ visual size hi·ªán t·∫°i khi toggle.
         * - ON: Visual size = planLabelScale -> Sau ƒë√≥ th√†nh planLabelScale * canvasZoom
         *       => planLabelScale m·ªõi = planLabelScale c≈© / canvasZoom
         * - OFF: Visual size = planLabelScale * canvasZoom -> Sau ƒë√≥ th√†nh planLabelScale
         *        => planLabelScale m·ªõi = planLabelScale c≈© * canvasZoom
         */
        function toggleLockTextZoom(checked) {
            const slider = document.getElementById('labelScaleSlider');

            if (checked && !lockTextZoom) {
                // Turning ON: ƒêi·ªÅu ch·ªânh planLabelScale ƒë·ªÉ visual size kh√¥ng ƒë·ªïi
                // Visual tr∆∞·ªõc = planLabelScale
                // Visual sau = planLabelScale * canvasZoom
                // => planLabelScale m·ªõi = planLabelScale / canvasZoom
                planLabelScale = planLabelScale / canvasZoom;
            } else if (!checked && lockTextZoom) {
                // Turning OFF: ƒêi·ªÅu ch·ªânh planLabelScale ƒë·ªÉ visual size kh√¥ng ƒë·ªïi
                // Visual tr∆∞·ªõc = planLabelScale * canvasZoom
                // Visual sau = planLabelScale
                // => planLabelScale m·ªõi = planLabelScale * canvasZoom
                planLabelScale = planLabelScale * canvasZoom;
            }

            // Clamp to slider range
            planLabelScale = Math.max(0.5, Math.min(3, planLabelScale));

            // Update slider to reflect new value
            if (slider) {
                slider.value = planLabelScale;
            }

            lockTextZoom = checked;
            showToast(lockTextZoom ? 'üîí Text zoom theo canvas' : 'üîì Text c·ªë ƒë·ªãnh size', 'info');
            render();
        }

        /**
         * N-way Sync: ƒê·ªìng b·ªô d·ªØ li·ªáu t·ª´ currentGroup.Spans -> data.allBeams.
         * G·ªçi h√†m n√†y sau m·ªçi thay ƒë·ªïi th√©p trong Detail View.
         * @param {object} span - SpanData ƒë√£ ƒë∆∞·ª£c ch·ªânh s·ª≠a
         */
        function syncSpanDataToAllBeams(span) {
            if (!span || !data.allBeams) return;
            const handle = span.Segments?.[0]?.EntityHandle;
            if (!handle) return;

            const beam = data.allBeams.find(b => b.Handle === handle);
            if (!beam) return;

            // Sync rebar strings (t·ª´ span sang beam trong allBeams)
            beam.TopRS = extractRebarStringsJS(span, 'Top');
            beam.BotRS = extractRebarStringsJS(span, 'Bot');
            beam.StirRS = span.Stirrup || [];
            beam.WebRS = span.WebBar || [];
            beam.As_Top = span.As_Top || [];
            beam.As_Bot = span.As_Bot || [];
            beam.StirrupReq = span.StirrupReq || [];
            beam.WebReq = span.WebReq || [];

            // Trigger Plan View re-render
            renderPlanView();
        }

        /**
         * Helper: Tr√≠ch xu·∫•t chu·ªói th√©p cho 3 v√πng (L, M, R) t·ª´ span (ph√≠a JS).
         */
        function extractRebarStringsJS(span, side) {
            const result = ['', '', ''];
            if (!span) return result;

            const rebar = (side === 'Top') ? span.TopRebar : span.BotRebar;
            if (!rebar || !Array.isArray(rebar)) return result;

            // Zones: 0=Left(pos 0), 1=Mid(pos 2), 2=Right(pos 4)
            for (let zone = 0; zone < 3; zone++) {
                const posBase = zone * 2;
                const parts = [];

                for (let layer = 0; layer < rebar.length; layer++) {
                    const arr = rebar[layer] || [];
                    const val = arr[posBase];
                    if (val && val !== '-' && val !== '0') {
                        if (layer === 0) {
                            parts.push(val);
                        } else {
                            parts.push('+' + val);
                        }
                    }
                }
                result[zone] = parts.join(' ');
            }
            return result;
        }

        /**
         * Helper: T√≠nh di·ªán t√≠ch th√©p t·ª´ chu·ªói (VD: "3D20" -> 942 mm¬≤).
         */
        function parseRebarArea(str) {
            if (!str || typeof str !== 'string') return 0;
            const parts = str.split(/\s*\+\s*/); // Split by "+"
            let total = 0;
            for (const part of parts) {
                const m = part.match(/(\d+)\s*[DdŒ¶œÜ#]?\s*(\d+)/);
                if (m) {
                    const count = parseInt(m[1], 10) || 0;
                    const dia = parseInt(m[2], 10) || 0;
                    total += count * Math.PI * dia * dia / 4;
                }
            }
            return total;
        }


        function startInlineLabelEdit(label) {
            if (!label) return;

            // Determine source canvas and container
            const isPlan = label.source === 'plan';
            const canvas = document.getElementById(isPlan ? 'beamCanvas' : 'detailCanvas');
            const container = canvas?.parentElement;

            if (!labelEditorEl || !container) {
                // Fallback to prompt-based edit (original logic)
                if (isPlan) {
                    const handle = label.handle;
                    const beam = data.allBeams.find(b => b.Handle === handle);
                    if (!beam) return;
                    const oldLabel = beam.xSectionLabel || beam.SectionLabel || '';
                    const nextVal = prompt(`NH√ÉN D·∫¶M - ${handle}`, oldLabel);
                    if (nextVal !== null && nextVal !== oldLabel) {
                        beam.xSectionLabel = nextVal;
                        beam.xSectionLabelLocked = true;
                        if (window.chrome?.webview) {
                            window.chrome.webview.postMessage(`UPDATE_SECTION_LABEL|${handle}|${nextVal}|1`);
                        }
                        setTimeout(() => sendRefreshAllData(), 200);
                        showToast(`‚úÖ C·∫≠p nh·∫≠t nh√£n ${handle}`);
                        render();
                    }
                    return;
                }

                // Existing logic for detail canvas rebar labels
                if (label.spanIndex === undefined || !currentGroup?.Spans?.[label.spanIndex]) return;
                const span = currentGroup.Spans[label.spanIndex];
                if (label.type === 'Stirrup' || label.type === 'WebBar') {
                    const idx = Number.isFinite(label.pos) ? label.pos : 0;
                    const isStirrup = label.type === 'Stirrup';
                    const currentVal = (isStirrup ? (span?.Stirrup?.[idx] || '') : (span?.WebBar?.[idx] || '')).toString();
                    const title = `${isStirrup ? 'ƒêAI' : 'S∆Ø·ªúN'} - Nh·ªãp ${span.SpanId || (label.spanIndex + 1)}`;
                    const nextVal = prompt(title, currentVal);
                    if (nextVal === null) return;
                    if (isStirrup) updateStirrup(label.spanIndex, idx, nextVal);
                    else updateWebBar(label.spanIndex, idx, nextVal);
                    return;
                }
                const layer = Number.isFinite(label.layer) ? label.layer : 0;
                const pos = Number.isFinite(label.pos) ? label.pos : 2;
                const currentVal = getLayerRebarText(span, label.type, layer, pos);
                const nextVal = prompt(`${label.type === 'Top' ? 'TR√äN' : 'D∆Ø·ªöI'} (L${layer + 1})`, currentVal);
                if (nextVal === null) return;
                updateLayerRebar(label.spanIndex, label.type, layer, pos, nextVal);
                return;
            }

            activeLabelEdit = label;

            // Moves editor to correct container if needed
            if (labelEditorEl.parentElement !== container) {
                container.appendChild(labelEditorEl);
                if (!container.style.position) container.style.position = 'relative';
            }

            const rect = canvas.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();

            // Screen coords calculation
            let left, top, sw, sh;
            if (isPlan) {
                // Plan view coords are already screen-relative after transform
                left = (rect.left - containerRect.left) + label.x;
                top = (rect.top - containerRect.top) + label.y;
                sw = label.width;
                sh = label.height;
            } else {
                // Detail view world coords need zoom/pan
                const sx = label.x * detailZoom + detailPanX;
                const sy = label.y * detailZoom + detailPanY;
                sw = label.width * detailZoom;
                sh = label.height * detailZoom;
                left = (rect.left - containerRect.left) + sx;
                top = (rect.top - containerRect.top) + sy;
            }

            // Correction for alignment: Editor is TOP-LEFT, while text is often CENTER
            // We adjust 'left' because text source might be centered
            if (label.source !== 'plan' || true) { // Detail uses center. Plan also uses rotated center, but we pass TOP-LEFT in dblclick logic below
                // Keep as is for now
            }

            labelEditorEl.style.left = Math.max(0, left) + 'px';
            labelEditorEl.style.top = Math.max(0, top) + 'px';
            labelEditorEl.style.width = Math.max(60, sw) + 'px';
            labelEditorEl.style.height = Math.max(18, sh) + 'px';

            // Set initial value
            if (isPlan) {
                labelEditorEl.value = label.label || '';
            } else {
                const span = currentGroup.Spans[label.spanIndex];
                if (label.type === 'Stirrup') {
                    labelEditorEl.value = (span?.Stirrup?.[label.pos || 0] || '').toString();
                } else if (label.type === 'WebBar') {
                    labelEditorEl.value = (span?.WebBar?.[label.pos || 0] || '').toString();
                } else if (label.type === 'SectionLabel') {
                    labelEditorEl.value = (span?.xSectionLabel || '').toString();
                } else {
                    labelEditorEl.value = getLayerRebarText(span, label.type, label.layer || 0, label.pos || 2);
                }
            }

            labelEditorEl.classList.remove('hidden');
            labelEditorEl.focus();
            labelEditorEl.select();
        }

        // Batch Operation: Set Name for multiple beams
        window.batchSetSectionLabel = function () {
            if (Beam.State.selectedHandles.size === 0) {
                showToast('Vui l√≤ng ch·ªçn d·∫ßm tr√™n canvas tr∆∞·ªõc!');
                return;
            }
            const newName = prompt(`Nh·∫≠p t√™n m·ªõi cho ${Beam.State.selectedHandles.size} d·∫ßm ƒë∆∞·ª£c ch·ªçn:`);
            if (newName === null) return; // Cancelled

            const handles = Array.from(Beam.State.selectedHandles);
            let count = 0;

            handles.forEach(h => {
                const beam = data.allBeams.find(b => b.Handle === h);
                if (beam) {
                    beam.xSectionLabel = newName;
                    beam.xSectionLabelLocked = true; // Auto-lock requested
                    count++;
                }
            });

            if (count > 0) {
                // Batch update sync message
                const msg = `UPDATE_SECTION_LABEL_BATCH|${newName}|1|${handles.join(',')}`;
                window.chrome.webview.postMessage(msg);

                showToast(`‚úì ƒê√£ c·∫≠p nh·∫≠t ${count} d·∫ßm th√†nh "${newName}" v√† kh√≥a nh√£n.`);

                // K√≠ch ho·∫°t n·∫°p l·∫°i d·ªØ li·ªáu ƒë·ªÉ ƒë·ªìng b·ªô to√†n h·ªá th·ªëng
                setTimeout(() => {
                    sendRefreshAllData();
                }, 200);
            }
        };

        // Batch Operation: Unlock multiple beams
        window.batchUnlockSection = function () {
            if (Beam.State.selectedHandles.size === 0) {
                showToast('Vui l√≤ng ch·ªçn d·∫ßm ƒë·ªÉ m·ªü kh√≥a!');
                return;
            }
            if (!confirm(`M·ªü kh√≥a nh√£n cho ${Beam.State.selectedHandles.size} d·∫ßm ƒëang ch·ªçn?`)) return;

            const handles = Array.from(Beam.State.selectedHandles);
            let count = 0;

            handles.forEach(h => {
                const beam = data.allBeams.find(b => b.Handle === h);
                if (beam) {
                    beam.xSectionLabelLocked = false;
                    count++;
                }
            });

            if (count > 0) {
                const msg = `UPDATE_SECTION_LABEL_BATCH||0|${handles.join(',')}`;
                window.chrome.webview.postMessage(msg);

                showToast(`‚úì ƒê√£ m·ªü kh√≥a nh√£n cho ${count} d·∫ßm.`);

                setTimeout(() => {
                    sendRefreshAllData();
                }, 200);
            }
        };

        function toggleSectionLockByHandle(handle, e) {
            // Find beam in allBeams
            const beam = data.allBeams.find(b => b.Handle === handle);
            if (!beam) return;

            // Toggle locked state
            const currentState = !!beam.xSectionLabelLocked;
            const newState = !currentState;
            beam.xSectionLabelLocked = newState;

            // Optional: Sync to current group span if it's the same handle
            if (activeGroup && activeGroup.Spans) {
                const spanIndex = activeGroup.Spans.findIndex(s => s.Segments && s.Segments[0].EntityHandle === handle);
                if (spanIndex >= 0) {
                    activeGroup.Spans[spanIndex].xSectionLabelLocked = newState;
                }
            }

            // Send to C# to update AutoCAD XData
            if (window.chrome?.webview) {
                const label = beam.xSectionLabel || beam.SectionLabel || '';
                window.chrome.webview.postMessage(`UPDATE_SECTION_LABEL|${handle}|${label}|${newState ? 1 : 0}`);
            }

            render();
            showToast(newState ? `üîí ƒê√£ kh√≥a ${handle}` : `üîì ƒê√£ m·ªü kh√≥a ${handle}`);

            // Re-sync groups to be sure
            syncAllGroupsFromPlanData();
            updateElementsPanel(); // Update padlock in sidebar if visible
        }

        function commitInlineLabelEdit() {
            if (!activeLabelEdit || !labelEditorEl) {
                hideInlineLabelEditor();
                return;
            }
            const nextVal = labelEditorEl.value;

            // 1. X·ª≠ l√Ω nh√£n t·ª´ m·∫∑t b·∫±ng (Plan View)
            if (activeLabelEdit.source === 'plan') {
                const handle = activeLabelEdit.handle;
                const beam = data.allBeams.find(b => b.Handle === handle);
                if (beam) {
                    const oldLabel = beam.xSectionLabel || beam.SectionLabel || '';
                    if (nextVal !== oldLabel) {
                        // C·∫≠p nh·∫≠t d·ªØ li·ªáu t·∫°i ch·ªó (optimistic UI)
                        beam.xSectionLabel = nextVal;
                        beam.xSectionLabelLocked = true; // Lu√¥n kh√≥a khi s·ª≠a th·ªß c√¥ng

                        // G·ª≠i xu·ªëng AutoCAD
                        if (window.chrome?.webview) {
                            window.chrome.webview.postMessage(`UPDATE_SECTION_LABEL|${handle}|${nextVal}|1`);
                        }

                        // K√≠ch ho·∫°t n·∫°p l·∫°i d·ªØ li·ªáu ƒë·ªÉ ƒë·ªìng b·ªô to√†n h·ªá th·ªëng
                        setTimeout(() => {
                            sendRefreshAllData();
                        }, 200);

                        showToast(`‚úÖ ƒê√£ c·∫≠p nh·∫≠t nh√£n d·∫ßm ${handle} (Auto-locked)`);
                    }
                }
                hideInlineLabelEditor();
                return;
            }

            // 2. X·ª≠ l√Ω nh√£n t·ª´ Detail View (nguy√™n b·∫£n)
            if (activeLabelEdit.type === 'Stirrup') {
                const idx = Number.isFinite(activeLabelEdit.pos) ? activeLabelEdit.pos : 0;
                updateStirrup(activeLabelEdit.spanIndex, idx, nextVal);
                hideInlineLabelEditor();
                return;
            }
            if (activeLabelEdit.type === 'WebBar') {
                const idx = Number.isFinite(activeLabelEdit.pos) ? activeLabelEdit.pos : 0;
                updateWebBar(activeLabelEdit.spanIndex, idx, nextVal);
                hideInlineLabelEditor();
                return;
            }
            if (activeLabelEdit.type === 'SectionLabel') {
                updateSectionLabel(activeLabelEdit.spanIndex, nextVal);
                hideInlineLabelEditor();
                return;
            }
            const layer = Number.isFinite(activeLabelEdit.layer) ? activeLabelEdit.layer : 0;
            const pos = Number.isFinite(activeLabelEdit.pos) ? activeLabelEdit.pos : 2;
            updateLayerRebar(activeLabelEdit.spanIndex, activeLabelEdit.type, layer, pos, nextVal);
            hideInlineLabelEditor();
        }

        function cancelInlineLabelEdit() {
            hideInlineLabelEditor();
        }

        function hideInlineLabelEditor() {
            activeLabelEdit = null;
            if (!labelEditorEl) return;
            labelEditorEl.classList.add('hidden');
            labelEditorEl.value = '';
        }

        // ============ END INLINE LABEL EDIT FUNCTIONS ============

        function maybeRenderTable() {
            // Avoid heavy table re-render during canvas-first workflow when panel is collapsed.
            // When user expands the panel, we'll re-render once.
            if (!tablePanelCollapsed) renderTable();
            updateStaleGeometryBanner();
            updateVisualIndicators();
        }

        function toggleTablePanel() {
            tablePanelCollapsed = !tablePanelCollapsed;
            const panel = document.getElementById('tablePanel');
            const icon = document.getElementById('tablePanelIcon');
            const content = document.getElementById('tablePanelContent');

            if (tablePanelCollapsed) {
                panel.classList.remove('max-h-[300px]');
                panel.classList.add('max-h-[32px]');
                content.classList.add('hidden');
                icon.classList.remove('fa-chevron-down');
                icon.classList.add('fa-chevron-up');
            } else {
                panel.classList.remove('max-h-[32px]');
                panel.classList.add('max-h-[300px]');
                content.classList.remove('hidden');
                icon.classList.remove('fa-chevron-up');
                icon.classList.add('fa-chevron-down');

                // Panel just expanded: refresh table to reflect any canvas edits made while collapsed.
                renderTable();
            }

            // Update overlay positions based on new table height
            updateOverlayPositions();
        }

        function setCanvasMode(mode) {
            canvasMode = mode;
            // Toggle active state for 4 buttons
            const btnPlan = document.getElementById('modePlan');
            const btnSection = document.getElementById('modeSection');
            const btnLong = document.getElementById('modeLong');
            const btnShear = document.getElementById('modeShear');
            const storyContainer = document.getElementById('storyDropdownContainer');
            const planToolbar = document.getElementById('planToolbar');

            btnPlan?.classList.toggle('bg-blue-600', mode === 'plan');
            btnPlan?.classList.toggle('bg-slate-600', mode !== 'plan');
            btnSection?.classList.toggle('bg-blue-600', mode === 'section');
            btnSection?.classList.toggle('bg-slate-600', mode !== 'section');
            btnLong?.classList.toggle('bg-blue-600', mode === 'long');
            btnLong?.classList.toggle('bg-slate-600', mode !== 'long');
            btnShear?.classList.toggle('bg-blue-600', mode === 'shear');
            btnShear?.classList.toggle('bg-slate-600', mode !== 'shear');

            // Show/hide Story dropdown and Plan Toolbar for Plan mode
            if (mode === 'plan') {
                storyContainer?.classList.remove('hidden');
                planToolbar?.classList.remove('hidden');
                selectedBeamIndex = -1; // Reset beam cycling
                populateStoryDropdown();
                renderPlanView();
            } else {
                storyContainer?.classList.add('hidden');
                planToolbar?.classList.add('hidden');
                // FIX: Reset zoom/pan and auto-center when switching modes
                canvasZoom = 1.0;
                canvasPanX = 0;
                canvasPanY = 0;
                refreshUI();
                centerCanvas();  // Auto-center view
            }
        }

        // ============ NEW LAYOUT FUNCTIONS ============
        function toggleRightSidebar() {
            rightSidebarCollapsed = !rightSidebarCollapsed;
            const sidebar = document.getElementById('rightSidebar');
            const icon = document.getElementById('rightSidebarIcon');
            const floatBtn = document.getElementById('rightSidebarFloatBtn');

            if (rightSidebarCollapsed) {
                sidebar.style.transform = 'translateX(100%)';
                icon?.classList.remove('fa-chevron-right');
                icon?.classList.add('fa-chevron-left');
                floatBtn?.classList.remove('hidden');  // Show floating button
            } else {
                sidebar.style.transform = 'translateX(0)';
                icon?.classList.remove('fa-chevron-left');
                icon?.classList.add('fa-chevron-right');
                floatBtn?.classList.add('hidden');  // Hide floating button
            }

            updateDetailPanelWidth();
            updateOverlayPositions();
        }

        function toggleDetailPanel() {
            detailPanelCollapsed = !detailPanelCollapsed;
            const panel = document.getElementById('detailPanel');
            const icon = document.getElementById('detailPanelIcon');
            const floatBtn = document.getElementById('detailPanelFloatBtn');

            if (detailPanelCollapsed) {
                panel.style.transform = 'translateY(100%)';
                icon?.classList.remove('fa-chevron-down');
                icon?.classList.add('fa-chevron-up');
                floatBtn?.classList.remove('hidden');  // Show floating button
            } else {
                panel.style.transform = 'translateY(0)';
                icon?.classList.remove('fa-chevron-up');
                icon?.classList.add('fa-chevron-down');
                floatBtn?.classList.add('hidden');  // Hide floating button
                // Re-render detail canvas when panel is expanded
                resizeDetailCanvas();
                updateOverlayPositions();
            }
        }

        // ============ DETAIL PANEL RESIZE ============
        let detailPanelResizing = false;
        let detailPanelStartY = 0;
        let detailPanelStartHeight = 0;
        const DETAIL_PANEL_MIN_HEIGHT = 150;
        const DETAIL_PANEL_MAX_HEIGHT = window.innerHeight * 0.8;

        function initDetailPanelResize() {
            const resizer = document.getElementById('detailPanelResizer');
            const panel = document.getElementById('detailPanel');
            if (!resizer || !panel) return;

            // FIX: B·ªçc localStorage trong try-catch ƒë·ªÉ tr√°nh l·ªói WebView ch·∫∑n truy c·∫≠p g√¢y ch·∫øt h√†m
            try {
                const savedHeight = localStorage.getItem('detailPanelHeight');
                if (savedHeight) {
                    panel.style.height = savedHeight + 'px';
                }
            } catch (e) { console.warn('Cannot access localStorage', e); }

            // Handler x·ª≠ l√Ω di chu·ªôt (Move)
            const onMouseMove = function (e) {
                if (!detailPanelResizing) return;
                const delta = detailPanelStartY - e.clientY;

                // T√≠nh to√°n chi·ªÅu cao m·ªõi
                let newHeight = detailPanelStartHeight + delta;

                // Gi·ªõi h·∫°n chi·ªÅu cao (Min 150px, Max 80% m√†n h√¨nh)
                newHeight = Math.max(DETAIL_PANEL_MIN_HEIGHT, Math.min(DETAIL_PANEL_MAX_HEIGHT, newHeight));

                panel.style.height = newHeight + 'px';

                // Resize canvas b√™n trong ngay l·∫≠p t·ª©c
                resizeDetailCanvas();
                updateOverlayPositions();
            };

            // Handler x·ª≠ l√Ω nh·∫£ chu·ªôt (Up)
            const onMouseUp = function () {
                if (detailPanelResizing) {
                    detailPanelResizing = false;
                    document.body.classList.remove('resizing');

                    try {
                        localStorage.setItem('detailPanelHeight', panel.offsetHeight);
                    } catch (e) { }

                    // FIX: D√πng removeEventListener thay v√¨ g√°n null
                    window.removeEventListener('mousemove', onMouseMove);
                    window.removeEventListener('mouseup', onMouseUp);
                }
            };

            // B·∫Øt s·ª± ki·ªán MouseDown v√†o thanh resizer
            resizer.addEventListener('mousedown', function (e) {
                e.preventDefault();
                e.stopPropagation(); // NgƒÉn s·ª± ki·ªán lan xu·ªëng c√°c element b√™n d∆∞·ªõi

                detailPanelResizing = true;
                detailPanelStartY = e.clientY;
                detailPanelStartHeight = panel.offsetHeight;
                document.body.classList.add('resizing');

                // FIX: D√πng addEventListener ƒë·ªÉ kh√¥ng xung ƒë·ªôt v·ªõi c√°c th∆∞ vi·ªán kh√°c
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);
            });
        }

        // NOTE: renderPlanView() is defined later (line 1212) and renders the full plan view
        // with grids, beams, columns. highlightSpan() calls it directly.
        // Highlight span - ONLY re-render plan view, NOT renderCanvas() 
        // This prevents plan view from turning into span view when highlighting
        function highlightSpan(index) {
            if (highlightedSpanIndex === index) return;
            highlightedSpanIndex = index;

            // Update table row highlighting
            document.querySelectorAll('.span-row').forEach((tr, i) => {
                tr.classList.toggle('highlighted', parseInt(tr.dataset.spanIndex) === index);
            });

            renderPlanView();  // Main canvas - always plan view
            renderDetailCanvas();  // Detail canvas - current detail mode

            // AUTO HIGHLIGHT IN CAD: send handles to C#
            const span = currentGroup?.Spans?.[index];
            if (span?.Segments?.length > 0) {
                const handles = span.Segments.map(s => s.EntityHandle).filter(h => h);
                if (handles.length > 0) {
                    window.chrome.webview.postMessage('HIGHLIGHT|' + JSON.stringify(handles));
                }
            }
        }

        function clearHighlight() {
            if (highlightedSpanIndex === -1) return;
            highlightedSpanIndex = -1;
            document.querySelectorAll('.span-row').forEach(tr => tr.classList.remove('highlighted'));
            renderPlanView();  // Main canvas - always plan view
            renderDetailCanvas();  // Detail canvas - current detail mode
        }

        function updateDetailPanelWidth() {
            const detailPanel = document.getElementById('detailPanel');
            if (!detailPanel) return;

            // Adjust right edge based on sidebar state
            if (rightSidebarCollapsed) {
                detailPanel.style.right = '0px';
            } else {
                detailPanel.style.right = '320px'; // w-80 = 320px
            }

            resizeDetailCanvas();
        }

        function setDetailMode(mode) {
            detailMode = mode;

            // Toggle active state for tabs
            const tabLong = document.getElementById('tabLong');
            const tabSection = document.getElementById('tabSection');
            const tabShear = document.getElementById('tabShear');

            tabLong?.classList.toggle('bg-blue-600', mode === 'long');
            tabLong?.classList.toggle('bg-slate-600', mode !== 'long');
            tabSection?.classList.toggle('bg-blue-600', mode === 'section');
            tabSection?.classList.toggle('bg-slate-600', mode !== 'section');
            tabShear?.classList.toggle('bg-blue-600', mode === 'shear');
            tabShear?.classList.toggle('bg-slate-600', mode !== 'shear');

            // Reset detail zoom/pan
            detailZoom = 1.0;
            detailPanX = 0;
            detailPanY = 0;

            renderDetailCanvas();
        }

        function showCalculationReport(spanIndex = -1) {
            if (window.chrome?.webview) {
                const payload = {
                    GroupIndex: currentGroupIndex,
                    SpanIndex: spanIndex,
                    Groups: data.groups
                };
                window.chrome.webview.postMessage('SHOW_REPORT|' + JSON.stringify(payload));
            } else {
                console.warn('WebView2 not found. Cannot show report.');
            }
        }


        function resetDetailCanvasView() {
            detailZoom = 1.0;
            detailPanX = 0;
            detailPanY = 0;
            renderDetailCanvas();
            centerDetailCanvas();
        }

        function centerDetailCanvas() {
            const canvas = document.getElementById('detailCanvas');
            if (!canvas || detailSpanBounds.length === 0) return;

            const minX = Math.min(...detailSpanBounds.map(b => b.x));
            const maxX = Math.max(...detailSpanBounds.map(b => b.x + b.width));
            const minY = Math.min(...detailSpanBounds.map(b => b.y));
            const maxY = Math.max(...detailSpanBounds.map(b => b.y + b.height));

            const contentCenterX = (minX + maxX) / 2;
            const contentCenterY = (minY + maxY) / 2;

            detailPanX = canvas.width / 2 - contentCenterX * detailZoom;
            detailPanY = canvas.height / 2 - contentCenterY * detailZoom;

            renderDetailCanvas();
        }



        function renderDetailCanvas() {
            const canvas = document.getElementById('detailCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const dpr = window.devicePixelRatio || 1;
            const lw = canvas.width / dpr;
            const lh = canvas.height / dpr;

            // Clear using logical scale
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, lw, lh);

            if (!currentGroup?.Spans?.length) {
                ctx.fillStyle = '#94a3b8';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Kh√¥ng c√≥ d·ªØ li·ªáu nh·ªãp', lw / 2, lh / 2);
                return;
            }

            // Reset bounds
            detailSpanBounds = [];
            detailRebarLabelBounds = [];
            sectionLabelBounds = [];

            // Route to existing render functions based on mode
            // We reuse the existing renderCanvas logic but target detailCanvas
            const oldMode = canvasMode;
            canvasMode = detailMode; // Temporarily set mode for render function

            // Use the modified renderCanvas that renders to detail canvas
            renderCanvasToDetailPanel(ctx, canvas);

            canvasMode = oldMode; // Restore
        }

        // Wrapper to render span views to detail canvas
        function renderCanvasToDetailPanel(ctx, canvas) {
            if (!currentGroup?.Spans?.length) return;

            const spans = currentGroup.Spans;
            const SUPPORT_GAP = 15;
            const equalSpanWidth = FIXED_SPAN_WIDTH;

            let totalWidth = CANVAS_PADDING * 2;
            const spanWidths = spans.map(() => {
                totalWidth += equalSpanWidth + SUPPORT_GAP;
                return equalSpanWidth;
            });

            const dpr = window.devicePixelRatio || 1;
            const lw = canvas.width / dpr;
            const lh = canvas.height / dpr;

            // Clear using logical scale
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, lw, lh);

            // Apply detail zoom and pan
            ctx.save();
            ctx.translate(detailPanX, detailPanY);
            ctx.scale(detailZoom, detailZoom);

            let x = CANVAS_PADDING;
            const beamY = 90;

            // Draw beams (same as original renderCanvas)
            spans.forEach((span, i) => {
                const w = spanWidths[i];

                if (i === 0) {
                    drawSupport(ctx, x, beamY);
                    x += 5;
                }

                detailSpanBounds.push({ x, y: beamY, width: w, height: BEAM_HEIGHT, index: i });

                const isHighlighted = i === highlightedSpanIndex;
                ctx.fillStyle = isHighlighted ? '#dbeafe' : '#e2e8f0';
                ctx.strokeStyle = isHighlighted ? '#3b82f6' : '#64748b';
                ctx.lineWidth = isHighlighted ? 2 : 1;
                ctx.fillRect(x, beamY, w, BEAM_HEIGHT);
                ctx.strokeRect(x, beamY, w, BEAM_HEIGHT);

                // Draw rebar lines
                drawRebarLines(ctx, x, beamY, w, span);

                // Draw labels based on detail mode
                if (detailMode === 'long') {
                    drawLongRebarLabels(ctx, x, w, beamY, span, i);
                } else if (detailMode === 'section') {
                    drawSectionLabels(ctx, x, w, beamY, span, i);
                } else if (detailMode === 'shear') {
                    drawShearLabels(ctx, x, w, beamY, span, i);
                }

                // Span label (center of beam) - Format: "S1 | 2GY2 üîí" or "S1 | üîì"
                // FIX: Fallback v·ªÅ currentGroup.Name ƒë·ªÉ th·ªëng nh·∫•t v·ªõi sidebar table
                const sectionLabel = span.xSectionLabel || currentGroup.Name || '';
                const isLocked = span.xSectionLabelLocked === true;
                const lockIcon = isLocked ? ' üîí' : ' üîì'; // Always show icon at END
                const fullLabel = `${span.SpanId} | ${sectionLabel}${lockIcon}`;

                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const labelY = beamY + BEAM_HEIGHT / 2 + 4;
                ctx.fillText(fullLabel, x + w / 2, labelY);

                // Register bounds for section label editing (click on label text, not icon)
                const fullWidth = ctx.measureText(fullLabel).width;
                const prefixWidth = ctx.measureText(span.SpanId + ' | ').width;
                const labelTextWidth = ctx.measureText(sectionLabel).width;
                const separatorX = x + w / 2 - fullWidth / 2 + prefixWidth;

                sectionLabelBounds.push({
                    x: separatorX,
                    y: labelY - 8,
                    width: labelTextWidth > 0 ? labelTextWidth : 40, // Min width for empty label
                    height: 16,
                    spanIndex: i,
                    label: sectionLabel,
                    isLocked: isLocked,
                    lockIconWidth: 0 // Icon is now part of the fullLabel, not a separate clickable element for editing the text
                });

                // Dimension + Section label (1 d√≤ng below beam)
                ctx.fillStyle = '#475569';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'center';
                const dimSizeText = `L=${(span.Length || 0).toFixed(2)} | ${span.Width || 0}√ó${span.Height || 0}`;
                ctx.fillText(dimSizeText, x + w / 2, beamY + BEAM_HEIGHT + 42);

                x += w + SUPPORT_GAP;

                // End support
                drawSupport(ctx, x - SUPPORT_GAP, beamY);
            });

            ctx.restore();
        }

        // Helper functions for drawing labels by mode (reuse existing logic)
        function drawLongRebarLabels(ctx, x, w, beamY, span, i) {
            // Reuse existing long rebar label drawing code
            const labelXs = [x + w * 0.20, x + w * 0.50, x + w * 0.80];
            const labelPos = [0, 2, 4];
            const maxLayers = data.settings?.MaxLayers || 2;

            const topBaseY = beamY + 12;
            const botBaseY = beamY + BEAM_HEIGHT - 12;

            // Editable rebar labels (backbone)
            for (let li = 0; li < labelXs.length; li++) {
                const cx = labelXs[li];
                const pos = labelPos[li];
                drawEditableLabelDetail(ctx, getLayerRebarText(span, 'Top', 0, pos), cx, topBaseY, '#ef4444', { spanIndex: i, type: 'Top', layer: 0, pos });
                drawEditableLabelDetail(ctx, getLayerRebarText(span, 'Bot', 0, pos), cx, botBaseY, '#3b82f6', { spanIndex: i, type: 'Bot', layer: 0, pos });
            }

            // Reinforcement layers
            for (let layer = 1; layer < maxLayers; layer++) {
                const dy = 14 * layer;
                const topY = topBaseY + dy;
                const botY = botBaseY - dy;
                for (let li = 0; li < labelXs.length; li++) {
                    const cx = labelXs[li];
                    const pos = labelPos[li];
                    drawEditableLabelDetail(ctx, getLayerRebarText(span, 'Top', layer, pos), cx, topY, '#f97316', { spanIndex: i, type: 'Top', layer, pos });
                    drawEditableLabelDetail(ctx, getLayerRebarText(span, 'Bot', layer, pos), cx, botY, '#0ea5e9', { spanIndex: i, type: 'Bot', layer, pos });
                }
            }

            // Required labels (outside beam): As_prv/As_req with deficit highlight
            const reqTopY = beamY - 20;
            const reqBotY = beamY + BEAM_HEIGHT + 28;
            const posNames = ['L', 'M', 'R'];
            for (let li = 0; li < labelXs.length; li++) {
                const cx = labelXs[li];
                const pn = posNames[li];
                const topRatio = getAsRatioResult(span, 'Top', pn);
                const botRatio = getAsRatioResult(span, 'Bot', pn);
                drawInfoLabelDetail(ctx, topRatio.text, cx, reqTopY, '#b91c1c', topRatio.isDeficit);
                drawInfoLabelDetail(ctx, botRatio.text, cx, reqBotY, '#1d4ed8', botRatio.isDeficit);
            }
        }

        // Info label for As_prv/As_req (read-only with border, deficit highlight)
        // Updated style to match Editable Label (Bold, Radius 3, Fill)
        function drawInfoLabelDetail(ctx, text, x, y, color, isDeficit) {
            if (!text) return;

            // FIX: Bold font, Radius 3
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const width = ctx.measureText(text).width + 10;
            const height = 16;
            const rx = x - width / 2;
            const ry = y - height / 2;
            const radius = 3;

            // Draw rounded rectangle background
            ctx.beginPath();
            ctx.roundRect(rx, ry, width, height, radius);

            if (isDeficit) {
                ctx.fillStyle = '#fee2e2'; // Light red fill
                ctx.fill();
                ctx.strokeStyle = '#ef4444'; // Red border
                ctx.lineWidth = 1.5;
                ctx.stroke();
                ctx.fillStyle = '#dc2626'; // Red text
            } else {
                ctx.fillStyle = '#fff';
                ctx.fill();
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.fillStyle = color;
            }

            ctx.fillText(text, x, y);
        }

        function drawSectionLabels(ctx, x, w, beamY, span, i) {
            // Section view labels (simplified)
            ctx.fillStyle = '#64748b';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Section View', x + w / 2, beamY + BEAM_HEIGHT / 2);
        }

        function drawShearLabels(ctx, x, w, beamY, span, i) {
            // Shear/Web view - draw stirrup and webbar labels
            const labelXs = [x + w * 0.18, x + w * 0.50, x + w * 0.82];
            const labelPos = [0, 1, 2];
            const stirY = beamY + BEAM_HEIGHT / 2 - 8;
            const webY = beamY + BEAM_HEIGHT / 2 + 8;

            for (let li = 0; li < labelXs.length; li++) {
                const cx = labelXs[li];
                const pos = labelPos[li];
                drawEditableLabelDetail(ctx, getStirrupText(span, pos), cx, stirY, '#475569', { spanIndex: i, type: 'Stirrup', pos });
                drawEditableLabelDetail(ctx, getWebBarText(span, pos), cx, webY, '#64748b', { spanIndex: i, type: 'WebBar', pos });
            }
        }

        function drawEditableLabelDetail(ctx, text, x, y, color, meta) {
            // ALWAYS draw label even if empty - show placeholder "-" for editing
            const displayText = (text && text !== '-' && text.trim() !== '') ? text : '-';

            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Use consistent width for all labels (empty or filled) for visual alignment
            const textWidth = ctx.measureText(displayText).width;
            const width = Math.max(textWidth + 10, 28); // Min 28px for clickable area
            const height = 16;
            const rx = x - width / 2;
            const ry = y - height / 2;
            const radius = 3;

            // Draw rounded rectangle background - SAME STYLE for all labels
            ctx.beginPath();
            ctx.roundRect(rx, ry, width, height, radius);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.stroke();

            // Draw text - use same color for consistency
            ctx.fillStyle = color;
            ctx.fillText(displayText, x, y);

            detailRebarLabelBounds.push({ x: rx, y: ry, width, height, ...meta });
        }

        // ============ PLAN VIEW FUNCTIONS ============
        function populateStoryDropdown() {
            const select = document.getElementById('storySelect');
            select.innerHTML = '';

            // Extract unique Z levels from allBeams (independent from groups)
            const allBeams = data.allBeams || [];
            const allZLevels = new Set();

            // Fix: Round Z to nearest 10mm to avoid float precision issues creating duplicate stories
            allBeams.forEach(b => {
                if (b.LevelZ != null) {
                    const z = Math.round(b.LevelZ / 10) * 10;
                    allZLevels.add(z);
                }
            });

            // Also ensure current group's Z is included
            if (currentGroup && currentGroup.LevelZ != null) {
                const z = Math.round(currentGroup.LevelZ / 10) * 10;
                allZLevels.add(z);
            }

            const sortedZ = Array.from(allZLevels).sort((a, b) => a - b);

            if (sortedZ.length === 0) {
                sortedZ.push(0);
            }

            // Determine best default Z
            let defaultZ = Beam.State.currentStoryZ;

            // If current Z is invalid or null, try to match current Group, or fallback to first
            if (defaultZ == null || !allZLevels.has(defaultZ)) {
                if (currentGroup && currentGroup.LevelZ != null) {
                    const target = Math.round(currentGroup.LevelZ / 10) * 10;
                    if (allZLevels.has(target)) defaultZ = target;
                    else defaultZ = sortedZ[0];
                } else {
                    defaultZ = sortedZ[0];
                }
            }

            // Populate options
            sortedZ.forEach((z, i) => {
                const opt = document.createElement('option');
                opt.value = z;
                // Display in Meters for cleaner UI
                const zM = (z / 1000).toFixed(1);
                opt.textContent = `Story ${i + 1} (Z=${zM}m)`;
                select.appendChild(opt);
            });

            // Set state and select value
            Beam.State.currentStoryZ = defaultZ;
            select.value = defaultZ;
        }

        function loadStory(z) {
            Beam.State.currentStoryZ = parseFloat(z);

            // FIX: Re-populate group dropdown to show only groups on this story
            populateGroupSelect();

            // Load first group on this story if any
            const groupsOnStory = getGroupsOnCurrentStory();
            if (groupsOnStory.length > 0) {
                loadGroup(groupsOnStory[0].originalIndex);
            }

            renderPlanView();
        }

        // Helper: Get groups on current story
        function getGroupsOnCurrentStory() {
            const z = Beam.State.currentStoryZ;
            const Z_TOL = 500;
            if (!data.groups) return [];
            return data.groups
                .map((g, i) => ({ ...g, originalIndex: i }))
                .filter(g => Math.abs((g.LevelZ || 0) - z) < Z_TOL);
        }

        function renderPlanView() {
            const canvas = document.getElementById('beamCanvas');
            const ctx = canvas.getContext('2d');

            // CRITICAL: Plan View reads from data.allBeams, NOT data.groups
            // This ensures independence from grouping logic
            const allBeams = data.allBeams || [];

            if (allBeams.length === 0) {
                ctx.fillStyle = '#f8fafc';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#94a3b8';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Kh√¥ng c√≥ d·ªØ li·ªáu m·∫∑t b·∫±ng', canvas.width / 2, canvas.height / 2);
                return;
            }

            const z = Beam.State.currentStoryZ;
            const Z_TOLERANCE = 500;

            // Clear canvas BEFORE filtering
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Filter beams for current story - read directly from allBeams
            const beamsOnStory = allBeams.filter(b => {
                const beamZ = b.LevelZ || 0;
                return Math.abs(beamZ - z) < Z_TOLERANCE;
            });

            if (beamsOnStory.length === 0) {
                // Background already cleared
                ctx.fillStyle = '#94a3b8';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`Kh√¥ng c√≥ d·∫ßm ·ªü t·∫ßng Z=${z}`, canvas.width / 2, canvas.height / 2);
                return;
            }

            // Collect axis names for grid lines
            const axisNames = new Set();
            beamsOnStory.forEach(b => {
                if (b.AxisName) axisNames.add(b.AxisName);
            });

            // Detect column points at beam endpoints (for orange circle markers)
            const columnPoints = [];
            beamsOnStory.forEach(b => {
                // Add both endpoints - these show beam-column connection points
                columnPoints.push({ x: b.StartX, y: b.StartY });
                columnPoints.push({ x: b.EndX, y: b.EndY });
            });

            // FIX: Move grid filtering up before bounds calculation
            const gridsOnStory = (data.allGrids || []).filter(grid => {
                const gridLevelZ = grid.LevelZ || grid.Z || 0;
                return Math.abs(gridLevelZ - z) < Z_TOLERANCE;
            });

            // Collect all points for bounds (beams + grids)
            const ptsX = beamsOnStory.flatMap(b => [b.StartX, b.EndX]);
            const ptsY = beamsOnStory.flatMap(b => [b.StartY, b.EndY]);

            gridsOnStory.forEach(g => {
                ptsX.push(g.StartX, g.EndX);
                ptsY.push(g.StartY, g.EndY);
            });

            const minX = Math.min(...ptsX);
            const maxX = Math.max(...ptsX);
            const minY = Math.min(...ptsY);
            const maxY = Math.max(...ptsY);

            const contentW = maxX - minX || 1000;
            const contentH = maxY - minY || 1000;

            // Padding for labels and axis text
            const PADDING = 100;

            // logical dimensions for centering calculations
            const dpr = window.devicePixelRatio || 1;
            const lw = canvas.width / dpr;
            const lh = canvas.height / dpr;

            // Scale to fit canvas (base scale)
            const scaleX = (lw - PADDING * 2) / contentW;
            const scaleY = (lh - PADDING * 2) / contentH;
            const baseScale = Math.min(scaleX, scaleY, 1.0); // Don't scale up too much

            // Center content in canvas
            const baseOffsetX = (lw - contentW * baseScale) / 2 - minX * baseScale;
            const baseOffsetY = (lh - contentH * baseScale) / 2 - minY * baseScale;

            // NEW: Sync shared transform for hit-testing
            planTransform = { baseScale, baseOffsetX, baseOffsetY, lw, lh };

            // Apply interactive zoom and pan
            const tx = x => (x * baseScale + baseOffsetX) * canvasZoom + canvasPanX;
            const ty = y => (lh - (y * baseScale + baseOffsetY)) * canvasZoom + canvasPanY;

            // Clear using logical coordinates
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, lw, lh);


            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.font = '10px sans-serif';
            ctx.fillStyle = '#64748b';

            gridsOnStory.forEach(grid => {
                ctx.beginPath();
                ctx.moveTo(tx(grid.StartX), ty(grid.StartY));
                ctx.lineTo(tx(grid.EndX), ty(grid.EndY));
                ctx.stroke();

                // Draw grid label: Name and Coordinate on SAME side
                if (grid.Name) {
                    ctx.save();
                    ctx.font = 'bold 12px sans-serif';
                    ctx.fillStyle = '#1e293b';
                    ctx.textAlign = 'center';

                    // Format coordinate (convert from mm to m if > 1000)
                    const coordText = grid.Coordinate > 1000
                        ? `${(grid.Coordinate / 1000).toFixed(1)}m`
                        : `${grid.Coordinate.toFixed(0)}`;

                    if (grid.Orientation === 'X') {
                        // Vertical grid: Name and coordinate at TOP
                        ctx.fillText(grid.Name, tx(grid.StartX), ty(grid.StartY) - 25);
                        ctx.font = '10px sans-serif';
                        ctx.fillStyle = '#64748b';
                        ctx.fillText(coordText, tx(grid.StartX), ty(grid.StartY) - 10);

                        // Only name at bottom
                        ctx.font = 'bold 12px sans-serif';
                        ctx.fillStyle = '#1e293b';
                        ctx.fillText(grid.Name, tx(grid.EndX), ty(grid.EndY) + 20);
                    } else {
                        // Horizontal grid: Name and coordinate at LEFT
                        ctx.textAlign = 'right';
                        ctx.fillText(grid.Name, tx(grid.StartX) - 15, ty(grid.StartY) - 5);
                        ctx.font = '10px sans-serif';
                        ctx.fillStyle = '#64748b';
                        ctx.fillText(coordText, tx(grid.StartX) - 15, ty(grid.StartY) + 8);

                        // Only name at right
                        ctx.font = 'bold 12px sans-serif';
                        ctx.fillStyle = '#1e293b';
                        ctx.textAlign = 'left';
                        ctx.fillText(grid.Name, tx(grid.EndX) + 15, ty(grid.EndY) + 5);
                    }
                    ctx.restore();
                }
            });
            ctx.setLineDash([]);

            // Draw beams
            beamsOnStory.forEach((b, idx) => {
                // FIX: Use EntityHandles membership for group highlighting
                // Also support Tab cycling with selectedBeamIndex
                const handles = currentGroup?.EntityHandles || [];
                const isInGroup = handles.includes(b.Handle);

                // Highlight logic: 
                // - highlightedSpanIndex >= 0: highlight beam at that index (from sidebar/detail click)
                // - selectedBeamIndex >= 0: highlight beam at that index (from Tab cycling)
                // - Both == -1: highlight all beams in group
                let isHighlighted = false;
                if (isInGroup) {
                    const beamIndexInGroup = handles.indexOf(b.Handle);

                    // Check if this beam matches highlightedSpanIndex (sidebar/detail selection)
                    if (highlightedSpanIndex >= 0 && beamIndexInGroup === highlightedSpanIndex) {
                        isHighlighted = true;
                    }
                    // Check if this beam matches selectedBeamIndex (Tab cycling)
                    else if (selectedBeamIndex >= 0 && beamIndexInGroup === selectedBeamIndex) {
                        isHighlighted = true;
                    }
                    // If neither is set, highlight all beams in group
                    else if (highlightedSpanIndex === -1 && selectedBeamIndex === -1) {
                        isHighlighted = true;
                    }
                }

                // Check if beam is selected by box selection
                const isChosen = Beam.State.isHandleSelected(b.Handle);

                // Determine stroke style based on selection priority
                let strokeStyle = '#475569';
                let lineWidth = 2;

                if (isChosen) {
                    // Selected by box selection: m√†u cam (gi·ªëng index.html)
                    strokeStyle = '#f97316';
                    lineWidth = 4;
                } else if (isHighlighted) {
                    // Highlighted by group/span selection
                    strokeStyle = '#3b82f6';
                    lineWidth = 4;
                } else if (isInGroup) {
                    // Part of current group
                    strokeStyle = '#93c5fd';
                    lineWidth = 3;
                }

                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                ctx.moveTo(tx(b.StartX), ty(b.StartY));
                ctx.lineTo(tx(b.EndX), ty(b.EndY));
                ctx.stroke();
            });

            // Draw columns from AutoCAD layer (dts_point) 
            // FIX: Use same Z_TOLERANCE (500mm) as beam filtering for consistency
            const columnsOnStory = (data.allColumns || []).filter(col => {
                const colZ = col.Z || 0;
                return Math.abs(colZ - z) < Z_TOLERANCE;  // Use same tolerance as beams
            });

            columnsOnStory.forEach(col => {
                const cx = col.X;
                const cy = col.Y;
                const w = col.Width || 400;
                const d = col.Depth || 400;  // Use Depth instead of Height
                const sectionType = (col.SectionType || 'Rectangular').toUpperCase();

                ctx.save();

                // Colors for columns
                ctx.fillStyle = 'rgba(100, 116, 139, 0.2)';  // Gray with transparency
                ctx.strokeStyle = '#475569';
                ctx.lineWidth = 2;

                // Draw based on section type
                if (sectionType === 'RECTANGULAR' || sectionType === 'RECT') {
                    drawRectColumn(ctx, cx, cy, w, d);
                } else if (sectionType === 'CIRCULAR' || sectionType === 'CIRCLE' || sectionType === 'PIPE') {
                    drawCircleColumn(ctx, cx, cy, Math.max(w, d) / 2);
                } else if (sectionType.includes('I') || sectionType.includes('H')) {
                    drawIColumn(ctx, cx, cy, w, d);
                } else if (sectionType.includes('BOX')) {
                    drawBoxColumn(ctx, cx, cy, w, d);
                } else if (sectionType.includes('CHANNEL') || sectionType.includes('C')) {
                    drawChannelColumn(ctx, cx, cy, w, d);
                } else {
                    // Default: rectangle
                    drawRectColumn(ctx, cx, cy, w, d);
                }

                ctx.restore();
            });

            // Helper functions for column drawing
            function drawRectColumn(ctx, cx, cy, w, h) {
                // Center-based rectangle
                const halfW = (w * baseScale * canvasZoom) / 2;
                const halfH = (h * baseScale * canvasZoom) / 2;
                const x = tx(cx) - halfW;
                const y = ty(cy) - halfH;
                const width = w * baseScale * canvasZoom;
                const height = h * baseScale * canvasZoom;

                ctx.fillRect(x, y, width, height);
                ctx.strokeRect(x, y, width, height);
            }

            function drawCircleColumn(ctx, cx, cy, radius) {
                ctx.beginPath();
                ctx.arc(tx(cx), ty(cy), radius * baseScale * canvasZoom, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }

            function drawIColumn(ctx, cx, cy, w, h) {
                // Simplified I-section: just draw as rectangle for now
                // Complex shapes need more careful coordinate handling
                drawRectColumn(ctx, cx, cy, w, h);
            }

            function drawBoxColumn(ctx, cx, cy, w, h) {
                // Hollow rectangle - draw outer then inner
                const thickness = Math.min(w, h) * 0.15;

                // Outer rectangle
                drawRectColumn(ctx, cx, cy, w, h);

                // Inner rectangle (clear with background color)
                ctx.save();
                ctx.fillStyle = '#f8fafc';  // Background color
                drawRectColumn(ctx, cx, cy, w - 2 * thickness, h - 2 * thickness);
                ctx.restore();
            }

            function drawChannelColumn(ctx, cx, cy, w, h) {
                // Simplified C-section: draw as rectangle for now
                drawRectColumn(ctx, cx, cy, w, h);
            }

            // Draw beam endpoints (small circles at support points)
            // These indicate where beams connect to columns
            const uniqueColumns = [];
            columnPoints.forEach(cp => {
                const exists = uniqueColumns.some(uc =>
                    Math.abs(uc.x - cp.x) < 100 && Math.abs(uc.y - cp.y) < 100
                );
                if (!exists) uniqueColumns.push(cp);
            });

            ctx.fillStyle = '#f59e0b';
            ctx.strokeStyle = '#78350f';
            ctx.lineWidth = 1;
            uniqueColumns.forEach(c => {
                ctx.beginPath();
                ctx.arc(tx(c.x), ty(c.y), 3, 0, Math.PI * 2);  // Small circle (3px radius)
                ctx.fill();
                ctx.stroke();
            });

            // Legend
            ctx.fillStyle = '#1e293b';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`Plan View - Z=${z} | ${beamsOnStory.length} beams | ${gridsOnStory.length} grids | ${columnsOnStory.length} columns`, 10, 20);

            // ================== LABEL RENDERING (3 modes) ==================
            // Calculate effective label scale (base scale * canvasZoom if lockTextZoom is on)
            const effectiveLabelScale = lockTextZoom ? planLabelScale * canvasZoom : planLabelScale;

            // Label Mode 1: GROUP NAME (1 nh√£n duy nh·∫•t per group, ƒë·∫∑t tr√™n d·∫ßm gi·ªØa)
            if (labelMode === 1 && data.groups) {
                ctx.save();
                const fontSize = (lockTextZoom ? 10 * effectiveLabelScale : 10 * planLabelScale);
                ctx.font = `bold ${fontSize}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // L·ªçc groups tr√™n t·∫ßng hi·ªán t·∫°i
                const groupsOnStory = data.groups.filter(g => Math.abs((g.LevelZ || 0) - z) < Z_TOLERANCE);

                groupsOnStory.forEach(group => {
                    if (!group.EntityHandles || group.EntityHandles.length === 0) return;

                    // T√¨m c√°c d·∫ßm thu·ªôc group tr√™n m·∫∑t b·∫±ng
                    const groupBeams = beamsOnStory.filter(b => group.EntityHandles.includes(b.Handle));
                    if (groupBeams.length === 0) return;

                    // Ch·ªçn d·∫ßm gi·ªØa (ho·∫∑c g·∫ßn gi·ªØa nh·∫•t)
                    const midIndex = Math.floor(groupBeams.length / 2);
                    const b = groupBeams[midIndex];

                    const midX = (b.StartX + b.EndX) / 2;
                    const midY = (b.StartY + b.EndY) / 2;
                    const screenX = tx(midX);
                    const screenY = ty(midY);

                    // XOAY TEXT theo h∆∞·ªõng d·∫ßm
                    const dx = b.EndX - b.StartX;
                    const dy = b.EndY - b.StartY;
                    let angle = Math.atan2(dy, dx);

                    // Chu·∫©n h√≥a g√≥c ƒë·ªÉ text kh√¥ng b·ªã ng∆∞·ª£c
                    if (angle > Math.PI / 2) angle -= Math.PI;
                    else if (angle < -Math.PI / 2) angle += Math.PI;

                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(-angle);

                    const label = group.GroupName || `Group ${(group.originalIndex || 0) + 1}`;
                    const isSelected = (currentGroup === group) || (currentGroupIndex === group.originalIndex);

                    // Stroke vi·ªÅn tr·∫Øng cho d·ªÖ ƒë·ªçc
                    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                    ctx.lineWidth = 3;
                    ctx.strokeText(label, 0, -6);

                    // Fill text - m√†u kh√°c n·∫øu ƒëang ch·ªçn
                    ctx.fillStyle = isSelected ? '#2563eb' : '#0f172a';
                    ctx.fillText(label, 0, -6);

                    ctx.restore();
                });
                ctx.restore();


            } else if (labelMode === 2) {
                // Clean old bounds
                planSectionLabelBounds = [];
                planLockBounds = [];

                beamsOnStory.forEach(b => {
                    const midX = (b.StartX + b.EndX) / 2;
                    const midY = (b.StartY + b.EndY) / 2;
                    const screenX = tx(midX);
                    const screenY = ty(midY);

                    // XOAY TEXT: T√≠nh g√≥c nghi√™ng
                    const dx = b.EndX - b.StartX;
                    const dy = b.EndY - b.StartY;
                    let angle = Math.atan2(dy, dx);

                    // Chu·∫©n h√≥a g√≥c ƒë·ªÉ text kh√¥ng b·ªã ng∆∞·ª£c
                    if (angle > Math.PI / 2) angle -= Math.PI;
                    else if (angle < -Math.PI / 2) angle += Math.PI;

                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(-angle);

                    // FIX D·ªÆ LI·ªÜU: ∆Øu ti√™n xSectionLabel -> SectionLabel -> "-"
                    let label = b.xSectionLabel || b.SectionLabel;
                    if (!label || label.trim() === '') {
                        label = '-';
                    }

                    // 1. V·∫Ω Nh√£n (Text) - S·ª≠ d·ª•ng effectiveLabelScale
                    const scaledFontSize = 10 * effectiveLabelScale;
                    ctx.font = `bold ${scaledFontSize}px sans-serif`;
                    ctx.textAlign = 'center'; // FIX Alignment
                    const textWidth = ctx.measureText(label).width;
                    const labelW = Math.max(textWidth + 8, 24 * effectiveLabelScale);
                    const labelH = 14 * effectiveLabelScale;
                    const lx = -labelW / 2;
                    const ly = -12 * effectiveLabelScale; // Offset l√™n tr√™n tr·ª•c d·∫ßm

                    // L∆∞u bounds (Screen-relative coordinates for hit testing)
                    planSectionLabelBounds.push({
                        handle: b.Handle,
                        label: label,
                        cx: screenX,
                        cy: screenY,
                        angle: angle,
                        width: labelW,
                        height: labelH,
                        offsetX: 0,
                        offsetY: -6 * effectiveLabelScale
                    });

                    // Stroke vi·ªÅn tr·∫Øng cho d·ªÖ ƒë·ªçc
                    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                    ctx.lineWidth = 3;
                    ctx.strokeText(label, 0, -6 * effectiveLabelScale);
                    ctx.fillStyle = '#0f172a';
                    ctx.fillText(label, 0, -6 * effectiveLabelScale);

                    // 2. V·∫Ω bi·ªÉu t∆∞·ª£ng kh√≥a (üîí/üîì)
                    const isLocked = !!b.xSectionLabelLocked;
                    const lockIcon = isLocked ? 'üîí' : 'üîì';
                    const lockX = labelW / 2 + 8 * effectiveLabelScale;
                    const lockY = -6 * effectiveLabelScale;

                    ctx.font = `${10 * effectiveLabelScale}px sans-serif`;
                    ctx.fillText(lockIcon, lockX, lockY);

                    planLockBounds.push({
                        handle: b.Handle,
                        isLocked: isLocked,
                        cx: screenX,
                        cy: screenY,
                        angle: angle,
                        width: 18 * effectiveLabelScale, // TƒÉng di·ªán t√≠ch b·∫•m
                        height: 18 * effectiveLabelScale,
                        offsetX: lockX,
                        offsetY: lockY
                    });

                    ctx.restore();

                    ctx.restore();
                });
                ctx.restore();
            }
            // labelMode === 0: Kh√¥ng v·∫Ω label

            // ================== REBAR LABEL RENDERING (rebarMode > 0) ==================
            // Mode mapping gi·ªëng DTS_REBAR_SHOW:
            // 1: Th√©p d·ªçc (Longitudinal)
            // 2: ƒêai + S∆∞·ªùn (Stirrup + Web)
            // 3: So s√°nh As (As_prv/As_req + th√©p d·ªçc)
            // 4: Chi ti·∫øt ƒëai/s∆∞·ªùn
            if (rebarMode > 0) {
                ctx.save();
                const rebarFontSize = 8 * effectiveLabelScale;
                ctx.font = `${rebarFontSize}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                beamsOnStory.forEach(b => {
                    // Calculate beam direction and angle
                    const dx = b.EndX - b.StartX;
                    const dy = b.EndY - b.StartY;
                    let angle = Math.atan2(dy, dx);
                    if (angle > Math.PI / 2) angle -= Math.PI;
                    else if (angle < -Math.PI / 2) angle += Math.PI;

                    const len = Math.sqrt(dx * dx + dy * dy);
                    if (len < 100) return; // Skip very short beams

                    // 3 zones along the beam
                    const zones = [
                        { t: 0.15, label: 'L' },  // Left (start)
                        { t: 0.50, label: 'M' },  // Mid
                        { t: 0.85, label: 'R' }   // Right (end)
                    ];

                    zones.forEach((zone, zIdx) => {
                        const px = b.StartX + dx * zone.t;
                        const py = b.StartY + dy * zone.t;
                        const sx = tx(px);
                        const sy = ty(py);

                        ctx.save();
                        ctx.translate(sx, sy);
                        ctx.rotate(-angle);

                        // Get rebar strings for this zone
                        const topRS = b.TopRS ? (b.TopRS[zIdx] || '') : '';
                        const botRS = b.BotRS ? (b.BotRS[zIdx] || '') : '';
                        const stirRS = b.StirRS ? (b.StirRS[zIdx] || '') : '';
                        const webRS = b.WebRS ? (b.WebRS[zIdx] || '') : '';

                        // Get required areas
                        const posIdx = zIdx * 2; // 0, 2, 4
                        const asTopReq = b.As_Top ? (b.As_Top[posIdx] || 0) : 0;
                        const asBotReq = b.As_Bot ? (b.As_Bot[posIdx] || 0) : 0;
                        const asTopProv = parseRebarArea(topRS);
                        const asBotProv = parseRebarArea(botRS);

                        // Check errors
                        const topErr = asTopProv < asTopReq * 0.99;
                        const botErr = asBotProv < asBotReq * 0.99;

                        // Draw text offsets
                        const yOffsetTop = -12 * effectiveLabelScale;
                        const yOffsetBot = 10 * effectiveLabelScale;
                        // G·∫ßn h∆°n 50%: thay v√¨ -24 th√†nh -18 (g·∫ßn top h∆°n)
                        const yOffsetTop2 = -18 * effectiveLabelScale; // Comparison line above (s√°t h∆°n)
                        const yOffsetBot2 = 16 * effectiveLabelScale;  // Comparison line below (s√°t h∆°n)

                        // Helper function to draw rebar text
                        function drawRebarText(text, yOffset, isError, fontScale = 1.0, isComparison = false) {
                            if (!text || text === '') return;
                            const fontSize = rebarFontSize * fontScale;
                            // B·ªé in nghi√™ng theo y√™u c·∫ßu
                            ctx.font = `${fontSize}px sans-serif`;
                            ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                            ctx.lineWidth = 2;
                            ctx.strokeText(text, 0, yOffset);

                            // M√†u s·∫Øc: isComparison -> xanh/ƒë·ªè nh·∫π, else -> x√°m ƒë·∫≠m/ƒë·ªè ƒë·∫≠m
                            if (isComparison) {
                                // Xanh nh·∫π (#3b82f6) ho·∫∑c ƒê·ªè nh·∫π (#f87171)
                                ctx.fillStyle = isError ? '#f87171' : '#3b82f6';
                            } else {
                                // X√°m ƒë·∫≠m (#1f2937) ho·∫∑c ƒê·ªè ƒë·∫≠m (#dc2626)
                                ctx.fillStyle = isError ? '#dc2626' : '#1f2937';
                            }

                            ctx.fillText(text, 0, yOffset);
                            // Reset font
                            ctx.font = `${rebarFontSize}px sans-serif`;
                        }

                        // ========== MODE 1: LONGITUDINAL (Th√©p d·ªçc) ==========
                        if (rebarMode === 1) {
                            drawRebarText(topRS, yOffsetTop, topErr);
                            drawRebarText(botRS, yOffsetBot, botErr);
                        }

                        // ========== MODE 2: STIRRUP + WEB (ƒêai + S∆∞·ªùn) ==========
                        else if (rebarMode === 2) {
                            // Hi·ªÉn th·ªã d√π empty (d·∫•u -)
                            const stirDisplay = stirRS || '-';
                            const webDisplay = webRS || '-';
                            drawRebarText(stirDisplay, yOffsetTop, false);
                            drawRebarText(webDisplay, yOffsetBot, false);
                        }

                        // ========== MODE 3: AS COMPARE (So s√°nh As) ==========
                        else if (rebarMode === 3) {
                            // Hi·ªÉn th·ªã 1 ch·ªØ s·ªë th·∫≠p ph√¢n, size 0.8, m√†u nh·∫π
                            const topAsText = `(${asTopProv.toFixed(1)}/${asTopReq.toFixed(1)})`;
                            const botAsText = `(${asBotProv.toFixed(1)}/${asBotReq.toFixed(1)})`;

                            // As comparison: kh√¥ng nghi√™ng, m√†u nh·∫π (xanh/ƒë·ªè), font 0.8
                            drawRebarText(topAsText, yOffsetTop2, topErr, 0.8, true);
                            drawRebarText(topRS, yOffsetTop, topErr);
                            drawRebarText(botRS, yOffsetBot, botErr);
                            drawRebarText(botAsText, yOffsetBot2, botErr, 0.8, true);
                        }

                        // ========== MODE 4: DETAILED (Chi ti·∫øt ƒëai/s∆∞·ªùn) ==========
                        else if (rebarMode === 4) {
                            // Hi·ªÉn th·ªã c·∫£ stirrup v√† web v·ªõi chi ti·∫øt
                            const stirrupReq = b.StirrupReq ? (b.StirrupReq[zIdx] || 0) : 0;
                            const webReq = b.WebReq ? (b.WebReq[zIdx] || 0) : 0;

                            const stirDisplay = stirRS || '-';
                            // N·∫øu webRS r·ªóng th√¨ hi·ªán [Al=...], n·∫øu c√≥ th√¨ g·ªôp
                            const webDisplay = (webRS && webRS !== '-') ? `${webRS} [${webReq.toFixed(0)}]` : `[Al=${webReq.toFixed(0)}]`;

                            drawRebarText(stirDisplay, yOffsetTop, false);
                            drawRebarText(webDisplay, yOffsetBot, false);
                        }

                        ctx.restore();
                    });
                });
                ctx.restore();
            }
        }

        // Mode-aware render wrapper - ALWAYS use renderPlanView for main canvas
        // Main canvas should NEVER show span view, only plan view with grids, beams, columns
        function render() {
            // ALWAYS render plan view for main canvas - no mode check needed
            renderPlanView();
            updateOverlayPositions();

            // Update Elements panel to reflect selection changes
            if (typeof updateElementsPanel === 'function') updateElementsPanel();

            // Draw box selection rectangle AFTER content
            if (Beam.State.boxSelectActive) {
                const canvas = document.getElementById('beamCanvas');
                const ctx = canvas.getContext('2d');
                const { boxSelectStart, boxSelectEnd } = Beam.State;
                const isLeftToRight = boxSelectEnd.x >= boxSelectStart.x;

                const x = Math.min(boxSelectStart.x, boxSelectEnd.x);
                const y = Math.min(boxSelectStart.y, boxSelectEnd.y);
                const w = Math.abs(boxSelectEnd.x - boxSelectStart.x);
                const h = Math.abs(boxSelectEnd.y - boxSelectStart.y);

                ctx.save();
                if (isLeftToRight) {
                    // Window Selection: Blue solid
                    ctx.strokeStyle = '#3b82f6';
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
                    ctx.setLineDash([]);
                } else {
                    // Crossing Selection: Green dashed
                    ctx.strokeStyle = '#22c55e';
                    ctx.fillStyle = 'rgba(34, 197, 94, 0.1)';
                    ctx.setLineDash([5, 3]);
                }
                ctx.lineWidth = 1;
                ctx.fillRect(x, y, w, h);
                ctx.strokeRect(x, y, w, h);
                ctx.restore();
            }
        }

        function autoLockOnEdit() {
            // Block edits when locked
            if (Beam.History.isLocked) return false;

            // Push to history stack BEFORE change
            Beam.History.push();

            // When user manually edits, mark span as user-edited
            if (currentGroup && highlightedSpanIndex >= 0) {
                const span = currentGroup.Spans[highlightedSpanIndex];
                if (span) span._userEdited = true;
            }
            return true;
        }

        function toggleHighlightMode(enabled) {
            highlightModeEnabled = enabled;
            if (enabled) {
                // Immediately set 80% transparent when toggle ON
                window.chrome.webview.postMessage('SET_OPACITY|0.2');
                showToast('‚úì Highlight mode ON - form 80% trong su·ªët');
            } else {
                // Reset to full opacity when toggle OFF
                window.chrome.webview.postMessage('SET_OPACITY|1.0');
                showToast('Highlight mode OFF');
            }
        }

        // Resize canvas to fill container (proper DPI scaling)
        function resizeCanvas() {
            const planContainer = document.getElementById('planCanvasContainer');
            const canvas = document.getElementById('beamCanvas');
            if (planContainer && canvas) {
                const dpr = window.devicePixelRatio || 1;
                const w = planContainer.clientWidth || 800;
                const h = planContainer.clientHeight || 300;

                if (canvas.width !== w * dpr || canvas.height !== h * dpr) {
                    canvas.width = w * dpr;
                    canvas.height = h * dpr;
                    canvas.style.width = w + 'px';
                    canvas.style.height = h + 'px';

                    const ctx = canvas.getContext('2d');
                    ctx.resetTransform();
                    ctx.scale(dpr, dpr);

                    renderPlanView();
                }
            }
        }

        function resizeDetailCanvas() {
            const container = document.getElementById('detailCanvasContainer');
            const canvas = document.getElementById('detailCanvas');
            if (container && canvas) {
                const dpr = window.devicePixelRatio || 1;
                const w = container.clientWidth || 800;
                const h = container.clientHeight || 200;

                if (canvas.width !== w * dpr || canvas.height !== h * dpr) {
                    canvas.width = w * dpr;
                    canvas.height = h * dpr;
                    canvas.style.width = w + 'px';
                    canvas.style.height = h + 'px';

                    const ctx = canvas.getContext('2d');
                    ctx.resetTransform();
                    ctx.scale(dpr, dpr);

                    renderDetailCanvas();
                }
            }
        }

        // Helper to check if screen point is within a rotated rect
        function isPointInRotatedRect(px, py, rect) {
            // 1. Translate point relative to center
            const dx = px - rect.cx;
            const dy = py - rect.cy;

            // 2. Rotate point by inverse angle
            // render uses ctx.rotate(-angle), so to get back to local we rotate by angle
            // But we need to be careful with the coordinate system (Y down)
            const cos = Math.cos(rect.angle);
            const sin = Math.sin(rect.angle);

            // Point rotation formula for local space (inverse of -angle rotation):
            const rx = dx * cos - dy * sin;
            const ry = dx * sin + dy * cos;

            // 3. Check bounds in local coordinate space
            const left = rect.offsetX - rect.width / 2;
            const right = rect.offsetX + rect.width / 2;
            const top = rect.offsetY - rect.height / 2;
            const bottom = rect.offsetY + rect.height / 2;

            return rx >= left && rx <= right && ry >= top && ry <= bottom;
        }

        function init() {
            // FIX: G·ªçi h√†m kh·ªüi t·∫°o resize ngay ƒë·∫ßu ti√™n, b·∫•t ch·∫•p data c√≥ l·ªói hay kh√¥ng
            // V√¨ Panel UI lu√¥n t·ªìn t·∫°i trong DOM
            initDetailPanelResize();

            // Fix: Reset story state on load to ensure stale state doesn't persist
            Beam.State.currentStoryZ = null;

            // Resize canvas with multiple fallbacks for reliable sizing
            // Container may not have size immediately on WebView2 load
            resizeCanvas();
            resizeDetailCanvas();
            requestAnimationFrame(() => { resizeCanvas(); resizeDetailCanvas(); });
            setTimeout(() => { resizeCanvas(); resizeDetailCanvas(); updateOverlayPositions(); }, 100);
            setTimeout(() => { resizeCanvas(); resizeDetailCanvas(); updateOverlayPositions(); }, 500);
            window.addEventListener('resize', () => { hideInlineLabelEditor(); resizeCanvas(); updateDetailPanelWidth(); updateOverlayPositions(); });

            const planContainer = document.getElementById('planCanvasContainer');
            if (planContainer) {
                planContainer.addEventListener('scroll', () => hideInlineLabelEditor());
                planContainer.addEventListener('wheel', () => hideInlineLabelEditor(), { passive: true });
            }

            // Sync material grades from DtsSettings to read-only display
            if (data.settings) {
                const concreteDisp = document.getElementById('concreteDisplay');
                const steelDisp = document.getElementById('steelDisplay');
                if (concreteDisp && data.settings.ConcreteGradeName) {
                    concreteDisp.textContent = data.settings.ConcreteGradeName;
                }
                if (steelDisp && data.settings.SteelGradeName) {
                    // Map CB400-V to CB400, etc.
                    const grade = data.settings.SteelGradeName.replace('-V', '');
                    steelDisp.textContent = grade;
                }
            }

            // Initialize canvas interaction system (inline, no external dependency)
            const canvas = document.getElementById('beamCanvas');
            if (canvas) {
                // NOTE: Inline label editor (labelEditorEl) is created in detailCanvas section 
                // since span editing is now in the sidebar Detail Canvas, not Main Canvas

                // Click: label edit (priority) or span select/copy-format
                // FIX: Only accept left-click (button 0) and ignore if dragged
                canvas.addEventListener('contextmenu', e => e.preventDefault()); // Block context menu
                canvas.addEventListener('click', (e) => {
                    if (isPanDragging) {
                        isPanDragging = false;
                        return;
                    }
                    // Strict check: Click must start AND end with Button 0
                    if (e.button !== 0 || mouseDownButton !== 0) return;

                    const rect = canvas.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;

                    // PRIORITY 1: Check Lock Icon hit (Toggle Lock) - MOVE TO FRONT
                    if (canvasMode === 'plan' && labelMode === 2) {
                        for (const lb of planLockBounds) {
                            if (isPointInRotatedRect(mx, my, lb)) {
                                toggleSectionLockByHandle(lb.handle, e);
                                return; // Stop here!
                            }
                        }
                    }

                    const x = (e.clientX - rect.left - canvasPanX) / canvasZoom;
                    const y = (e.clientY - rect.top - canvasPanY) / canvasZoom;

                    // Label hit => edit (Detail mode rebar labels)
                    if (canvasMode !== 'plan') {
                        for (let i = 0; i < rebarLabelBounds.length; i++) {
                            const lb = rebarLabelBounds[i];
                            if (x >= lb.x && x <= lb.x + lb.width && y >= lb.y && y <= lb.y + lb.height) {
                                startInlineLabelEdit(lb);
                                return;
                            }
                        }
                    }

                    // Skip spanBounds click in Plan mode - Plan mode uses beam-level selection
                    if (canvasMode !== 'plan') {
                        // ... existing spanBounds logic ...
                        for (let i = 0; i < spanBounds.length; i++) {
                            const b = spanBounds[i];
                            if (x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height) {
                                const spanIndex = b.index;
                                // Copy format mode
                                if (copyFormatMode) {
                                    if (!copySourceSpan) {
                                        copySourceSpan = currentGroup.Spans[spanIndex];
                                        showToast('Ch·ªçn nh·ªãp ƒë√≠ch...');
                                    } else {
                                        const dest = currentGroup.Spans[spanIndex];
                                        dest.TopRebar = JSON.parse(JSON.stringify(copySourceSpan.TopRebar || []));
                                        dest.BotRebar = JSON.parse(JSON.stringify(copySourceSpan.BotRebar || []));
                                        dest.Stirrup = [...(copySourceSpan.Stirrup || [])];
                                        copyFormatMode = false;
                                        copySourceSpan = null;
                                        document.body.style.cursor = 'default';
                                        refreshUI();
                                        renderTable();
                                        showToast('‚úì Copied format to ' + dest.SpanId);
                                    }
                                    return;
                                }

                                highlightSpan(spanIndex);

                                // Expand table panel if collapsed
                                const panel = document.getElementById('tablePanel');
                                if (panel && panel.classList.contains('max-h-8')) {
                                    toggleTablePanel(); // Expand it
                                }

                                // Scroll to row within tablePanelContent
                                const row = document.querySelector(`[data-span-index="${spanIndex}"]`);
                                if (row) {
                                    const container = document.getElementById('tablePanelContent');
                                    if (container) {
                                        // Calculate scroll position to center row
                                        const rowTop = row.offsetTop;
                                        const containerHeight = container.clientHeight;
                                        container.scrollTo({
                                            top: rowTop - containerHeight / 2 + row.offsetHeight / 2,
                                            behavior: 'smooth'
                                        });
                                    }
                                }
                                break;
                            }
                        }
                    } // End of: if (canvasMode !== 'plan')

                    const clickedBeam = findBeamAtPoint(mx, my);
                    if (clickedBeam) {
                        const groupIdx = findGroupByBeamHandle(clickedBeam.Handle);
                        if (groupIdx >= 0) {
                            if (groupIdx !== currentGroupIndex) {
                                // First click on DIFFERENT beam group ‚Üí select group, highlight full beam
                                loadGroup(groupIdx); // loadGroup resets highlightedSpanIndex = -1
                                showToast(`ƒê√£ ch·ªçn: ${data.groups[groupIdx].GroupName || 'Group ' + (groupIdx + 1)}`);
                                // loadGroup already calls render functions
                            } else {
                                // Second click on SAME group ‚Üí find span at click position
                                const spanIdx = findSpanAtClickPosition(clickedBeam, mx, my);
                                if (spanIdx >= 0 && spanIdx !== highlightedSpanIndex) {
                                    highlightSpan(spanIdx); // This will sync sidebar
                                }
                            }
                        }
                    }
                });

                // Hover to highlight span + Box zoom drag update
                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();

                    // Handle box selection drag
                    if (Beam.State.boxSelectActive) {
                        Beam.State.boxSelectEnd = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                        render(); // Will draw selection box
                        return;
                    }

                    // Handle pan drag
                    if (canvasDragging) {
                        const dx = e.clientX - canvasLastX;
                        const dy = e.clientY - canvasLastY;

                        // Mark as dragged if moved meaningfully
                        if (Math.abs(dx) > 2 || Math.abs(dy) > 2) isPanDragging = true;

                        canvasPanX += dx;
                        canvasPanY += dy;
                        canvasLastX = e.clientX;
                        canvasLastY = e.clientY;
                        render();
                    } else {
                        // Hover detection
                        const x = (e.clientX - rect.left - canvasPanX) / canvasZoom;
                        const y = (e.clientY - rect.top - canvasPanY) / canvasZoom;

                        // Hover label => pointer cursor
                        let overLabel = false;
                        for (let i = 0; i < rebarLabelBounds.length; i++) {
                            const lb = rebarLabelBounds[i];
                            if (x >= lb.x && x <= lb.x + lb.width && y >= lb.y && y <= lb.y + lb.height) {
                                overLabel = true;
                                break;
                            }
                        }
                        if (overLabel) {
                            canvas.style.cursor = 'pointer';
                        } else if (!canvasDragging && !boxZoomActive) {
                            canvas.style.cursor = 'default';
                        }
                        let found = -1;
                        // FIX: Only update highlight if no mouse button is pressed (pure hover)
                        // SKIP in Plan mode - hover highlight is disabled in Plan view
                        if (e.buttons === 0 && canvasMode !== 'plan') {
                            for (let i = 0; i < spanBounds.length; i++) {
                                const b = spanBounds[i];
                                if (x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height) {
                                    found = b.index;
                                    break;
                                }
                            }
                            if (found !== highlightedSpanIndex) {
                                highlightedSpanIndex = found;
                                render();
                                renderTable();
                            }
                        }
                    }
                });

                // Middle click or Alt+click to start pan, Left click to start box selection
                canvas.addEventListener('mousedown', (e) => {
                    mouseDownButton = e.button; // Track which button started the interaction
                    hideInlineLabelEditor();
                    const rect = canvas.getBoundingClientRect();

                    // Middle click or Alt+Left click = Pan
                    if (e.button === 1 || (e.button === 0 && e.altKey)) {
                        canvasDragging = true;
                        isPanDragging = false; // Reset drag flag
                        canvasLastX = e.clientX;
                        canvasLastY = e.clientY;
                        canvas.style.cursor = 'grabbing';
                        e.preventDefault();
                        return;
                    }

                    // Left click (no modifier except Ctrl/Shift for selection) = Start Box Selection
                    if (e.button === 0 && !e.altKey && canvasMode === 'plan') {
                        Beam.State.boxSelectActive = true;
                        Beam.State.boxSelectStart = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                        Beam.State.boxSelectEnd = { ...Beam.State.boxSelectStart };
                        canvas.style.cursor = 'crosshair';
                        e.preventDefault();
                        return;
                    }
                });

                canvas.addEventListener('mouseup', (e) => {
                    // Finish Box Selection
                    if (Beam.State.boxSelectActive) {
                        Beam.State.boxSelectActive = false;
                        canvas.style.cursor = 'default';

                        const { boxSelectStart, boxSelectEnd } = Beam.State;
                        const isLeftToRight = boxSelectEnd.x >= boxSelectStart.x;
                        const left = Math.min(boxSelectStart.x, boxSelectEnd.x);
                        const right = Math.max(boxSelectStart.x, boxSelectEnd.x);
                        const top = Math.min(boxSelectStart.y, boxSelectEnd.y);
                        const bottom = Math.max(boxSelectStart.y, boxSelectEnd.y);

                        // Ch·ªâ x·ª≠ l√Ω n·∫øu v√πng ch·ªçn ƒë·ªß l·ªõn (> 5px)
                        if (right - left > 5 && bottom - top > 5) {
                            // N·∫øu kh√¥ng gi·ªØ Ctrl, clear selection tr∆∞·ªõc
                            if (!e.ctrlKey) {
                                Beam.State.clearHandleSelection();
                            }
                            performBoxSelection(left, right, top, bottom, isLeftToRight);
                        } else {
                            // Click ƒë∆°n (kh√¥ng k√©o) - x·ª≠ l√Ω nh∆∞ click th√¥ng th∆∞·ªùng
                            const rect = canvas.getBoundingClientRect();
                            const mx = e.clientX - rect.left;
                            const my = e.clientY - rect.top;
                            const beam = findBeamAtPoint(mx, my);

                            if (beam && beam.Handle) {
                                if (e.ctrlKey) {
                                    // Ctrl+Click: Toggle span ƒë∆°n l·∫ª
                                    Beam.State.toggleHandleSelection(beam.Handle, true);
                                } else if (e.shiftKey) {
                                    // Shift+Click: Toggle c·∫£ group
                                    const groupIdx = findGroupByBeamHandle(beam.Handle);
                                    if (groupIdx >= 0) {
                                        const handles = data.groups[groupIdx].EntityHandles || [];
                                        const allSelected = handles.every(h => Beam.State.isHandleSelected(h));
                                        if (allSelected) {
                                            Beam.State.removeHandlesFromSelection(handles);
                                        } else {
                                            Beam.State.addHandlesToSelection(handles);
                                        }
                                    }
                                } else {
                                    // Click th∆∞·ªùng v√†o d·∫ßm: Ch·ªçn duy nh·∫•t d·∫ßm ƒë√≥
                                    Beam.State.clearHandleSelection();
                                    Beam.State.selectedHandles.add(beam.Handle);
                                }
                            }
                            // Click v√†o v√πng tr·ªëng: B·∫¢O L∆ØU v√πng ch·ªçn (kh√¥ng clear)
                            // S·ª≠ d·ª•ng ESC ƒë·ªÉ x√≥a selection
                        }
                        render();
                        return;
                    }

                    canvasDragging = false;
                    canvas.style.cursor = 'default';
                });

                canvas.addEventListener('mouseleave', () => {
                    canvasDragging = false;
                    Beam.State.boxSelectActive = false;
                    canvas.style.cursor = 'default';
                    // Highlight state is persistent, only changed by click/tab
                });

                // Wheel to zoom
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    const newZoom = Math.max(0.5, Math.min(5, canvasZoom * delta));
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    canvasPanX = mouseX - (mouseX - canvasPanX) * (newZoom / canvasZoom);
                    canvasPanY = mouseY - (mouseY - canvasPanY) * (newZoom / canvasZoom);
                    canvasZoom = newZoom;
                    render();
                }, { passive: false });

                canvas.addEventListener('dblclick', (e) => {
                    mouseDownButton = -1; // Reset to avoid interference
                    const rect = canvas.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;

                    if (canvasMode === 'plan') {
                        // PRIORITY 1: Edit Section Label (Plan View)
                        if (labelMode === 2) {
                            for (const lb of planSectionLabelBounds) {
                                if (isPointInRotatedRect(mx, my, lb)) {
                                    startInlineLabelEdit({
                                        ...lb,
                                        type: 'SectionLabel',
                                        source: 'plan',
                                        x: mx - lb.width / 2, // Center editor on click
                                        y: my - lb.height / 2
                                    });
                                    return;
                                }
                            }
                        }
                    } else {
                        const x = (e.clientX - rect.left - canvasPanX) / canvasZoom;
                        const y = (e.clientY - rect.top - canvasPanY) / canvasZoom;
                        for (let i = 0; i < rebarLabelBounds.length; i++) {
                            const lb = rebarLabelBounds[i];
                            if (x >= lb.x && x <= lb.x + lb.width && y >= lb.y && y <= lb.y + lb.height) {
                                startInlineLabelEdit(lb);
                                return;
                            }
                        }
                    }
                });

                console.log('Canvas interaction system initialized');

                // === ESC KEY TO CLEAR SELECTION ===
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        Beam.State.clearHandleSelection();
                        render();
                        updateElementsPanel();
                    }
                });
            }

            // ====== DETAIL CANVAS ZOOM/PAN EVENTS ======
            const detailCanvas = document.getElementById('detailCanvas');
            if (detailCanvas) {
                let detailDragging = false;
                let detailLastX = 0;
                let detailLastY = 0;

                // Create inline label editor for detail canvas
                const detailContainer = detailCanvas.parentElement;
                if (detailContainer && !labelEditorEl) {
                    if (!detailContainer.style.position) detailContainer.style.position = 'relative';
                    labelEditorEl = document.createElement('input');
                    labelEditorEl.type = 'text';
                    labelEditorEl.className = 'hidden absolute z-50 border border-blue-400 rounded px-1 py-0.5 text-[11px] bg-white shadow-lg';
                    labelEditorEl.style.minWidth = '60px';
                    labelEditorEl.style.height = '20px';
                    labelEditorEl.addEventListener('keydown', (ev) => {
                        if (ev.key === 'Enter') {
                            commitInlineLabelEdit();
                        } else if (ev.key === 'Escape') {
                            cancelInlineLabelEdit();
                        }
                        ev.stopPropagation();
                    });
                    labelEditorEl.addEventListener('blur', () => {
                        if (labelEditorEl && !labelEditorEl.classList.contains('hidden')) commitInlineLabelEdit();
                    });
                    detailContainer.appendChild(labelEditorEl);
                }

                // Wheel zoom
                detailCanvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const rect = detailCanvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newZoom = Math.max(0.3, Math.min(5, detailZoom * zoomFactor));

                    // Zoom towards mouse position
                    detailPanX = mouseX - (mouseX - detailPanX) * (newZoom / detailZoom);
                    detailPanY = mouseY - (mouseY - detailPanY) * (newZoom / detailZoom);
                    detailZoom = newZoom;

                    renderDetailCanvas();
                }, { passive: false });

                // Middle click or Alt+Left click pan
                detailCanvas.addEventListener('mousedown', (e) => {
                    if (e.button === 1 || (e.button === 0 && e.altKey)) {
                        detailDragging = true;
                        detailLastX = e.clientX;
                        detailLastY = e.clientY;
                        detailCanvas.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                });

                detailCanvas.addEventListener('mousemove', (e) => {
                    if (detailDragging) {
                        detailPanX += e.clientX - detailLastX;
                        detailPanY += e.clientY - detailLastY;
                        detailLastX = e.clientX;
                        detailLastY = e.clientY;
                        renderDetailCanvas();
                    }
                });

                detailCanvas.addEventListener('mouseup', () => {
                    detailDragging = false;
                    detailCanvas.style.cursor = 'default';
                });

                detailCanvas.addEventListener('mouseleave', () => {
                    detailDragging = false;
                    detailCanvas.style.cursor = 'default';
                });

                // Click: FIRST check label bounds for editing, THEN span bounds for selection
                detailCanvas.addEventListener('click', (e) => {
                    const rect = detailCanvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left - detailPanX) / detailZoom;
                    const y = (e.clientY - rect.top - detailPanY) / detailZoom;

                    // PRIORITY 0: Check section label bounds (xSectionLabel)
                    for (let i = 0; i < sectionLabelBounds.length; i++) {
                        const sl = sectionLabelBounds[i];
                        // Expand clickable area to include icon (icon is after the text)
                        const iconWidth = 20; // Approximate width of lock/unlock icon
                        const totalWidth = sl.width + iconWidth;

                        if (x >= sl.x && x <= sl.x + totalWidth && y >= sl.y && y <= sl.y + sl.height) {
                            const clickXInLabel = x - sl.x;
                            // Icon is at END - check if clicked in last 20px for lock toggle
                            if (clickXInLabel > sl.width) {
                                // Clicked on lock icon area - toggle lock state
                                toggleSectionLock(sl.spanIndex, e);
                            } else {
                                // Clicked on section label text - edit label
                                editSectionLabel(sl.spanIndex, sl.label, e, sl);
                            }
                            return;
                        }
                    }

                    // PRIORITY 1: Check label bounds for editing (single click)
                    for (let i = 0; i < detailRebarLabelBounds.length; i++) {
                        const lb = detailRebarLabelBounds[i];
                        if (x >= lb.x && x <= lb.x + lb.width && y >= lb.y && y <= lb.y + lb.height) {
                            startInlineLabelEdit(lb);
                            return;
                        }
                    }

                    // PRIORITY 2: Check span bounds for selection
                    for (let i = 0; i < detailSpanBounds.length; i++) {
                        const b = detailSpanBounds[i];
                        if (x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height) {
                            highlightSpan(b.index);
                            renderDetailCanvas();
                            renderTable();
                            return;
                        }
                    }
                });

                // Double-click: open calculation report for span OR edit label
                detailCanvas.addEventListener('dblclick', (e) => {
                    const rect = detailCanvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left - detailPanX) / detailZoom;
                    const y = (e.clientY - rect.top - detailPanY) / detailZoom;

                    // 1. Priority: Edit label if clicked
                    for (let i = 0; i < detailRebarLabelBounds.length; i++) {
                        const lb = detailRebarLabelBounds[i];
                        if (x >= lb.x && x <= lb.x + lb.width && y >= lb.y && y <= lb.y + lb.height) {
                            startInlineLabelEdit(lb);
                            return;
                        }
                    }

                    // 2. Secondary: Open report for span if clicked on span body
                    for (let i = 0; i < detailSpanBounds.length; i++) {
                        const b = detailSpanBounds[i];
                        if (x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height) {
                            showCalculationReport(b.index);
                            return;
                        }
                    }
                });

                console.log('Detail canvas zoom/pan initialized');
            }

            // Handle error mode (from C# when data too large or serialization failed)
            if (data.mode === 'error') {
                const canvas = document.getElementById('beamCanvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 600;
                ctx.fillStyle = '#fef2f2';
                ctx.fillRect(0, 0, 600, 360);
                ctx.fillStyle = '#dc2626';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('‚ö†Ô∏è L·ªói kh·ªüi t·∫°o d·ªØ li·ªáu', 300, 140);
                ctx.font = '12px sans-serif';
                ctx.fillStyle = '#b91c1c';
                ctx.fillText(data.error || 'Unknown error', 300, 170);
                ctx.fillStyle = '#64748b';
                ctx.fillText('Vui l√≤ng ch·ªçn √≠t ƒë·ªëi t∆∞·ª£ng h∆°n ho·∫∑c ki·ªÉm tra d·ªØ li·ªáu.', 300, 200);
                document.getElementById('groupSelect').style.display = 'none';
                console.error('Data error:', data.error);
                return;
            }

            // Handle view mode: 'groups' vs 'single'
            if (data.mode === 'single' || !data.groups || data.groups.length === 0) {
                // Single beam mode - show message in canvas
                const canvas = document.getElementById('beamCanvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 600;
                ctx.fillStyle = '#f8fafc';
                ctx.fillRect(0, 0, 600, 360);
                ctx.fillStyle = '#64748b';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('üì¶ D·∫ßm ƒë∆°n ch∆∞a ƒë∆∞·ª£c gom nh√≥m', 300, 150);
                ctx.font = '12px sans-serif';
                ctx.fillStyle = '#94a3b8';
                ctx.fillText('S·ª≠ d·ª•ng l·ªánh DTS_REBAR_GROUP ƒë·ªÉ gom d·∫ßm v√†o nh√≥m', 300, 180);
                ctx.fillText('ho·∫∑c ch·ªçn ph·∫ßn t·ª≠ thu·ªôc nh√≥m ƒë·ªÉ xem', 300, 200);

                // Hide group controls
                document.getElementById('groupSelect').style.display = 'none';
                console.log('Single beam mode - no groups to display');
                return;
            }
            // FIX: Auto-set story from first group's LevelZ (elements selected from AutoCAD)
            if (data.groups && data.groups.length > 0) {
                const firstGroupZ = data.groups[0].LevelZ || 0;
                // Round to match story grouping tolerance
                const roundedZ = Math.round(firstGroupZ / 500) * 500;
                Beam.State.currentStoryZ = roundedZ;

                // Update story dropdown to match
                const storySelect = document.getElementById('storySelect');
                if (storySelect) storySelect.value = roundedZ;
            }

            // Populate story dropdown for Plan View
            populateStoryDropdown();

            populateGroupSelect();
            if (data.groups && data.groups.length > 0) {
                loadGroup(0);
            }
            // NOTE: initDetailPanelResize() is now called at the beginning of init()

            // === LISTEN FOR MESSAGES FROM C# ===
            if (window.chrome?.webview) {
                window.chrome.webview.addEventListener('message', (event) => {
                    const msg = event.data;
                    if (typeof msg !== 'string') return;

                    if (msg.startsWith('NAMING_DONE|')) {
                        const count = parseInt(msg.split('|')[1]) || 0;
                        showToast(`‚úÖ ƒê√£ ƒë·∫∑t t√™n ${count} d·∫ßm`);
                        // Refresh ALL plan data to update sections panel and plan labels
                        sendRefreshAllData();
                    }

                    if (msg.startsWith('NAMING_ERROR|')) {
                        const errorMsg = msg.split('|')[1] || 'L·ªói kh√¥ng x√°c ƒë·ªãnh';
                        showToast(`‚ùå L·ªói: ${errorMsg}`, 3000);
                    }
                });
            }
        }

        function sendRefreshAllData() {
            if (window.chrome?.webview) {
                console.log('üì° Requesting full data refresh from CAD (REFRESH_DATA & REFRESH_PLAN_DATA)...');
                window.chrome.webview.postMessage('REFRESH_DATA|');
                window.chrome.webview.postMessage('REFRESH_PLAN_DATA|');
            }
        }

        window.onUpdateAllBeams = function (allBeams) {
            if (!allBeams) return;
            data.allBeams = allBeams;
            console.log(`üì° Plan View data updated: ${allBeams.length} beams`);

            // [FIX REALTIME] Sync new label data from plan beams back to group spans
            syncAllGroupsFromPlanData();

            refreshUI();
        };

        function syncAllGroupsFromPlanData() {
            if (!data.allBeams || !data.groups) return;
            data.groups.forEach(group => {
                if (!group.Spans) return;
                group.Spans.forEach(span => {
                    if (!span.Segments || span.Segments.length === 0) return;
                    const handle = span.Segments[0].EntityHandle;
                    const beam = data.allBeams.find(b => b.Handle === handle);
                    if (beam) {
                        // Priority: Sync labels from CAD XData back to group spans if provided
                        if (beam.xSectionLabel !== undefined) {
                            span.xSectionLabel = beam.xSectionLabel || '';
                        }
                        if (beam.SectionLabel !== undefined) {
                            span.SectionLabel = beam.SectionLabel || '';
                        }
                        if (beam.xSectionLabelLocked !== undefined) {
                            span.xSectionLabelLocked = !!beam.xSectionLabelLocked;
                        }
                    }
                });
            });
            console.log('üîÑ Synced Section Labels from Plan Data to Groups');
        }

        function populateGroupSelect() {
            const sel = document.getElementById('groupSelect');
            sel.innerHTML = '';
            if (!data.groups) return;

            // FIX: Filter groups by current story Z (Plan View mode)
            const z = Beam.State.currentStoryZ;
            const Z_TOL = 500;

            // FIX 1: Sort groups - Girder first, then Beam, alphabetically within each type
            const groupsWithIndex = data.groups.map((g, i) => ({ ...g, originalIndex: i }));
            const filteredGroups = groupsWithIndex.filter(g => {
                const groupZ = g.LevelZ || 0;
                return z == null || Math.abs(groupZ - z) < Z_TOL;
            });

            // Sort: Girder first, then Beam, then alphabetically by GroupName
            filteredGroups.sort((a, b) => {
                const typeA = (a.GroupType || 'Beam').toLowerCase();
                const typeB = (b.GroupType || 'Beam').toLowerCase();
                // Girder before Beam
                if (typeA.includes('girder') && !typeB.includes('girder')) return -1;
                if (!typeA.includes('girder') && typeB.includes('girder')) return 1;
                // Same type: sort alphabetically by GroupName
                const nameA = (a.GroupName || '').toLowerCase();
                const nameB = (b.GroupName || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });

            filteredGroups.forEach((g) => {
                const opt = document.createElement('option');
                opt.value = g.originalIndex;  // Original index in data.groups
                opt.textContent = `${g.GroupName || 'Group ' + (g.originalIndex + 1)} (${g.Spans?.length || 0} nh·ªãp)`;
                sel.appendChild(opt);
            });

            // If current group is not on this story, select first available
            if (sel.options.length > 0 && !Array.from(sel.options).some(o => o.value == currentGroupIndex)) {
                // Current group not visible, switch to first
            }
        }

        function loadGroup(index) {
            currentGroupIndex = parseInt(index);
            currentGroup = data.groups[currentGroupIndex];
            document.getElementById('groupSelect').value = currentGroupIndex;

            // Reset span highlight to full beam when switching groups
            highlightedSpanIndex = -1;

            // V7.0: M·∫∑c ƒë·ªãnh ch·ªçn option 0
            selectedOptionKey = String(currentGroup?.SelectedBackboneIndex || 0);

            populateOptionSelect();

            // V7.0: Apply option t·ª´ span.Options tr·ª±c ti·∫øp
            applyXDataOptionToSpans(parseInt(selectedOptionKey) || 0);

            // Render: Main canvas always shows Plan View, Detail panel shows Long/Section/Shear
            renderPlanView();  // Main canvas - always plan view

            // Reset detail view zoom/pan and render
            detailZoom = 1.0;
            detailPanX = 0;
            detailPanY = 0;
            renderDetailCanvas();
            centerDetailCanvas();

            renderTable();
            updateMetrics();
            updateGroupInfo();
            loadMaterialSelects();
            updateLockStatus();

            // Initialize history
            Beam.History.clear();
            Beam.History.push();
        }

        // Center canvas viewport on content (for Plan View)
        function centerCanvas() {
            const canvas = document.getElementById('beamCanvas');
            if (!canvas) return;

            // For Plan View, use plan-specific centering
            canvasPanX = 0;
            canvasPanY = 0;
            renderPlanView();
            updateZoomIndicator();
        }

        // Reset Plan Canvas View (zoom to fit)
        function resetPlanCanvasView() {
            canvasZoom = 1.0;
            canvasPanX = 0;
            canvasPanY = 0;
            renderPlanView();
            updateZoomIndicator();
        }

        function updateZoomIndicator() {
            const el = document.getElementById('zoomIndicator');
            if (el) el.textContent = Math.round(canvasZoom * 100) + '%';
        }

        // NOTE: Inline label edit functions (startInlineLabelEdit, commitInlineLabelEdit, etc.) 
        // moved to lines 752-859 to use detailCanvas instead of beamCanvas

        // Backward compatible helper (kept for other UI pieces)
        function getSpanRebarText(span, type) {
            const t = getLayerRebarText(span, type, 0, 2);
            if (t && t.trim().length > 0) return t;
            const l = getLayerRebarText(span, type, 0, 0);
            if (l && l.trim().length > 0) return l;
            const r = getLayerRebarText(span, type, 0, 4);
            return r;
        }

        function drawEditableLabel(ctx, text, centerX, centerY, color, meta) {
            const raw = (text === undefined || text === null) ? '' : String(text);
            const t = raw.trim();
            const isEmpty = t.length === 0;
            ctx.save();
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const padX = 4;
            const showText = isEmpty ? '' : t;
            const w = Math.max(24, ctx.measureText(showText || '00').width + padX * 2);
            const h = 14;
            const x = centerX - w / 2;
            const y = centerY - h / 2;

            // Background pill
            ctx.fillStyle = isEmpty ? 'rgba(255,255,255,0.55)' : 'rgba(255,255,255,0.85)';
            ctx.strokeStyle = isEmpty ? 'rgba(203,213,225,0.9)' : 'rgba(148,163,184,0.9)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            const r = 6;
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            if (!isEmpty) {
                ctx.fillStyle = color;
                ctx.fillText(showText, centerX, centerY);
            }
            ctx.restore();

            rebarLabelBounds.push({ x, y, width: w, height: h, ...meta });
        }

        function drawInfoLabel(ctx, text, centerX, centerY, color, isDeficit = false) {
            const raw = (text === undefined || text === null) ? '' : String(text);
            const t = raw.trim();
            if (t.length === 0) return;

            ctx.save();
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const padX = 4;
            const w = Math.max(26, ctx.measureText(t).width + padX * 2);
            const h = 14;
            const x = centerX - w / 2;
            const y = centerY - h / 2;

            // V3.4.1: Red background for deficit labels
            ctx.fillStyle = isDeficit ? 'rgba(254,202,202,0.95)' : 'rgba(255,255,255,0.9)';
            ctx.strokeStyle = isDeficit ? 'rgba(220,38,38,0.9)' : 'rgba(148,163,184,0.9)';
            ctx.lineWidth = isDeficit ? 2 : 1;
            ctx.beginPath();
            const r = 6;
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = isDeficit ? '#991b1b' : color;
            ctx.fillText(t, centerX, centerY);
            ctx.restore();
        }



        // ===== UNIFIED ROUNDING: <1 ‚Üí 4 decimals, ‚â•1 ‚Üí 2 decimals =====
        function formatRebarValue(n) {
            if (!Number.isFinite(n) || n <= 0) return '-';
            if (n < 1) return n.toFixed(4);
            return n.toFixed(2);
        }

        // Calculate As_prov from rebar string (e.g., "3D20" ‚Üí 9.42 cm¬≤)
        function parseRebarArea(rebarStr) {
            if (!rebarStr || typeof rebarStr !== 'string') return 0;
            let total = 0;
            // Split by '+' or ',' for combined bars (e.g., "2D16+2D18" or "2D20,2D25")
            const parts = rebarStr.split(/[+,]/);
            for (const part of parts) {
                const match = part.trim().match(/(\d+)D(\d+)/i);
                if (match) {
                    const count = parseInt(match[1]) || 0;
                    const dia = parseInt(match[2]) || 0;
                    total += count * Math.PI * (dia / 10) * (dia / 10) / 4; // cm¬≤
                }
            }
            return total;
        }

        // Get As_prov/As_req text for display (replaces getAsReqText)
        function getAsRatioText(span, type, posName) {
            const result = getAsRatioResult(span, type, posName);
            return result.text;
        }

        // V3.4.2: Returns {text, isDeficit, asProv} for deficit highlighting
        // FIXED: Sum ALL layers, not just layer 0
        function getAsRatioResult(span, type, posName) {
            // As_req from XData
            const reqArr = (type === 'Top') ? span?.As_Top : span?.As_Bot;
            const idx = (posName === 'L') ? 0 : (posName === 'R' ? 4 : 2);
            const asReq = Number(reqArr?.[idx]) || 0;

            // V3.4.2 FIX: Sum As_prov from ALL layers (not just layer 0)
            const rebarArr = (type === 'Top') ? span?.TopRebar : span?.BotRebar;
            let asProv = 0;
            if (rebarArr && Array.isArray(rebarArr)) {
                for (let layer = 0; layer < rebarArr.length; layer++) {
                    const str = rebarArr[layer]?.[idx] || '';
                    asProv += parseRebarArea(str);
                }
            }

            // Check deficit with safety factor (Single Source: data.settings.SafetyFactor)
            const safetyFactor = data.settings?.SafetyFactor || 1.0;
            const isDeficit = asReq > 0 && asProv < asReq * safetyFactor;

            // Format display
            const reqText = formatRebarValue(asReq);
            const provText = formatRebarValue(asProv);

            let text = '';
            if (asReq <= 0 && asProv <= 0) text = '';
            else if (asProv > 0 && asReq > 0) text = `${provText}/${reqText}`;
            else if (asReq > 0) text = reqText;
            else text = provText;

            return { text, isDeficit, asProv };
        }

        // Get Stirrup/WebBar requirement text with As_prov/As_req format
        function getShearRatioText(span, provKind, reqKind, idx) {
            // provKind: 'Stirrup' or 'WebBar'
            // reqKind: 'StirrupReq' or 'WebReq'
            const provArr = span?.[provKind];
            const reqArr = span?.[reqKind];

            const provStr = Array.isArray(provArr) ? (provArr[idx] || '') : '';
            const reqVal = Number(Array.isArray(reqArr) ? reqArr[idx] : 0) || 0;

            // For stirrup/web, parse asProv differently (e.g., "D8@150" not bar area)
            // Just show strings as-is with req value
            const reqText = formatRebarValue(reqVal);

            if (provStr && reqVal > 0) return `${provStr} (${reqText})`;
            if (provStr) return provStr;
            if (reqVal > 0) return `req:${reqText}`;
            return '';
        }

        function editCanvasRebarLabel(label) {
            if (labelEditorEl) {
                startInlineLabelEdit(label);
                return;
            }
            if (!label || !currentGroup?.Spans?.[label.spanIndex]) return;
            if (label.type === 'Stirrup') {
                const span = currentGroup.Spans[label.spanIndex];
                const idx = Number.isFinite(label.pos) ? label.pos : 0;
                const currentVal = (span?.Stirrup?.[idx] || '').toString();
                const title = `ƒêAI - Nh·ªãp ${span.SpanId || (label.spanIndex + 1)} (${idx === 0 ? 'L1' : (idx === 1 ? 'Gi·ªØa' : 'L2')})`;
                const nextVal = prompt(title, currentVal);
                if (nextVal === null) return;
                updateStirrup(label.spanIndex, idx, nextVal);
                maybeRenderTable();
                refreshUI();
                return;
            }
            if (label.type === 'WebBar') {
                const span = currentGroup.Spans[label.spanIndex];
                const idx = Number.isFinite(label.pos) ? label.pos : 0;
                const currentVal = (span?.WebBar?.[idx] || '').toString();
                const title = `S∆Ø·ªúN - Nh·ªãp ${span.SpanId || (label.spanIndex + 1)} (${idx === 0 ? 'L1' : (idx === 1 ? 'Gi·ªØa' : 'L2')})`;
                const nextVal = prompt(title, currentVal);
                if (nextVal === null) return;
                updateWebBar(label.spanIndex, idx, nextVal);
                maybeRenderTable();
                refreshUI();
                return;
            }
            const span = currentGroup.Spans[label.spanIndex];
            const layer = Number.isFinite(label.layer) ? label.layer : 0;
            const pos = Number.isFinite(label.pos) ? label.pos : 2;
            const currentVal = getLayerRebarText(span, label.type, layer, pos);
            const posName = (pos === 0 ? 'Tr√°i' : (pos === 4 ? 'Ph·∫£i' : 'Gi·ªØa'));
            const title = `${label.type === 'Top' ? 'TH√âP TR√äN' : 'TH√âP D∆Ø·ªöI'} - Nh·ªãp ${span.SpanId || (label.spanIndex + 1)} (Layer ${layer + 1}, ${posName})`;
            const nextVal = prompt(title, currentVal);
            if (nextVal === null) return;
            updateLayerRebar(label.spanIndex, label.type, layer, pos, nextVal);
            maybeRenderTable();
        }

        function prevGroup() { if (currentGroupIndex > 0) loadGroup(currentGroupIndex - 1); }
        function nextGroup() { if (currentGroupIndex < data.groups.length - 1) loadGroup(currentGroupIndex + 1); }

        function populateOptionSelect() {
            const sel = document.getElementById('optionSelect');
            sel.innerHTML = '';

            // V7.0: ƒê·ªçc options t·ª´ span ƒë·∫ßu ti√™n (t·∫•t c·∫£ spans c√≥ c√πng options structure)
            const firstSpan = currentGroup?.Spans?.[0];
            const options = firstSpan?.Options || [];

            // [V7.1] Hi·ªÉn th·ªã User Option n·∫øu c√≥
            if (firstSpan?.UserOption && firstSpan.UserOption.TopL0) {
                const el = document.createElement('option');
                el.value = 'user';
                const topStr = firstSpan.UserOption.TopL0 || '-';
                const botStr = firstSpan.UserOption.BotL0 || '-';
                el.textContent = `‚≠ê User: T:${topStr} / B:${botStr}`;
                sel.appendChild(el);
            }

            // Hi·ªÉn th·ªã 5 options (Opt0-4)
            if (options.length > 0) {
                options.forEach((opt, idx) => {
                    const el = document.createElement('option');
                    el.value = String(idx);
                    const topStr = opt.TopL0 || '-';
                    const botStr = opt.BotL0 || '-';
                    el.textContent = `Opt${idx}: T:${topStr} / B:${botStr}`;
                    sel.appendChild(el);
                });
            } else if (!firstSpan?.UserOption) {
                // Kh√¥ng c√≥ options v√† kh√¥ng c√≥ UserOption
                const noOpt = document.createElement('option');
                noOpt.value = 'none';
                noOpt.textContent = 'Chua tinh thep';
                noOpt.disabled = true;
                sel.appendChild(noOpt);
            }

            // Ch·ªçn option m·∫∑c ƒë·ªãnh
            if (currentGroup?.IsLocked && firstSpan?.UserOption) {
                sel.value = 'user';
                selectedOptionKey = 'user';
            } else {
                const selectedIdx = currentGroup?.SelectedBackboneIndex || 0;
                // D·ª± ph√≤ng n·∫øu index > options.length
                const valueToSet = (selectedIdx >= 0 && selectedIdx < options.length) ? String(selectedIdx) : (options.length > 0 ? '0' : 'none');
                sel.value = valueToSet;
                selectedOptionKey = valueToSet;
            }
        }

        function selectOption(index) {
            if (index === 'user') {
                selectedOptionKey = 'user';
                // currentGroup.SelectedBackboneIndex = -1; // Optional indicator
            } else {
                const parsed = parseInt(index);
                if (isNaN(parsed)) return;
                selectedOptionKey = String(parsed);
                currentGroup.SelectedBackboneIndex = parsed;
            }

            // V7.0: ƒê·ªçc tr·ª±c ti·∫øp t·ª´ XData options
            applyXDataOptionToSpans(index);

            updateMetrics();
            refreshUI();
            renderTable();
        }

        // V7.0: X√≥a getSelectedOption obsolete - kh√¥ng c√≤n s·ª≠ d·ª•ng BackboneOptions

        // V7.0: ƒê·ªçc tr·ª±c ti·∫øp t·ª´ span.Options[index] ho·∫∑c span.UserOption
        function applyXDataOptionToSpans(optionIndex) {
            if (!currentGroup?.Spans?.length) return;

            currentGroup.Spans.forEach(span => {
                // ƒê·ªçc tr·ª±c ti·∫øp t·ª´ Options ho·∫∑c UserOption
                const opt = (optionIndex === 'user') ? span.UserOption : span.Options?.[optionIndex];
                if (!opt) return;

                // Initialize arrays - MUST be 6 elements to match C# [3,6] structure
                if (!span.TopRebar) span.TopRebar = [[], []];
                if (!span.BotRebar) span.BotRebar = [[], []];
                if (!span.TopRebar) span.TopRebar = [];
                if (!span.BotRebar) span.BotRebar = [];

                // Layer 0: Backbone (positions 0,2,4 = Left,Mid,Right)
                span.TopRebar[0] = [opt.TopL0 || '', '', opt.TopL0 || '', '', opt.TopL0 || '', ''];
                span.BotRebar[0] = [opt.BotL0 || '', '', opt.BotL0 || '', '', opt.BotL0 || '', ''];

                // Clear addon layers (1-7)
                for (let l = 1; l < 8; l++) {
                    span.TopRebar[l] = ['', '', '', '', '', ''];
                    span.BotRebar[l] = ['', '', '', '', '', ''];
                }

                // Apply Addons from XData (TopAddons is [[L,M,R], ...])
                if (opt.TopAddons && opt.TopAddons.length > 0) {
                    for (let l = 0; l < opt.TopAddons.length; l++) {
                        let layerIdx = l + 1;
                        if (layerIdx >= 8) break;
                        let layerData = opt.TopAddons[l];
                        span.TopRebar[layerIdx] = [layerData[0] || '', '', layerData[1] || '', '', layerData[2] || '', ''];
                    }
                }
                if (opt.BotAddons && opt.BotAddons.length > 0) {
                    for (let l = 0; l < opt.BotAddons.length; l++) {
                        let layerIdx = l + 1;
                        if (layerIdx >= 8) break;
                        let layerData = opt.BotAddons[l];
                        span.BotRebar[layerIdx] = [layerData[0] || '', '', layerData[1] || '', '', layerData[2] || '', ''];
                    }
                }

                // [FIX] Apply Stirrup & WebBar from Option (Modes 2 & 4 fix)
                if (opt.Stirrup && opt.Stirrup.length >= 3) {
                    span.Stirrup = [...opt.Stirrup];
                }
                if (opt.WebBar && opt.WebBar.length >= 3) {
                    span.WebBar = [...opt.WebBar];
                }

                // Sync to Plan View
                syncSpanDataToAllBeams(span);
            });
        }

        // ===== QUICK CALC (T√≠nh th√©p nhanh) =====
        function quickCalc() {
            if (!currentGroup) return;
            // Send message to C# to run rebar calculation
            window.chrome.webview?.postMessage('QUICK_CALC|' + currentGroupIndex);
        }

        // Called from C# after Quick Calc or other group updates
        function onGroupUpdated(groupIndex, groupJson) {
            try {
                const updated = (typeof groupJson === 'string') ? JSON.parse(groupJson) : groupJson;
                if (!data.groups || groupIndex < 0 || groupIndex >= data.groups.length) return;

                // Update specific group in the global data object
                data.groups[groupIndex] = updated;

                console.log(`[onGroupUpdated] Received Group ${groupIndex}`, updated);

                // If it's the current group, we need a full refresh
                if (currentGroupIndex === groupIndex) {
                    refreshUI();

                    // Reinitialize history for updated group
                    Beam.History.clear();
                    Beam.History.push();
                } else {
                    // Just update the dropdown if necessary (count changed, name changed)
                    populateGroupSelect();
                }
            } catch (e) {
                console.error('onGroupUpdated error', e);
            }
        }

        // NOTE: lockDesign, unlockDesign, toggleLock, restoreLockedDesign, updateLockStatus 
        // are now defined in the Beam.History section at the top of the script

        // Wrapper ƒë·ªÉ g·ªçi khi b·∫•t k·ª≥ edit n√†o x·∫£y ra
        function onManualEdit(spanIndex, field, value) {
            // Th·ª±c hi·ªán edit...
            console.log(`Manual edit: span ${spanIndex}, ${field} = ${value}`);

            // Auto-lock
            autoLockOnEdit();

            // Update UI
            refreshUI();
            renderTable();
        }

        function updateGroupInfo() {
            const info = document.getElementById('groupInfo');
            if (!currentGroup) { info.textContent = '-'; return; }
            const totalL = currentGroup.TotalLength?.toFixed(2) || '-';
            const beamCount = currentGroup.EntityHandles?.length || 0;
            info.textContent = `T·ªïng: ${totalL}m | ${beamCount} d·∫ßm | ${currentGroup.Spans?.length || 0} nh·ªãp`;
        }

        function updateMetrics() {
            if (!currentGroup) return;

            // V7.0: ƒê·ªçc t·ª´ span.Options thay v√¨ BackboneOptions
            const firstSpan = currentGroup.Spans?.[0];
            const selectedIdx = parseInt(selectedOptionKey) || 0;
            const opt = firstSpan?.Options?.[selectedIdx];

            if (opt) {
                document.getElementById('metricBackbone').textContent = opt.TopL0 || '-';
                document.getElementById('metricAs').textContent = '-'; // Kh√¥ng c√≤n As_Backbone
                document.getElementById('metricWaste').textContent = '-';
                document.getElementById('metricWeight').textContent = '-';
                document.getElementById('metricScore').textContent = '-';
            }

            // Warnings
            const warnings = [];
            if (currentGroup.HasStepChange) warnings.push({ icon: '!', text: 'Giat cap', cls: 'bg-amber-100 text-amber-700' });
            if (currentGroup.RequiresSplice) warnings.push({ icon: '+', text: 'Noi thep', cls: 'bg-blue-100 text-blue-700' });
            if (currentGroup.HasConsole) warnings.push({ icon: '>', text: 'Console', cls: 'bg-purple-100 text-purple-700' });

            document.getElementById('warningsContainer').innerHTML = warnings
                .map(w => `<span class="px-2 py-0.5 rounded text-[10px] font-bold ${w.cls}">${w.icon} ${w.text}</span>`).join('');
        }

        // ============ CANVAS RENDERING (RELATIVE LENGTHS) ============
        // FIX: Redirect Legacy Render to Plan View & Detail View
        // This prevents Main Canvas from accidentally showing Span View
        function renderCanvas() {
            renderPlanView();
            renderDetailCanvas();
            return;

            const canvas = document.getElementById('beamCanvas');
            const ctx = canvas.getContext('2d');

            if (!currentGroup?.Spans?.length) {
                canvas.width = 400;
                ctx.fillStyle = '#f8fafc';
                ctx.fillRect(0, 0, 400, 180);
                ctx.fillStyle = '#94a3b8';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Kh√¥ng c√≥ d·ªØ li·ªáu nh·ªãp', 200, 90);
                return;
            }

            spanBounds = [];
            rebarLabelBounds = [];
            const spans = currentGroup.Spans;

            // FIXED SPAN WIDTHS: all spans have the SAME visual width (independent of span count)
            const SUPPORT_GAP = 15; // Gap for support symbols
            const equalSpanWidth = FIXED_SPAN_WIDTH;

            let totalWidth = CANVAS_PADDING * 2;
            const spanWidths = spans.map(() => {
                totalWidth += equalSpanWidth + SUPPORT_GAP;
                return equalSpanWidth;
            });

            // Use canvas size from resizeCanvas (don't override here)
            // Clear with light background (full canvas, before transform)
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply zoom and pan transform
            ctx.save();
            ctx.translate(canvasPanX, canvasPanY);
            ctx.scale(canvasZoom, canvasZoom);

            let x = CANVAS_PADDING;
            // Give more vertical room for outside required labels
            const beamY = 90;

            // Draw beams
            spans.forEach((span, i) => {
                const w = spanWidths[i];

                // Support symbol
                if (i === 0) {
                    drawSupport(ctx, x, beamY);
                    x += 5;
                }

                // Store bounds
                spanBounds.push({ x, y: beamY, width: w, height: BEAM_HEIGHT, index: i });

                // Draw beam segment
                const isHighlighted = i === highlightedSpanIndex;
                ctx.fillStyle = isHighlighted ? '#dbeafe' : '#e2e8f0';
                ctx.strokeStyle = isHighlighted ? '#3b82f6' : '#64748b';
                ctx.lineWidth = isHighlighted ? 2 : 1;
                ctx.fillRect(x, beamY, w, BEAM_HEIGHT);
                ctx.strokeRect(x, beamY, w, BEAM_HEIGHT);

                // Draw rebar lines
                drawRebarLines(ctx, x, beamY, w, span);

                const labelXs = [x + w * 0.20, x + w * 0.50, x + w * 0.80];
                const labelPos = [0, 2, 4];

                if (canvasMode === 'long') {
                    // Editable long rebar labels: backbone (layer 0) + reinforcement layers (1..MaxLayers-1)
                    const maxLayers = data.settings?.MaxLayers || 2;

                    // Backbone label rows (inside beam)
                    const topBaseY = beamY + 12;
                    const botBaseY = beamY + BEAM_HEIGHT - 12;
                    for (let li = 0; li < labelXs.length; li++) {
                        const cx = labelXs[li];
                        const pos = labelPos[li];
                        drawEditableLabel(ctx, getLayerRebarText(span, 'Top', 0, pos), cx, topBaseY, '#ef4444', { spanIndex: i, type: 'Top', layer: 0, pos });
                        drawEditableLabel(ctx, getLayerRebarText(span, 'Bot', 0, pos), cx, botBaseY, '#3b82f6', { spanIndex: i, type: 'Bot', layer: 0, pos });
                    }

                    // Reinforcement layers (gia c∆∞·ªùng) - per span
                    // Stack inward to avoid collisions; typically MaxLayers=2 so only one extra row.
                    for (let layer = 1; layer < maxLayers; layer++) {
                        const dy = 14 * layer;
                        const topY = topBaseY + dy;
                        const botY = botBaseY - dy;
                        for (let li = 0; li < labelXs.length; li++) {
                            const cx = labelXs[li];
                            const pos = labelPos[li];
                            drawEditableLabel(ctx, getLayerRebarText(span, 'Top', layer, pos), cx, topY, '#f97316', { spanIndex: i, type: 'Top', layer, pos });
                            drawEditableLabel(ctx, getLayerRebarText(span, 'Bot', layer, pos), cx, botY, '#0ea5e9', { spanIndex: i, type: 'Bot', layer, pos });
                        }
                    }

                    // Required labels (outside beam): 6 positions
                    const reqTopY = beamY - 24;
                    const reqBotY = beamY + BEAM_HEIGHT + 24;
                    const posNames = ['L', 'M', 'R'];
                    for (let li = 0; li < labelXs.length; li++) {
                        const cx = labelXs[li];
                        const pn = posNames[li];
                        const topRatio = getAsRatioResult(span, 'Top', pn);
                        const botRatio = getAsRatioResult(span, 'Bot', pn);
                        drawInfoLabel(ctx, topRatio.text, cx, reqTopY, '#b91c1c', topRatio.isDeficit);
                        drawInfoLabel(ctx, botRatio.text, cx, reqBotY, '#1d4ed8', botRatio.isDeficit);
                    }
                } else if (canvasMode === 'section') {
                    // FIX: Section mode - display As_req labels (like Long mode but view-only)
                    const reqTopY = beamY - 24;
                    const reqBotY = beamY + BEAM_HEIGHT + 24;
                    const posNames = ['L', 'M', 'R'];
                    for (let li = 0; li < labelXs.length; li++) {
                        const cx = labelXs[li];
                        const pn = posNames[li];
                        const topRatio = getAsRatioResult(span, 'Top', pn);
                        const botRatio = getAsRatioResult(span, 'Bot', pn);
                        drawInfoLabel(ctx, topRatio.text, cx, reqTopY, '#b91c1c', topRatio.isDeficit);
                        drawInfoLabel(ctx, botRatio.text, cx, reqBotY, '#1d4ed8', botRatio.isDeficit);
                    }
                } else if (canvasMode === 'shear') {
                    // Shear-web mode: editable stirrup labels (provided) outside beam
                    const stirrupY = beamY + BEAM_HEIGHT + 22;
                    const webY = stirrupY + 18;
                    const stirrup = span.Stirrup || [];
                    const webBar = span.WebBar || [];
                    const stirrupXs = [x + w * 0.125, x + w * 0.50, x + w * 0.875];
                    for (let si = 0; si < stirrupXs.length; si++) {
                        drawEditableLabel(
                            ctx,
                            (stirrup[si] || ''),
                            stirrupXs[si],
                            stirrupY,
                            '#475569',
                            { spanIndex: i, type: 'Stirrup', layer: 0, pos: si }
                        );
                        drawEditableLabel(
                            ctx,
                            (webBar[si] || ''),
                            stirrupXs[si],
                            webY,
                            '#0f766e',
                            { spanIndex: i, type: 'WebBar', layer: 0, pos: si }
                        );
                    }

                    // Optional required labels (outside beam): up to 6 positions if data exists
                    // - StirrupReq at top
                    // - WebReq at bottom
                    const reqTopY = beamY - 24;
                    const reqBotY = webY + 36;
                    for (let si = 0; si < stirrupXs.length; si++) {
                        drawInfoLabel(ctx, getShearRatioText(span, 'Stirrup', 'StirrupReq', si), stirrupXs[si], reqTopY, '#b45309');
                        drawInfoLabel(ctx, getShearRatioText(span, 'WebBar', 'WebReq', si), stirrupXs[si], reqBotY, '#0f766e');
                    }
                }

                // Span label
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(span.SpanId, x + w / 2, beamY + BEAM_HEIGHT / 2 + 4);

                // Removed size/dimension labels to free space for required labels

                x += w;

                // Support between spans
                drawSupport(ctx, x, beamY);
                x += 15;
            });

            // Restore canvas transform
            ctx.restore();

            // Draw box zoom selection rectangle (after restore, in screen coords)
            if (boxZoomActive) {
                const x1 = Math.min(boxZoomStartX, boxZoomEndX);
                const y1 = Math.min(boxZoomStartY, boxZoomEndY);
                const w = Math.abs(boxZoomEndX - boxZoomStartX);
                const h = Math.abs(boxZoomEndY - boxZoomStartY);

                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);
                ctx.strokeRect(x1, y1, w, h);
                ctx.setLineDash([]);

                // Fill with transparent blue
                ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
                ctx.fillRect(x1, y1, w, h);
            }

            // Update zoom indicator if exists
            const zoomIndicator = document.getElementById('zoomIndicator');
            if (zoomIndicator) {
                zoomIndicator.textContent = `${Math.round(canvasZoom * 100)}%`;
            }

            // Scroll to highlighted span (only when not interacting)
            if (!canvasDragging && !boxZoomActive && highlightedSpanIndex >= 0) {
                const bound = spanBounds.find(b => b.index === highlightedSpanIndex);
                const container = document.getElementById('canvasContainer');
                if (bound && container) {
                    const scrollTarget = (bound.x * canvasZoom + canvasPanX) - container.clientWidth / 2 + (bound.width * canvasZoom) / 2;
                    container.scrollTo({ left: scrollTarget, behavior: 'smooth' });
                }
            }
        }

        function drawSupport(ctx, x, y) {
            ctx.fillStyle = '#475569';
            ctx.beginPath();
            ctx.moveTo(x, y + BEAM_HEIGHT);
            ctx.lineTo(x - 6, y + BEAM_HEIGHT + 15);
            ctx.lineTo(x + 6, y + BEAM_HEIGHT + 15);
            ctx.closePath();
            ctx.fill();
        }

        function drawRebarLines(ctx, x, y, w, span) {
            const topY = y + 12;
            const botY = y + BEAM_HEIGHT - 12;
            const midX = x + w / 2;

            // Draw backbone (continuous lines)
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);

            // Top backbone (red)
            ctx.beginPath();
            ctx.moveTo(x + 3, topY);
            ctx.lineTo(x + w - 3, topY);
            ctx.stroke();

            // Bottom backbone (blue)
            ctx.strokeStyle = '#3b82f6';
            ctx.beginPath();
            ctx.moveTo(x + 3, botY);
            ctx.lineTo(x + w - 3, botY);
            ctx.stroke();

            // MODE-SPECIFIC RENDERING
            if (canvasMode === 'long') {
                // LONG REBAR MODE - Editable labels are already drawn above via drawEditableLabel().
                // No additional rendering needed here to avoid duplicate labels.
            } else if (canvasMode === 'shear') {
                // SHEAR/WEB BAR MODE - Show stirrup layout as vertical lines
                const stirrups = span.Stirrup || [];
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = 1;
                ctx.setLineDash([]);

                // Draw vertical stirrup lines across span (simplified representation)
                const zones = [
                    { start: 0, end: 0.25, spacing: stirrups[0] },   // L1 zone
                    { start: 0.25, end: 0.75, spacing: stirrups[1] }, // Mid zone
                    { start: 0.75, end: 1.0, spacing: stirrups[2] }   // L2 zone
                ];

                zones.forEach(zone => {
                    const spacing = zone.spacing ? parseFloat(zone.spacing.match(/a(\d+)/)?.[1] || '150') : 150;
                    const dia = zone.spacing ? parseFloat(zone.spacing.match(/d(\d+)/)?.[1] || '8') : 8;
                    const zoneStart = x + w * zone.start;
                    const zoneEnd = x + w * zone.end;
                    const zoneWidth = zoneEnd - zoneStart;
                    const numStirrups = Math.max(2, Math.floor(zoneWidth / (spacing / 10))); // Scale for display

                    ctx.strokeStyle = dia >= 10 ? '#475569' : '#94a3b8';
                    ctx.lineWidth = dia >= 10 ? 1.5 : 1;

                    for (let i = 0; i <= numStirrups; i++) {
                        const sx = zoneStart + (zoneWidth / numStirrups) * i;
                        ctx.beginPath();
                        ctx.moveTo(sx, topY - 2);
                        ctx.lineTo(sx, botY + 2);
                        ctx.stroke();
                    }
                });

                // Stirrup text labels are drawn as editable labels in renderCanvas() (canvas-first).
            } else {
                // SECTION mode - draw addon bars (dashed) like before
                const topRebar = span.TopRebar?.[0];
                const botRebar = span.BotRebar?.[0];

                ctx.setLineDash([4, 2]);
                ctx.lineWidth = 1.5;

                if (topRebar?.[0]) {
                    ctx.strokeStyle = '#f97316';
                    ctx.beginPath();
                    ctx.moveTo(x + 3, topY + 4);
                    ctx.lineTo(x + w * 0.3, topY + 4);
                    ctx.stroke();
                }
                if (topRebar?.[4]) {
                    ctx.strokeStyle = '#f97316';
                    ctx.beginPath();
                    ctx.moveTo(x + w * 0.7, topY + 4);
                    ctx.lineTo(x + w - 3, topY + 4);
                    ctx.stroke();
                }
            }

            ctx.setLineDash([]);
        }

        // ============ TABLE RENDERING (LAYER-BASED) ============
        function renderTable() {
            const tbody = document.getElementById('spanTableBody');
            tbody.innerHTML = '';

            if (!currentGroup?.Spans) return;

            // V3.4.2: Get MaxLayers from settings
            const maxLayers = data.settings?.MaxLayers || 2;

            currentGroup.Spans.forEach((span, spanIdx) => {
                // Create n rows for each span (n = maxLayers)
                for (let layer = 0; layer < maxLayers; layer++) {
                    const tr = document.createElement('tr');
                    const isFirstRow = layer === 0;
                    tr.className = `span-row border-b border-slate-100 ${span.IsActive === false ? 'opacity-40' : ''} ${spanIdx === highlightedSpanIndex ? 'highlighted' : ''}`;
                    tr.dataset.spanIndex = spanIdx;

                    // Mouse events for sync
                    // DISABLED: mouseenter/mouseleave - hover should NOT change selection
                    // User requested: only CLICK changes span selection
                    // FIX: Click to select span persistently (update highlight on plan view)
                    tr.addEventListener('click', () => {
                        highlightSpan(spanIdx);
                        renderPlanView(); // Ensure plan view shows highlight
                    });

                    // First row shows span info with rowspan, other rows only show layer data
                    if (isFirstRow) {
                        // Format: "SpanId | xSectionLabel" with editable section label
                        // FIX: Fallback v·ªÅ currentGroup.Name (gi·ªëng plan view) thay v√¨ '-' ƒë·ªÉ th·ªëng nh·∫•t ngu·ªìn d·ªØ li·ªáu
                        const sectionLabel = span.xSectionLabel || currentGroup.Name || '-';
                        const isLocked = span.xSectionLabelLocked === true;

                        tr.innerHTML = `
                            <td class="p-1 font-medium" rowspan="${maxLayers}">
                                <div class="flex items-center gap-1 justify-center">
                                    <input type="text" value="${span.SpanId || ''}" 
                                        onclick="event.stopPropagation()"
                                        onchange="updateSpanName(${spanIdx}, this.value)"
                                        class="w-8 text-center bg-transparent border-b border-transparent hover:border-slate-300 focus:border-blue-500 outline-none font-medium text-slate-600">
                                    <span class="text-slate-400">|</span>
                                    ${isLocked ? `<span class="cursor-pointer hover:opacity-70" 
                                          onclick="toggleSectionLock(${spanIdx}, event)"
                                          title="Click ƒë·ªÉ m·ªü kh√≥a">üîí</span>` : ''}
                                    <span class="cursor-pointer hover:bg-blue-100 px-1 rounded font-bold ${isLocked ? 'text-amber-600' : 'text-blue-600'}" 
                                          ondblclick="editSectionLabel(${spanIdx}, '${sectionLabel.replace(/'/g, "\\'")}', event)"
                                          title="${isLocked ? 'ƒê√£ kh√≥a - Double-click ƒë·ªÉ s·ª≠a' : 'Double-click ƒë·ªÉ s·ª≠a Section Label'}">
                                        ${sectionLabel}
                                    </span>
                                    ${!isLocked && sectionLabel !== '-' ? `<span class="cursor-pointer text-slate-400 hover:text-amber-600 text-xs" 
                                          onclick="toggleSectionLock(${spanIdx}, event)"
                                          title="Click ƒë·ªÉ kh√≥a">üîì</span>` : ''}
                                </div>
                            </td>
                            <td class="p-1 text-center" rowspan="${maxLayers}">
                                <input type="checkbox" ${span.IsActive !== false ? 'checked' : ''} 
                                    onchange="toggleSpanActive(${spanIdx}, this.checked)" class="w-3 h-3">
                            </td>
                            <td class="p-1 text-center text-slate-600 text-[10px]" rowspan="${maxLayers}">${(span.Length || 0).toFixed(2)}</td>
                            <td class="p-1 text-center text-slate-500 text-[10px]" rowspan="${maxLayers}">${span.Width || 0}√ó${span.Height || 0}</td>
                            <td class="p-1 text-center text-xs font-bold ${layer === 0 ? 'bg-slate-200' : 'bg-slate-100'}">${layer + 1}</td>
                            ${renderLayerRebarInputs(spanIdx, span, 'Top', layer)}
                            ${renderLayerRebarInputs(spanIdx, span, 'Bot', layer)}
                            ${renderStirrupInputs(spanIdx, span, maxLayers)}
                            <td class="p-1" rowspan="${maxLayers}">
                                <div class="flex flex-col items-center">
                                    <input type="text" value="${span.SideBar || ''}" 
                                        onchange="updateSideBar(${spanIdx}, this.value)"
                                        placeholder="2D12"
                                        class="w-12 border border-slate-200 rounded px-0.5 py-0.5 text-center text-[10px] mb-0.5">
                                    <span class="text-[8px] text-slate-400 text-center truncate w-12" title="Max Required Web Area">${formatRebarValue(Math.max(...(span.WebReq || [0])))}</span>
                                </div>
                            </td>
                        `;
                    } else {
                        tr.innerHTML = `
                            <td class="p-1 text-center text-xs font-bold ${layer === 0 ? 'bg-slate-200' : 'bg-slate-100'}">${layer + 1}</td>
                            ${renderLayerRebarInputs(spanIdx, span, 'Top', layer)}
                            ${renderLayerRebarInputs(spanIdx, span, 'Bot', layer)}
                        `;
                    }

                    tbody.appendChild(tr);
                }
            });
        }

        // Render rebar inputs for a specific layer
        function renderLayerRebarInputs(spanIndex, span, type, layer) {
            const rebarData = type === 'Top' ? span.TopRebar : span.BotRebar;
            const layerData = rebarData?.[layer] || [];
            const bgClass = type === 'Top' ? 'bg-red-50' : 'bg-blue-50';
            let html = '';
            const positions = [0, 2, 4]; // Left(G·ªëi T), Mid(Gi·ªØa), Right(G·ªëi P)
            const posNames = ['L', 'M', 'R'];

            positions.forEach((pos, idx) => {
                const val = layerData[pos] || '';
                const reqArr = (type === 'Top') ? span.As_Top : span.As_Bot;
                const reqIdx = (pos === 0) ? 0 : (pos === 4 ? 4 : 2);
                const asReq = Array.isArray(reqArr) ? (Number(reqArr[reqIdx]) || 0) : 0;

                // V3.4.1 FIX: Only highlight if cell has value AND is deficit
                const safetyFactor = data.settings?.General?.SteelTolerance || 0.98;
                const asProv = parseRebarArea(val);
                const hasValue = val.trim() !== '';
                const isUnder = hasValue && asReq > 0 && asProv < asReq * safetyFactor;

                html += `<td class="p-0.5 ${bgClass} w-12">
                    <input type="text" value="${val}" 
                        onchange="updateLayerRebar(${spanIndex}, '${type}', ${layer}, ${pos}, this.value)"
                        placeholder=""
                        title="As_prov: ${asProv.toFixed(1)} / As_req: ${asReq > 0 ? asReq.toFixed(1) : '-'}"
                        class="w-full min-w-0 border ${isUnder ? 'border-red-500 bg-red-100' : 'border-slate-200'} rounded px-0.5 py-0.5 text-center text-[10px] ${isUnder ? 'bg-red-100 text-red-700 font-bold' : 'bg-white'}">
                </td>`;
            });
            return html;
        }

        // Render 3 stirrup input cells (L1, Mid, L2) with rowspan
        function renderStirrupInputs(spanIndex, span, maxLayers) {
            let html = '';
            const positions = [0, 1, 2]; // L1, Mid, L2
            const placeholders = ['d8a100', 'd8a150', 'd8a100'];

            positions.forEach((pos) => {
                const val = span.Stirrup?.[pos] || '';
                html += `<td class="p-0.5 w-12" rowspan="${maxLayers}">
                    <input type="text" value="${val}" 
                        onchange="updateStirrup(${spanIndex}, ${pos}, this.value)"
                        placeholder="${placeholders[pos]}"
                        class="w-full min-w-0 border border-slate-200 rounded px-0.5 py-0.5 text-center text-[10px]">
                </td>`;
            });
            return html;
        }

        // NOTE: updateLayerRebar moved to line 688 (uses renderDetailCanvas)

        // ============ DATA UPDATE FUNCTIONS ============
        function toggleSpanActive(index, active) {
            currentGroup.Spans[index].IsActive = active;
            refreshUI();
        }

        // Update span name from table input
        function updateSpanName(index, newName) {
            if (!currentGroup?.Spans?.[index]) return;
            currentGroup.Spans[index].SpanId = newName;
            // Re-render all to show new name and sync story/group dropdowns if needed
            refreshUI();
        }

        function updateRebar(spanIndex, type, pos, value) {
            const span = currentGroup.Spans[spanIndex];
            const arr = type === 'Top' ? 'TopRebar' : 'BotRebar';
            if (!span[arr]) span[arr] = [[], [], []];
            if (!span[arr][0]) span[arr][0] = [];
            span[arr][0][pos] = value;

            // ===== AUTO-LOCK: T·ª± ƒë·ªông ch·ªët khi s·ª≠a tay =====
            autoLockOnEdit();

            // Auto apply
            if (document.getElementById('autoApply').checked) {
                for (let i = spanIndex + 1; i < currentGroup.Spans.length; i++) {
                    if (currentGroup.Spans[i].IsActive !== false) {
                        if (!currentGroup.Spans[i][arr]) currentGroup.Spans[i][arr] = [[], [], []];
                        if (!currentGroup.Spans[i][arr][0]) currentGroup.Spans[i][arr][0] = [];
                        currentGroup.Spans[i][arr][0][pos] = value;
                    }
                }
                maybeRenderTable();
            }
            refreshUI();
        }

        // NOTE: updateStirrup moved to line 734, updateWebBar to line 743 (use renderDetailCanvas)

        function updateSideBar(spanIndex, value) {
            currentGroup.Spans[spanIndex].SideBar = value;

            // ===== AUTO-LOCK: T·ª± ƒë·ªông ch·ªët khi s·ª≠a tay =====
            autoLockOnEdit();
        }

        // [FIX AUDIT] Helper function to enforce Single Source of Truth
        // Syncs span data from currentGroup (Detail View) to allBeams (Plan View)
        function syncSpanToPlanData(span) {
            if (!span || !span.Segments || !data.allBeams) return;

            const spanHandles = span.Segments.map(s => s.EntityHandle);

            // Find matching beams in the Plan View data source and update them
            data.allBeams.forEach(b => {
                if (spanHandles.includes(b.Handle)) {
                    // [FIX ISSUE 1] Use only xSectionLabel - removed legacy SectionLabel fallback
                    b.xSectionLabel = span.xSectionLabel;
                    b.xSectionLabelLocked = span.xSectionLabelLocked;
                }
            });
        }

        // [FIX AUDIT] Completely rewritten to sync all UI components and XData
        // Update section label (xSectionLabel) and auto-lock + send to C#
        function updateSectionLabel(spanIndex, newLabel) {
            const span = currentGroup?.Spans?.[spanIndex];
            if (!span) return;

            // [FIX LOCK] Ch·∫∑n ch·ªânh s·ª≠a n·∫øu d·∫ßm ƒë√£ ch·ªët thi·∫øt k·∫ø
            if (currentGroup.IsLocked) {
                showToast('‚ùå D·∫ßm ƒë√£ ch·ªët thi·∫øt k·∫ø, kh√¥ng th·ªÉ s·ª≠a t√™n!', 'error');
                return;
            }

            const trimmed = newLabel.trim();

            // 1. Update Data Model (Detail View Source)
            span.xSectionLabel = trimmed || '';
            // Logic: T·ªëi ∆∞u: N·∫øu c√≥ s·ª≠a n·ªôi dung th√¨ auto-lock nh√£n ƒë√≥
            if (trimmed.length > 0) {
                span.xSectionLabelLocked = true;
            }

            // 2. [CRITICAL] Sync to Plan View Data Source
            syncSpanToPlanData(span);

            // 3. Send to C# to write XData immediately
            const handle = span.Segments?.[0]?.EntityHandle;
            if (handle) {
                const label = span.xSectionLabel || '';
                const locked = span.xSectionLabelLocked ? '1' : '0';
                window.chrome.webview?.postMessage(`UPDATE_SECTION_LABEL|${handle}|${label}|${locked}`);
            }

            // 4. Force Re-render ALL Views to reflect changes
            refreshUI();
        }

        // Edit Section Label (xSectionLabel) via inline editor
        // NO PROMPT - use inline editor like rebar labels
        function editSectionLabel(spanIndex, currentLabel, event, bounds) {
            event?.stopPropagation();

            const span = currentGroup?.Spans?.[spanIndex];
            if (!span) return;

            // Trigger inline editor for section label with actual bounds
            startInlineLabelEdit({
                type: 'SectionLabel',
                spanIndex: spanIndex,
                x: bounds?.x || 0,
                y: bounds?.y || 0,
                width: bounds?.width || 100,
                height: bounds?.height || 16
            });
        }

        // [FIX AUDIT] Rewritten to ensure Toggle updates visuals everywhere
        // Toggle section label lock state (click on lock/unlock icon)
        function toggleSectionLock(spanIndex, event) {
            event?.stopPropagation();

            const span = currentGroup?.Spans?.[spanIndex];
            if (!span) return;

            // [FIX LOCK] Ch·∫∑n toggle ch·ªët nh√£n n·∫øu d·∫ßm ƒë√£ ch·ªët thi·∫øt k·∫ø chung
            if (currentGroup.IsLocked) {
                showToast('‚ùå D·∫ßm ƒë√£ ch·ªët thi·∫øt k·∫ø!', 'error');
                return;
            }

            // 1. Update Data Model
            const wasLocked = span.xSectionLabelLocked === true;
            span.xSectionLabelLocked = !wasLocked;

            // 2. [CRITICAL] Sync to Plan View Data Source
            syncSpanToPlanData(span);

            // 3. Send to C#
            const handle = span.Segments?.[0]?.EntityHandle;
            if (handle) {
                const label = span.xSectionLabel || '';
                const locked = span.xSectionLabelLocked ? '1' : '0';
                window.chrome.webview?.postMessage(`UPDATE_SECTION_LABEL|${handle}|${label}|${locked}`);
            }

            // 4. Force Re-render ALL Views
            refreshUI();
        }

        function selectNoneSpans() {
            currentGroup.Spans.forEach(s => s.IsActive = false);
            renderTable();
        }

        function applyStirrupPattern() {
            const pattern = document.getElementById('stirrupPattern').value;
            const parts = pattern.replace(/[a-zA-Z]/g, '').split('/');
            const dia = pattern.match(/d(\d+)/)?.[1] || '8';

            currentGroup.Spans.forEach(span => {
                if (span.IsActive !== false) {
                    span.Stirrup = [
                        `d${dia}a${parts[0] || 100}`,
                        `d${dia}a${parts[1] || 150}`,
                        `d${dia}a${parts[2] || 100}`
                    ];
                }
            });
            renderTable();
            showToast('‚úì ƒê√£ apply stirrup pattern');
        }

        // ============ HIGHLIGHT & SYNC ============
        // NOTE: highlightSpan and clearHighlight are defined earlier (line ~785)
        // to ensure proper rendering order with renderPlanView/renderDetailCanvas

        // ============ V5.0 GROUP OPERATIONS ============
        // Send DETACH message to C# for selected/highlighted span
        function sendDetachSelected() {
            const span = currentGroup?.Spans?.[highlightedSpanIndex];
            if (!span?.Segments?.length) {
                showToast('‚ùå Ch·ªçn 1 span ƒë·ªÉ t√°ch kh·ªèi group!', 'error');
                return;
            }
            const handle = span.Segments[0]?.EntityHandle;
            if (!handle) {
                showToast('‚ùå Kh√¥ng t√¨m th·∫•y EntityHandle!', 'error');
                return;
            }
            window.chrome.webview.postMessage('DETACH|' + handle);
        }

        // Send UNGROUP message to C# for current group
        function sendUngroupCurrent() {
            if (!currentGroup) {
                showToast('‚ùå Kh√¥ng c√≥ group hi·ªán t·∫°i!', 'error');
                return;
            }
            // Get GroupId from first span's handle (C# will get GroupId from XData)
            const handle = currentGroup.Spans?.[0]?.Segments?.[0]?.EntityHandle;
            if (!handle) {
                showToast('‚ùå Kh√¥ng t√¨m th·∫•y EntityHandle!', 'error');
                return;
            }
            // Read GroupId from currentGroup if available, fallback to handle
            const groupId = currentGroup.GroupId || handle;
            window.chrome.webview.postMessage('UNGROUP|' + groupId);
        }

        // Send REGROUP message to C# for selected spans
        function sendRegroupSelected() {
            const handles = [];
            currentGroup?.Spans?.forEach(span => {
                if (span.IsActive && span.Segments?.length > 0) {
                    span.Segments.forEach(seg => {
                        if (seg.EntityHandle) handles.push(seg.EntityHandle);
                    });
                }
            });
            if (handles.length < 2) {
                showToast('‚ùå Ch·ªçn √≠t nh·∫•t 2 span ƒë·ªÉ t·∫°o group m·ªõi!', 'error');
                return;
            }
            window.chrome.webview.postMessage('REGROUP|' + JSON.stringify(handles));
        }

        // V5.0: Update stale geometry warning banner
        function updateStaleGeometryBanner() {
            const banner = document.getElementById('staleGeometryBanner');
            if (!banner) return;
            if (currentGroup?.HasStaleGeometry) {
                banner.classList.remove('hidden');
            } else {
                banner.classList.add('hidden');
            }
        }

        // V5.0: Properties Panel Functions (per spec Section 9.2)
        function showPropertiesPanel(spanIndex) {
            const panel = document.getElementById('propertiesPanel');
            const span = currentGroup?.Spans?.[spanIndex];
            if (!panel || !span) return;

            // Populate fields
            document.getElementById('propHandle').value = span.Segments?.[0]?.EntityHandle || '-';
            document.getElementById('propSpanId').value = span.SpanId || '-';
            document.getElementById('propWidth').value = span.Width ? `${span.Width}mm` : '-';
            document.getElementById('propHeight').value = span.Height ? `${span.Height}mm` : '-';
            document.getElementById('propLength').value = span.Length ? `${(span.Length / 1000).toFixed(2)}m` : '-';

            // Populate Option select
            const optSelect = document.getElementById('propOption');
            optSelect.innerHTML = '';
            // V7.0: ƒê·ªçc t·ª´ span.Options
            if (span.Options?.length > 0) {
                span.Options.forEach((opt, i) => {
                    const optEl = document.createElement('option');
                    optEl.value = i;
                    optEl.textContent = `Opt${i}: ${opt.TopL0 || '-'}`;
                    optEl.selected = (i === currentGroup.SelectedBackboneIndex);
                    optSelect.appendChild(optEl);
                });
            }

            // Locked checkbox
            const lockedCb = document.getElementById('propLocked');
            const lockedLabel = document.getElementById('propLockedLabel');
            lockedCb.checked = currentGroup.IsLocked || false;
            lockedLabel.textContent = lockedCb.checked ? 'ƒê√£ ch·ªët' : 'Ch∆∞a ch·ªët';

            panel.classList.remove('hidden');
        }

        function closePropertiesPanel() {
            document.getElementById('propertiesPanel')?.classList.add('hidden');
        }

        // FIX 3: Helper to find beam at screen coordinates
        function findBeamAtPoint(screenX, screenY) {
            if (!data.allBeams) return null;
            const z = Beam.State.currentStoryZ;
            const Z_TOL = 500;
            const beamsOnStory = data.allBeams.filter(b => Math.abs((b.LevelZ || 0) - z) < Z_TOL);
            if (beamsOnStory.length === 0) return null;

            // Use SHARED transform state
            const { baseScale, baseOffsetX, baseOffsetY, lh } = planTransform;

            const tx = x => (x * baseScale + baseOffsetX) * canvasZoom + canvasPanX;
            const ty = y => (lh - (y * baseScale + baseOffsetY)) * canvasZoom + canvasPanY;

            // Hit test
            const HIT_TOLERANCE = 10; // pixels
            for (const beam of beamsOnStory) {
                const x1 = tx(beam.StartX), y1 = ty(beam.StartY);
                const x2 = tx(beam.EndX), y2 = ty(beam.EndY);

                // Distance from point to line segment
                const dist = pointToLineDistance(screenX, screenY, x1, y1, x2, y2);
                if (dist < HIT_TOLERANCE) return beam;
            }
            return null;
        }

        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = lenSq !== 0 ? dot / lenSq : -1;
            param = Math.max(0, Math.min(1, param));
            const xx = x1 + param * C, yy = y1 + param * D;
            return Math.hypot(px - xx, py - yy);
        }

        // === BOX SELECTION (Window/Crossing) ===
        function performBoxSelection(left, right, top, bottom, isWindow) {
            const z = Beam.State.currentStoryZ;
            const Z_TOL = 500;
            const beamsOnStory = (data.allBeams || []).filter(b =>
                Math.abs((b.LevelZ || 0) - z) < Z_TOL);

            if (beamsOnStory.length === 0) return;

            const { baseScale, baseOffsetX, baseOffsetY, lh } = planTransform;
            const tx = x => (x * baseScale + baseOffsetX) * canvasZoom + canvasPanX;
            const ty = y => (lh - (y * baseScale + baseOffsetY)) * canvasZoom + canvasPanY;

            beamsOnStory.forEach(b => {
                if (!b.Handle) return;

                const x1 = tx(b.StartX), y1 = ty(b.StartY);
                const x2 = tx(b.EndX), y2 = ty(b.EndY);
                const bLeft = Math.min(x1, x2), bRight = Math.max(x1, x2);
                const bTop = Math.min(y1, y2), bBottom = Math.max(y1, y2);

                let selected = false;
                if (isWindow) {
                    // Window: N·∫±m tr·ªçn trong v√πng
                    selected = bLeft >= left && bRight <= right && bTop >= top && bBottom <= bottom;
                } else {
                    // Crossing: Giao nhau v·ªõi v√πng
                    selected = !(bRight < left || bLeft > right || bBottom < top || bTop > bottom);
                }

                if (selected) {
                    Beam.State.selectedHandles.add(b.Handle);
                }
            });
        }


        // FIX 3: Find group containing beam by handle
        function findGroupByBeamHandle(handle) {
            if (!data.groups || !handle) return -1;
            for (let i = 0; i < data.groups.length; i++) {
                if (data.groups[i].EntityHandles?.includes(handle)) return i;
            }
            return -1;
        }

        // NEW: Find span index at click position (for quick span selection)
        function findSpanAtClickPosition(clickedBeam, screenX, screenY) {
            if (!currentGroup?.Spans || currentGroup.Spans.length === 0) return -1;

            // For single-beam groups, just return 0
            if (currentGroup.Spans.length === 1) return 0;

            // Use SHARED transform state
            const { baseScale, baseOffsetX, baseOffsetY, lh } = planTransform;

            // Find which span entity was clicked
            const groupHandles = currentGroup.EntityHandles || [];
            for (let spanIdx = 0; spanIdx < groupHandles.length; spanIdx++) {
                const beam = data.allBeams.find(b => b.Handle === groupHandles[spanIdx]);
                if (!beam) continue;

                // Transform beam coords to screen
                const x1 = (beam.StartX * baseScale + baseOffsetX) * canvasZoom + canvasPanX;
                const y1 = (lh - (beam.StartY * baseScale + baseOffsetY)) * canvasZoom + canvasPanY;
                const x2 = (beam.EndX * baseScale + baseOffsetX) * canvasZoom + canvasPanX;
                const y2 = (lh - (beam.EndY * baseScale + baseOffsetY)) * canvasZoom + canvasPanY;

                // Check if click is near this beam segment
                const dist = pointToLineDistance(screenX, screenY, x1, y1, x2, y2);
                if (dist < 15) { // Use slightly larger tolerance for span selection
                    return spanIdx;
                }
            }
            return -1;
        }

        // FIX 4: Show properties for clicked beam
        function showBeamProperties(beam) {
            const panel = document.getElementById('propertiesPanel');
            if (!panel || !beam) return;

            document.getElementById('propHandle').value = beam.Handle || '-';
            document.getElementById('propSpanId').value = beam.SpanIndex != null ? `S${beam.SpanIndex + 1}` : '-';
            document.getElementById('propWidth').value = beam.Width ? `${beam.Width}mm` : '-';
            document.getElementById('propHeight').value = beam.Height ? `${beam.Height}mm` : '-';
            const len = Math.hypot(beam.EndX - beam.StartX, beam.EndY - beam.StartY);
            document.getElementById('propLength').value = len > 0 ? `${(len / 1000).toFixed(2)}m` : '-';

            panel.classList.remove('hidden');
        }

        // Auto-naming functions
        function showAutoNameConfirm() {
            runAutoName();
        }

        function runAutoName() {
            const selectedHandles = Array.from(Beam.State.selectedHandles);
            const z = Beam.State.currentStoryZ;
            const Z_TOL = 500;

            // L·∫•y danh s√°ch d·∫ßm tr√™n t·∫ßng hi·ªán t·∫°i (All Beams source)
            const allBeamsOnStory = (data.allBeams || []).filter(b =>
                Math.abs((b.LevelZ || 0) - z) < Z_TOL);

            if (selectedHandles.length === 0) {
                // TR∆Ø·ªúNG H·ª¢P 1: Kh√¥ng c√≥ d·∫ßm ƒë∆∞·ª£c ch·ªçn -> H·ªèi ƒë·∫∑t t√™n to√†n b·ªô (ch·ªâ nh·ªØng d·∫ßm CH∆ØA KH√ìA)
                const unlockableHandles = allBeamsOnStory
                    .filter(b => !b.xSectionLabelLocked)
                    .map(b => b.Handle);

                if (unlockableHandles.length === 0) {
                    showToast('‚ÑπÔ∏è To√†n b·ªô d·∫ßm tr√™n t·∫ßng n√†y ƒë√£ ƒë∆∞·ª£c ch·ªët t√™n.');
                    return;
                }

                showCanvasConfirm(`ƒê·∫∑t t√™n cho ${unlockableHandles.length} d·∫ßm ch∆∞a ch·ªët tr√™n t·∫ßng n√†y?`,
                    () => sendAutoNameCommand(unlockableHandles),
                    () => { }
                );
            } else {
                // TR∆Ø·ªúNG H·ª¢P 2: C√≥ d·∫ßm ƒë∆∞·ª£c ch·ªçn -> Ch·ªâ ƒë·∫∑t t√™n nh·ªØng d·∫ßm CH∆ØA KH√ìA trong v√πng ch·ªçn
                const validHandles = allBeamsOnStory
                    .filter(b => selectedHandles.includes(b.Handle) && !b.xSectionLabelLocked)
                    .map(b => b.Handle);

                if (validHandles.length === 0) {
                    showToast('‚ö†Ô∏è C√°c d·∫ßm ƒë∆∞·ª£c ch·ªçn ƒë·ªÅu ƒë√£ ch·ªët t√™n!', 'warning');
                    return;
                }

                if (validHandles.length < selectedHandles.length) {
                    const lockedCount = selectedHandles.length - validHandles.length;
                    showToast(`‚ÑπÔ∏è ƒê√£ b·ªè qua ${lockedCount} d·∫ßm ƒë√£ ch·ªët t√™n`);
                }

                sendAutoNameCommand(validHandles);
            }
        }

        function sendAutoNameCommand(handles) {
            if (window.chrome?.webview) {
                window.chrome.webview.postMessage('AUTO_NAME|' + JSON.stringify(handles));
                showToast('‚è≥ ƒêang ƒë·∫∑t t√™n...');
            } else {
                console.warn('WebView2 not found');
            }
        }

        // === ELEMENTS PANEL - Hi·ªÉn th·ªã SECTION LABELS duy nh·∫•t ===
        function updateElementsPanel() {
            const content = document.getElementById('elements-list-content');
            const countEl = document.getElementById('elements-count');
            const selectedBar = document.getElementById('elements-selected-bar');
            const selectedCountEl = document.getElementById('elements-selected-count');

            if (!content) return;

            const z = Beam.State.currentStoryZ;
            const Z_TOL = 500;

            // L·ªçc d·∫ßm tr√™n t·∫ßng hi·ªán t·∫°i
            const beamsOnStory = (data.allBeams || []).filter(b =>
                Math.abs((b.LevelZ || 0) - z) < Z_TOL);

            // T·∫°o map: sectionLabel -> [handles]
            const sectionMap = new Map();
            beamsOnStory.forEach(b => {
                const label = b.xSectionLabel || b.SectionLabel || '-';
                if (!sectionMap.has(label)) {
                    sectionMap.set(label, []);
                }
                if (b.Handle) {
                    sectionMap.get(label).push(b.Handle);
                }
            });

            // S·∫Øp x·∫øp theo t√™n
            const sortedSections = Array.from(sectionMap.entries()).sort((a, b) =>
                a[0].localeCompare(b[0], undefined, { numeric: true }));

            countEl.textContent = sortedSections.length;

            let html = '';
            sortedSections.forEach(([label, handles]) => {
                const allSelected = handles.length > 0 && handles.every(h => Beam.State.isHandleSelected(h));
                const someSelected = handles.some(h => Beam.State.isHandleSelected(h));

                const bgClass = allSelected ? 'bg-orange-100' : someSelected ? 'bg-orange-50' : 'hover:bg-slate-50';
                const textClass = allSelected ? 'text-orange-700 font-bold' : 'text-slate-700';
                const escapedLabel = label.replace(/'/g, "\\'");

                html += `
                    <div class="px-2 py-1.5 border-b border-slate-100 cursor-pointer ${bgClass} ${textClass} flex items-center justify-between"
                         onclick="onSectionClick(event, '${escapedLabel}')"
                         title="${label} (${handles.length} d·∫ßm)">
                        <span class="truncate flex-1"><i class="fa-solid fa-tag mr-1 text-slate-400"></i>${label}</span>
                        <span class="text-[9px] text-slate-400">${handles.length}</span>
                    </div>
                `;
            });

            content.innerHTML = html || '<div class="px-2 py-2 text-slate-400 text-center">Kh√¥ng c√≥ sections</div>';

            // Update selected count
            const selectedCount = Beam.State.selectedHandles.size;
            if (selectedCount > 0) {
                selectedBar.classList.remove('hidden');
                selectedCountEl.textContent = selectedCount;
            } else {
                selectedBar.classList.add('hidden');
            }
        }

        // Click handler for Section items (ch·ªçn theo section label)
        function onSectionClick(event, sectionLabel) {
            const z = Beam.State.currentStoryZ;
            const Z_TOL = 500;

            // T√¨m t·∫•t c·∫£ d·∫ßm c√≥ c√πng section label tr√™n t·∫ßng hi·ªán t·∫°i
            const beamsOnStory = (data.allBeams || []).filter(b =>
                Math.abs((b.LevelZ || 0) - z) < Z_TOL);

            const handles = beamsOnStory
                .filter(b => (b.xSectionLabel || b.SectionLabel || '-') === sectionLabel)
                .map(b => b.Handle)
                .filter(h => h);

            if (event.ctrlKey) {
                // Ctrl+Click: Toggle section
                const allSelected = handles.every(h => Beam.State.isHandleSelected(h));
                if (allSelected) {
                    Beam.State.removeHandlesFromSelection(handles);
                } else {
                    Beam.State.addHandlesToSelection(handles);
                }
            } else if (event.shiftKey) {
                // Shift+Click: Add to selection
                Beam.State.addHandlesToSelection(handles);
            } else {
                // Normal click: Select only this section
                Beam.State.clearHandleSelection();
                Beam.State.addHandlesToSelection(handles);
            }

            render();
        }

        // FIX 5: Toggle group name labels on plan view (3 ch·∫ø ƒë·ªô: OFF -> GROUP -> SECTION)
        function toggleGroupLabels() {
            // Chuy·ªÉn ƒë·ªïi tr·∫°ng th√°i: 0 -> 1 -> 2 -> 0
            labelMode = (labelMode + 1) % 3;

            const btn = document.getElementById('btnToggleLabelsFloat');
            if (btn) {
                // C·∫≠p nh·∫≠t giao di·ªán n√∫t b·∫•m
                if (labelMode === 0) {
                    btn.innerHTML = '<i class="fa-solid fa-tag"></i>'; // Icon t·∫Øt
                    btn.className = "w-8 h-8 bg-slate-600/80 hover:bg-slate-500 text-slate-400 text-sm rounded flex items-center justify-center";
                    btn.title = "ƒêang T·∫Øt Label (Click ƒë·ªÉ hi·ªán Group)";
                    showToast('Labels: OFF');
                } else if (labelMode === 1) {
                    btn.innerHTML = '<i class="fa-solid fa-layer-group"></i>'; // Icon Group
                    btn.className = "w-8 h-8 bg-blue-600/80 hover:bg-blue-500 text-white text-sm rounded flex items-center justify-center";
                    btn.title = "ƒêang hi·ªán Group Label (Click ƒë·ªÉ hi·ªán Section)";
                    showToast('Labels: GROUP NAME');
                } else {
                    btn.innerHTML = '<i class="fa-solid fa-ruler-combined"></i>'; // Icon Section
                    btn.className = "w-8 h-8 bg-green-600/80 hover:bg-green-500 text-white text-sm rounded flex items-center justify-center";
                    btn.title = "ƒêang hi·ªán Section Label (Click ƒë·ªÉ T·∫Øt)";
                    showToast('Labels: SECTION SIZE');
                }
            }
            renderPlanView(); // V·∫Ω l·∫°i canvas
        }

        // Reset canvas view to fit content and center on grid
        function resetCanvasView() {
            canvasZoom = 1.0;
            canvasPanX = 0;
            canvasPanY = 0;
            render();
            centerCanvas();
            showToast('View reset');
        }

        // Update overlay positions based on panels state
        function updateOverlayPositions() {
            const detailPanel = document.getElementById('detailPanel');
            const detailVisibleHeight = (detailPanel && !detailPanelCollapsed) ? detailPanel.offsetHeight : 0;

            const bottomOffset = detailVisibleHeight + 10;
            const rightOffset = rightSidebarCollapsed ? 10 : 330; // 320px sidebar + 10px margin

            const zoomIndicator = document.getElementById('zoomIndicator');
            const helpOverlay = document.getElementById('helpOverlay');
            const zoomFitBtn = document.querySelector('button[onclick="resetPlanCanvasView()"]');

            if (zoomIndicator) {
                zoomIndicator.style.bottom = `${bottomOffset}px`;
                zoomIndicator.style.right = `${rightOffset}px`;
                // FIX: C·∫≠p nh·∫≠t lu√¥n ch·ªâ s·ªë % zoom
                zoomIndicator.textContent = `${Math.round(canvasZoom * 100)}%`;
            }
            if (helpOverlay) {
                helpOverlay.style.bottom = `${bottomOffset}px`;
            }
            if (zoomFitBtn) {
                zoomFitBtn.style.right = `${rightOffset}px`;
            }

            // Sync float button icon
            const sidebarIcon = document.getElementById('rightSidebarIcon');
            if (sidebarIcon) {
                sidebarIcon.className = rightSidebarCollapsed ? 'fa-solid fa-chevron-left text-xs' : 'fa-solid fa-chevron-right text-xs';
            }
        }

        // FIX 3: Tab key to cycle through SPANS in current group (synced with mouse)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Tab' && canvasMode === 'plan') {
                e.preventDefault();

                // Get current group's spans
                const spanCount = currentGroup?.Spans?.length || 0;
                if (spanCount === 0) return;

                // Cycle: -1 (all) -> 0 -> 1 -> ... -> last -> -1 (all)
                if (highlightedSpanIndex === -1) {
                    // Full beam ‚Üí start from span 0
                    highlightedSpanIndex = 0;
                } else {
                    // Next span
                    highlightedSpanIndex = highlightedSpanIndex + 1;
                    if (highlightedSpanIndex >= spanCount) {
                        highlightedSpanIndex = -1;  // Back to full beam
                    }
                }

                // Update message and sync all views
                if (highlightedSpanIndex === -1) {
                    showToast(`Ch·∫ø ƒë·ªô: C·∫£ nh√≥m (${spanCount} nh·ªãp)`);
                } else {
                    showToast(`Nh·ªãp ${highlightedSpanIndex + 1}/${spanCount}`);
                }

                // Sync all views like highlightSpan does
                refreshUI();
                renderDetailCanvas();
                renderTable();

                // Scroll table to highlighted row
                if (highlightedSpanIndex >= 0) {
                    const row = document.querySelector(`[data-span-index="${highlightedSpanIndex}"]`);
                    if (row) {
                        const container = document.getElementById('tablePanelContent');
                        if (container) {
                            const rowTop = row.offsetTop;
                            const containerHeight = container.clientHeight;
                            container.scrollTo({
                                top: rowTop - containerHeight / 2 + row.offsetHeight / 2,
                                behavior: 'smooth'
                            });
                        }
                    }
                }
            }
        });

        function onPropOptionChange(value) {
            const idx = parseInt(value, 10);
            if (!isNaN(idx) && currentGroup) {
                selectOption(idx);
            }
        }

        function onPropLockedChange(checked) {
            if (currentGroup) {
                currentGroup.IsLocked = checked;
                document.getElementById('propLockedLabel').textContent = checked ? 'ƒê√£ ch·ªët' : 'Ch∆∞a ch·ªët';
                if (checked) {
                    toggleLock();
                }
            }
        }

        // V5.0: Update visual indicators based on group state
        function updateVisualIndicators() {
            const motherEl = document.getElementById('motherIndicator');
            const lockedEl = document.getElementById('lockedIndicator');
            const brokenChainEl = document.getElementById('brokenChainIndicator');
            const manualEditEl = document.getElementById('manualEditIndicator');

            if (!motherEl || !currentGroup) return;

            // Show üëë if viewing first span (Mother)
            if (highlightedSpanIndex === 0) {
                motherEl.classList.remove('hidden');
            } else {
                motherEl.classList.add('hidden');
            }

            // V7.0: Show lock badge if design is locked
            if (currentGroup.IsLocked) {
                lockedEl.classList.remove('hidden');
            } else {
                lockedEl.classList.add('hidden');
            }

            // Show üîó‚ùå if SpanIndex has gaps
            const hasGap = detectSpanIndexGap();
            if (hasGap) {
                brokenChainEl.classList.remove('hidden');
            } else {
                brokenChainEl.classList.add('hidden');
            }

            // Show ‚ö†Ô∏è if manually edited
            if (currentGroup.IsManuallyEdited) {
                manualEditEl.classList.remove('hidden');
            } else {
                manualEditEl.classList.add('hidden');
            }
        }

        // Helper: Check if SpanIndex has gaps
        function detectSpanIndexGap() {
            if (!currentGroup?.Spans) return false;
            // Check for missing spans in sequence 0, 1, 2...
            for (let i = 0; i < currentGroup.Spans.length; i++) {
                const span = currentGroup.Spans[i];
                if (span.SpanIndex !== undefined && span.SpanIndex !== i) {
                    return true;
                }
            }
            return false;
        }

        // ============ MATERIAL GRADE SELECTION ============
        function setGroupConcrete(grade) {
            if (currentGroup) {
                currentGroup.ConcreteGrade = grade;
                showToast(`‚úì ƒê√£ ch·ªçn b√™ t√¥ng ${grade}`);
            }
        }

        function setGroupSteel(grade) {
            if (currentGroup) {
                currentGroup.SteelGrade = grade;
                showToast(`‚úì ƒê√£ ch·ªçn th√©p ${grade}`);
            }
        }

        function loadMaterialSelects() {
            const concreteSelect = document.getElementById('concreteGradeSelect');
            const steelSelect = document.getElementById('steelGradeSelect');

            if (currentGroup?.ConcreteGrade) {
                concreteSelect.value = currentGroup.ConcreteGrade;
            }
            if (currentGroup?.SteelGrade) {
                steelSelect.value = currentGroup.SteelGrade;
            }
        }

        // ============ CAD INTEGRATION ============
        function highlightInCAD() {
            if (!currentGroup?.EntityHandles?.length) {
                showToast('‚ö†Ô∏è Kh√¥ng c√≥ d·∫ßm ƒë·ªÉ highlight');
                return;
            }
            // Send message to C# to highlight beams
            window.chrome.webview.postMessage('HIGHLIGHT|' + JSON.stringify(currentGroup.EntityHandles));
            showToast('‚úì ƒê√£ highlight ' + currentGroup.EntityHandles.length + ' d·∫ßm tr√™n CAD');
        }

        // ============ COPY FORMAT ============
        let copyFormatMode = false;
        let copySourceSpan = null;

        function copyFormat() {
            copyFormatMode = true;
            copySourceSpan = null;
            document.body.style.cursor = 'crosshair';
            showToast('Click nh·ªãp ngu·ªìn ƒë·ªÉ copy format...');
        }

        // ============ ACTIONS ============
        function doSave() { window.chrome.webview.postMessage('SAVE|' + JSON.stringify(data)); }
        function doExport() { window.chrome.webview.postMessage('EXPORT'); }
        function doImport() { window.chrome.webview.postMessage('IMPORT'); }
        function doCancel() { window.chrome.webview.postMessage('CANCEL'); }
        function applyToDrawing() { window.chrome.webview.postMessage('APPLY|' + JSON.stringify(data)); }

        // [NEW] Pull latest data from CAD XData
        function pullDataFromCad() {
            if (!currentGroup) {
                console.warn('[Pull] No current group to pull data for');
                return;
            }

            // Show waiting message
            console.log('‚è≥ Pulling latest data from CAD XData...');
            showToast('‚è≥ ƒêang l√†m m·ªõi d·ªØ li·ªáu...');

            // REFRESH_DATA triggers a full sweep in C# and returns updated data package
            sendRefreshAllData();

            // [FIX] Also pull heavy rebar data for the current group details
            if (typeof currentGroupIndex !== 'undefined') {
                window.chrome.webview?.postMessage('PULL_DATA|' + currentGroupIndex);
            }
        }

        // ============ TOAST & CANVAS CONFIRM ============
        function showToast(msg, duration = 2000) {
            let overlay = document.getElementById('canvas-toast');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'canvas-toast';
                overlay.className = 'fixed top-4 left-1/2 -translate-x-1/2 bg-slate-800 text-white px-4 py-2 rounded-lg text-sm font-medium z-50 shadow-lg';
                overlay.style.transition = 'opacity 0.3s ease';
                document.body.appendChild(overlay);
            }
            overlay.innerText = msg;
            overlay.style.opacity = '1';
            setTimeout(() => { overlay.style.opacity = '0'; }, duration);
        }

        function showCanvasConfirm(msg, onYes, onNo) {
            const existing = document.getElementById('canvas-confirm');
            if (existing) existing.remove();

            const popup = document.createElement('div');
            popup.id = 'canvas-confirm';
            popup.className = 'absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white shadow-xl rounded-lg p-4 z-50 border border-slate-200';
            popup.innerHTML = `
                <p class="text-sm text-slate-700 mb-3">${msg}</p>
                <div class="flex gap-2 justify-end">
                    <button class="px-3 py-1 bg-slate-200 hover:bg-slate-300 rounded text-xs font-medium" data-action="no">Kh√¥ng</button>
                    <button class="px-3 py-1 bg-blue-500 hover:bg-blue-600 text-white rounded text-xs font-medium" data-action="yes">C√≥</button>
                </div>
            `;
            document.getElementById('beamCanvas').parentElement.appendChild(popup);

            popup.querySelector('[data-action="no"]').onclick = () => { popup.remove(); if (onNo) onNo(); };
            popup.querySelector('[data-action="yes"]').onclick = () => { popup.remove(); if (onYes) onYes(); };
        }

        // Init
        init();

        // ============ EXPORT TO BEAM NAMESPACE ============
        // This allows external access and future module extraction
        Object.assign(Beam, {
            // Navigation
            loadGroup,
            prevGroup,
            nextGroup,
            populateGroupSelect,

            // Options
            populateOptionSelect,
            selectOption,
            getSelectedOption,
            applyOptionToSpans,

            // Lock/Unlock
            toggleLock,
            restoreLockedDesign,
            updateLockStatus,

            // Rendering
            renderCanvas,
            renderTable,
            drawSupport,
            drawRebarLines,

            // Table editing
            toggleSpanActive,
            updateRebar,
            updateLayerRebar,
            updateStirrup,
            updateWebBar,
            updateSideBar,
            renderLayerRebarInputs,
            renderStirrupInputs,

            // Highlight
            highlightSpan,
            clearHighlight,

            // Actions
            doSave,
            doExport,
            doImport,
            doCancel,
            applyToDrawing,
            quickCalc,
            showCalculationReport,
            copyFormat,

            // UI
            showToast,
            toggleTablePanel,
            setCanvasMode,
            toggleHighlightMode,

            // Material
            setGroupConcrete,
            setGroupSteel,

            // Utils
            resizeCanvas,
            selectAllSpans,
            selectNoneSpans,
            applyStirrupPattern,

            // V5.0 Group Operations
            sendDetachSelected,
            sendUngroupCurrent,
            sendRegroupSelected,
            updateStaleGeometryBanner,
            updateVisualIndicators
        });

        // Sync state to namespace
        Beam.State.currentGroupIndex = currentGroupIndex;
        Beam.State.currentGroup = currentGroup;

        // Keyboard shortcuts for Undo/Redo
        document.addEventListener('keydown', (e) => {
            // Skip if focus is in input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            if (e.ctrlKey && e.key === 'z') { e.preventDefault(); Beam.History.undo(); }
            if (e.ctrlKey && e.key === 'y') { e.preventDefault(); Beam.History.redo(); }
        });

        console.log('Beam Viewer initialized with namespace:', Object.keys(Beam));
    </script>

</body>

</html>