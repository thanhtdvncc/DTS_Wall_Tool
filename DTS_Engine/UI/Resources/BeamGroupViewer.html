<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <title>DTS Beam Group Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        accent: '#f59e0b',
                        danger: '#ef4444',
                        success: '#22c55e'
                    }
                }
            }
        }
    </script>
    <style>
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        .span-row.highlighted {
            background: rgba(59, 130, 246, 0.15) !important;
        }

        .span-row:hover {
            background: rgba(59, 130, 246, 0.08);
        }

        .span-row.selected {
            background: rgba(34, 197, 94, 0.15);
        }

        .toast {
            animation: slideUp 0.3s ease, fadeOut 2.5s 0.5s forwards;
        }

        @keyframes slideUp {
            from {
                transform: translate(-50%, 100%);
                opacity: 0;
            }

            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
            }
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
    </style>
</head>

<body class="bg-slate-100 text-slate-800 font-sans text-sm h-screen flex flex-col overflow-hidden">

    <!-- HEADER -->
    <header class="flex-none bg-slate-900 text-white shadow-md z-50">
        <div class="px-4 py-2 flex justify-between items-center gap-4">
            <div class="flex items-center gap-3">
                <i class="fa-solid fa-layer-group text-amber-500 text-xl"></i>
                <h1 class="text-lg font-bold">DTS Rebar Viewer</h1>
            </div>

            <div class="flex items-center gap-3">
                <button class="nav-btn px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded" onclick="prevGroup()">
                    <i class="fa-solid fa-chevron-left"></i>
                </button>
                <select id="groupSelect" onchange="loadGroup(this.value)"
                    class="bg-slate-800 border border-slate-600 text-white px-3 py-1 rounded min-w-[180px]"></select>
                <button class="nav-btn px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded" onclick="nextGroup()">
                    <i class="fa-solid fa-chevron-right"></i>
                </button>
            </div>

            <div class="flex items-center gap-2">
                <label class="text-xs text-slate-400">Ph∆∞∆°ng √°n:</label>
                <select id="optionSelect" onchange="selectOption(this.value)"
                    class="bg-slate-800 border border-slate-600 text-white px-2 py-1 rounded text-xs"></select>
                <button id="lockBtn" onclick="lockDesign()" title="Ch·ªët ph∆∞∆°ng √°n n√†y l√†m Official Design"
                    class="px-2 py-1 bg-amber-600 hover:bg-amber-500 text-white rounded text-xs flex items-center gap-1">
                    <i class="fa-solid fa-lock"></i> Ch·ªët
                </button>
                <span id="lockStatus" class="text-xs text-green-400 hidden">
                    <i class="fa-solid fa-check-circle"></i> ƒê√£ ch·ªët
                </span>
            </div>

            <div class="flex items-center gap-2">
                <label class="text-xs text-slate-400">B√™ t√¥ng:</label>
                <select id="concreteGradeSelect" onchange="setGroupConcrete(this.value)"
                    class="bg-slate-800 border border-slate-600 text-white px-2 py-1 rounded text-xs">
                    <option value="B20">B20</option>
                    <option value="B25" selected>B25</option>
                    <option value="B30">B30</option>
                    <option value="B35">B35</option>
                    <option value="B40">B40</option>
                </select>
                <label class="text-xs text-slate-400 ml-2">Th√©p:</label>
                <select id="steelGradeSelect" onchange="setGroupSteel(this.value)"
                    class="bg-slate-800 border border-slate-600 text-white px-2 py-1 rounded text-xs">
                    <option value="CB300">CB300</option>
                    <option value="CB400" selected>CB400</option>
                    <option value="CB500">CB500</option>
                </select>
            </div>

            <div class="flex gap-2 items-center">
                <!-- Highlight CAD Toggle -->
                <label class="flex items-center gap-1 text-xs cursor-pointer">
                    <span class="text-slate-400">Highlight CAD</span>
                    <div class="relative">
                        <input type="checkbox" id="highlightToggle" class="sr-only peer"
                            onchange="toggleHighlightMode(this.checked)">
                        <div class="w-8 h-4 bg-slate-600 rounded-full peer-checked:bg-blue-500 transition-colors"></div>
                        <div
                            class="absolute top-0.5 left-0.5 w-3 h-3 bg-white rounded-full peer-checked:translate-x-4 transition-transform">
                        </div>
                    </div>
                </label>
                <button class="px-3 py-1 bg-slate-700 hover:bg-slate-600 text-white rounded text-xs"
                    onclick="copyFormat()"><i class="fa-solid fa-paintbrush mr-1"></i>Copy Format</button>
            </div>
        </div>
    </header>

    <!-- MAIN -->
    <main class="flex-1 flex flex-col overflow-hidden">
        <!-- CANVAS CONTAINER -->
        <div class="flex-none h-[200px] bg-white border-b border-slate-200 overflow-x-auto overflow-y-hidden relative"
            id="canvasContainer">
            <canvas id="beamCanvas" height="180"></canvas>
        </div>

        <!-- METRICS BAR -->
        <div
            class="flex-none bg-slate-50 border-b border-slate-200 px-4 py-2 flex items-center gap-6 text-xs flex-wrap">
            <div class="flex items-center gap-2">
                <span class="text-slate-500">Backbone:</span>
                <span class="font-bold text-blue-600" id="metricBackbone">-</span>
            </div>
            <div class="flex items-center gap-2">
                <span class="text-slate-500">As:</span>
                <span class="font-bold" id="metricAs">-</span>
            </div>
            <div class="flex items-center gap-2">
                <span class="text-slate-500">Waste:</span>
                <span class="font-bold" id="metricWaste">-</span>
            </div>
            <div class="flex items-center gap-2">
                <span class="text-slate-500">Weight:</span>
                <span class="font-bold" id="metricWeight">-</span>
            </div>
            <div class="flex items-center gap-2">
                <span class="text-slate-500">Score:</span>
                <span class="font-bold text-green-600" id="metricScore">-</span>
            </div>
            <div id="warningsContainer" class="flex gap-2"></div>
        </div>

        <!-- TABLE SECTION -->
        <div class="flex-1 overflow-auto p-3">
            <div class="flex items-center gap-3 mb-2">
                <label class="flex items-center gap-1 text-xs">
                    <input type="checkbox" id="autoApply" checked class="w-3.5 h-3.5">
                    Auto Apply
                </label>
                <button class="px-2 py-1 bg-slate-200 hover:bg-slate-300 rounded text-xs"
                    onclick="selectAllSpans()">Select All</button>
                <button class="px-2 py-1 bg-slate-200 hover:bg-slate-300 rounded text-xs"
                    onclick="selectNoneSpans()">Select None</button>
                <div class="ml-auto text-xs text-slate-500">
                    <span id="groupInfo">-</span>
                </div>
            </div>

            <div class="bg-white rounded border border-slate-200 overflow-hidden">
                <table class="w-full text-xs">
                    <thead class="bg-slate-100 sticky top-0">
                        <tr>
                            <th class="p-2 text-left w-16">Nh·ªãp</th>
                            <th class="p-2 text-center w-12">‚úì</th>
                            <th class="p-2 text-center w-16">L (m)</th>
                            <th class="p-2 text-center w-20">b√óh</th>
                            <th colspan="3" class="p-2 text-center bg-red-50 text-red-700">TH√âP TR√äN</th>
                            <th colspan="3" class="p-2 text-center bg-blue-50 text-blue-700">TH√âP D∆Ø·ªöI</th>
                            <th colspan="3" class="p-2 text-center bg-slate-100">ƒêAI</th>
                            <th class="p-2 text-center">Gia c∆∞·ªùng</th>
                        </tr>
                        <tr class="text-[10px] text-slate-500">
                            <th></th>
                            <th></th>
                            <th></th>
                            <th></th>
                            <th class="p-1 bg-red-50">L1</th>
                            <th class="p-1 bg-red-50">Mid</th>
                            <th class="p-1 bg-red-50">L2</th>
                            <th class="p-1 bg-blue-50">L1</th>
                            <th class="p-1 bg-blue-50">Mid</th>
                            <th class="p-1 bg-blue-50">L2</th>
                            <th class="p-1">L1</th>
                            <th class="p-1">Mid</th>
                            <th class="p-1">L2</th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody id="spanTableBody"></tbody>
                </table>
            </div>

            <div class="mt-3 flex items-center gap-3">
                <label class="text-xs text-slate-500">Stirrup pattern:</label>
                <input type="text" id="stirrupPattern" value="d8a100/150/100"
                    class="border border-slate-300 rounded px-2 py-1 text-xs w-32">
                <button class="px-2 py-1 bg-slate-200 hover:bg-slate-300 rounded text-xs"
                    onclick="applyStirrupPattern()">
                    Apply to Active
                </button>
            </div>
        </div>
    </main>

    <!-- FOOTER -->
    <footer class="flex-none bg-white border-t border-slate-200 px-4 py-2 flex justify-between items-center">
        <div class="flex gap-2">
            <button class="px-3 py-1.5 bg-slate-200 hover:bg-slate-300 rounded text-xs font-medium" onclick="doSave()">
                <i class="fa-solid fa-save mr-1"></i>Save
            </button>
            <button class="px-3 py-1.5 bg-slate-200 hover:bg-slate-300 rounded text-xs font-medium"
                onclick="doExport()">
                <i class="fa-solid fa-file-export mr-1"></i>Export
            </button>
            <button class="px-3 py-1.5 bg-slate-200 hover:bg-slate-300 rounded text-xs font-medium"
                onclick="doImport()">
                <i class="fa-solid fa-file-import mr-1"></i>Import
            </button>
        </div>
        <div class="flex gap-2">
            <button class="px-3 py-1.5 bg-slate-300 hover:bg-slate-400 rounded text-xs font-medium"
                onclick="doCancel()">
                Cancel
            </button>
            <button class="px-4 py-1.5 bg-blue-600 hover:bg-blue-500 text-white rounded text-xs font-bold"
                onclick="applyToDrawing()">
                <i class="fa-solid fa-check mr-1"></i>Apply to Drawing
            </button>
        </div>
    </footer>

    <script>
        // Data from C#
        const data = __DATA_JSON__;
        let currentGroupIndex = 0;
        let currentGroup = null;
        let highlightedSpanIndex = -1;
        let spanBounds = [];

        // RELATIVE SIZING: Min span width, max canvas width scaled
        const MIN_SPAN_WIDTH = 80;
        const MAX_CANVAS_WIDTH = 1600;
        const CANVAS_PADDING = 30;
        const BEAM_HEIGHT = 50;

        // HIGHLIGHT MODE & TRANSPARENCY STATE
        let highlightModeEnabled = false;

        function toggleHighlightMode(enabled) {
            highlightModeEnabled = enabled;
            if (enabled) {
                // Immediately set 80% transparent when toggle ON
                window.chrome.webview.postMessage('SET_OPACITY|0.2');
                showToast('‚úì Highlight mode ON - form 80% trong su·ªët');
            } else {
                // Reset to full opacity when toggle OFF
                window.chrome.webview.postMessage('SET_OPACITY|1.0');
                showToast('Highlight mode OFF');
            }
        }

        function init() {
            populateGroupSelect();
            if (data.groups && data.groups.length > 0) {
                loadGroup(0);
            }
        }

        function populateGroupSelect() {
            const sel = document.getElementById('groupSelect');
            sel.innerHTML = '';
            if (!data.groups) return;
            data.groups.forEach((g, i) => {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = `${g.GroupName || 'Group ' + (i + 1)} (${g.Spans?.length || 0} nh·ªãp)`;
                sel.appendChild(opt);
            });
        }

        function loadGroup(index) {
            currentGroupIndex = parseInt(index);
            currentGroup = data.groups[currentGroupIndex];
            document.getElementById('groupSelect').value = currentGroupIndex;

            populateOptionSelect();
            renderCanvas();
            renderTable();
            updateMetrics();
            updateGroupInfo();
            loadMaterialSelects();
            updateLockStatus();
        }

        function prevGroup() { if (currentGroupIndex > 0) loadGroup(currentGroupIndex - 1); }
        function nextGroup() { if (currentGroupIndex < data.groups.length - 1) loadGroup(currentGroupIndex + 1); }

        function populateOptionSelect() {
            const sel = document.getElementById('optionSelect');
            sel.innerHTML = '';
            if (!currentGroup?.BackboneOptions) {
                sel.innerHTML = '<option>No options</option>';
                return;
            }
            currentGroup.BackboneOptions.forEach((opt, i) => {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `${opt.OptionName || 'Option ' + (i + 1)}${i === 0 ? ' (Best)' : ''}`;
                sel.appendChild(option);
            });
            sel.value = currentGroup.SelectedBackboneIndex || 0;
        }

        function selectOption(index) {
            currentGroup.SelectedBackboneIndex = parseInt(index);

            // Populate span rebar from selected backbone option
            const opt = currentGroup.BackboneOptions?.[index];
            if (opt) {
                const backbone = `${opt.BackboneCount_Top}D${opt.BackboneDiameter}`;
                const botBackbone = `${opt.BackboneCount_Bot}D${opt.BackboneDiameter}`;
                currentGroup.Spans.forEach(span => {
                    // Only update if not manually edited
                    if (!span._userEdited) {
                        if (!span.TopRebar) span.TopRebar = [[], [], []];
                        if (!span.BotRebar) span.BotRebar = [[], [], []];
                        span.TopRebar[0][0] = backbone;
                        span.TopRebar[0][2] = backbone;
                        span.TopRebar[0][4] = backbone;
                        span.BotRebar[0][0] = botBackbone;
                        span.BotRebar[0][2] = botBackbone;
                        span.BotRebar[0][4] = botBackbone;
                    }
                });
            }

            updateMetrics();
            renderCanvas();
            renderTable();
        }

        // ===== SELECTED DESIGN (Ph∆∞∆°ng √°n Ch·ªët) =====
        function lockDesign() {
            if (!currentGroup) return;

            const selectedIdx = currentGroup.SelectedBackboneIndex || 0;
            const option = currentGroup.BackboneOptions?.[selectedIdx];

            if (!option) {
                showToast('‚ö†Ô∏è Kh√¥ng c√≥ ph∆∞∆°ng √°n ƒë·ªÉ ch·ªët!', 'error');
                return;
            }

            // Clone option v√†o SelectedDesign
            currentGroup.SelectedDesign = JSON.parse(JSON.stringify(option));
            currentGroup.LockedAt = new Date().toISOString();
            currentGroup.LockedBy = 'User';

            updateLockStatus();
            showToast('üîí ƒê√£ CH·ªêT ph∆∞∆°ng √°n l√†m Official Design!', 'success');

            // Notify C# ƒë·ªÉ save
            window.chrome.webview?.postMessage('LOCK_DESIGN|' + currentGroupIndex);
        }

        function unlockDesign() {
            if (!currentGroup) return;

            if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën H·ª¶Y CH·ªêT? Ph∆∞∆°ng √°n ƒë√£ l∆∞u s·∫Ω b·ªã x√≥a.')) return;

            currentGroup.SelectedDesign = null;
            currentGroup.LockedAt = null;
            currentGroup.LockedBy = null;

            updateLockStatus();
            showToast('üîì ƒê√£ h·ªßy ch·ªët ph∆∞∆°ng √°n.', 'info');

            window.chrome.webview?.postMessage('UNLOCK_DESIGN|' + currentGroupIndex);
        }

        function updateLockStatus() {
            const lockBtn = document.getElementById('lockBtn');
            const lockStatus = document.getElementById('lockStatus');

            if (!lockBtn || !lockStatus) return;

            const isLocked = currentGroup?.SelectedDesign != null;

            if (isLocked) {
                lockBtn.innerHTML = '<i class="fa-solid fa-unlock"></i> H·ªßy ch·ªët';
                lockBtn.classList.remove('bg-amber-600', 'hover:bg-amber-500');
                lockBtn.classList.add('bg-slate-600', 'hover:bg-slate-500');
                lockBtn.onclick = unlockDesign;
                lockStatus.classList.remove('hidden');
            } else {
                lockBtn.innerHTML = '<i class="fa-solid fa-lock"></i> Ch·ªët';
                lockBtn.classList.add('bg-amber-600', 'hover:bg-amber-500');
                lockBtn.classList.remove('bg-slate-600', 'hover:bg-slate-500');
                lockBtn.onclick = lockDesign;
                lockStatus.classList.add('hidden');
            }
        }

        function updateGroupInfo() {
            const info = document.getElementById('groupInfo');
            if (!currentGroup) { info.textContent = '-'; return; }
            const totalL = currentGroup.TotalLength?.toFixed(2) || '-';
            const beamCount = currentGroup.EntityHandles?.length || 0;
            info.textContent = `T·ªïng: ${totalL}m | ${beamCount} d·∫ßm | ${currentGroup.Spans?.length || 0} nh·ªãp`;
        }

        function updateMetrics() {
            if (!currentGroup) return;
            const opt = currentGroup.BackboneOptions?.[currentGroup.SelectedBackboneIndex || 0];
            if (opt) {
                document.getElementById('metricBackbone').textContent = opt.OptionName || '-';
                document.getElementById('metricAs').textContent = `${opt.As_Backbone_Top?.toFixed(1) || 0} cm¬≤`;
                document.getElementById('metricWaste').textContent = `${opt.WastePercentage?.toFixed(1) || 0}%`;
                document.getElementById('metricWeight').textContent = `${opt.TotalSteelWeight?.toFixed(0) || 0} kg`;
                document.getElementById('metricScore').textContent = opt.EfficiencyScore?.toFixed(0) || '-';
            }

            // Warnings
            const warnings = [];
            if (currentGroup.HasStepChange) warnings.push({ icon: '‚ö†Ô∏è', text: 'Gi·∫≠t c·∫•p', cls: 'bg-amber-100 text-amber-700' });
            if (currentGroup.RequiresSplice) warnings.push({ icon: 'üîó', text: 'N·ªëi th√©p', cls: 'bg-blue-100 text-blue-700' });
            if (currentGroup.HasConsole) warnings.push({ icon: 'üìê', text: 'Console', cls: 'bg-purple-100 text-purple-700' });

            document.getElementById('warningsContainer').innerHTML = warnings
                .map(w => `<span class="px-2 py-0.5 rounded text-[10px] font-bold ${w.cls}">${w.icon} ${w.text}</span>`).join('');
        }

        // ============ CANVAS RENDERING (RELATIVE LENGTHS) ============
        function renderCanvas() {
            const canvas = document.getElementById('beamCanvas');
            const ctx = canvas.getContext('2d');

            if (!currentGroup?.Spans?.length) {
                canvas.width = 400;
                ctx.fillStyle = '#f8fafc';
                ctx.fillRect(0, 0, 400, 180);
                ctx.fillStyle = '#94a3b8';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Kh√¥ng c√≥ d·ªØ li·ªáu nh·ªãp', 200, 90);
                return;
            }

            spanBounds = [];
            const spans = currentGroup.Spans;

            // Calculate relative widths (use sqrt for better visual scaling)
            const lengths = spans.map(s => s.Length || 1);
            const maxLen = Math.max(...lengths);
            const minLen = Math.min(...lengths);

            // Scale: each span gets width proportional to its length, but with min/max limits
            const availableWidth = MAX_CANVAS_WIDTH - CANVAS_PADDING * 2 - spans.length * 10;
            const totalLen = lengths.reduce((a, b) => a + b, 0);

            let totalWidth = CANVAS_PADDING * 2;
            const spanWidths = lengths.map(len => {
                const ratio = len / totalLen;
                const w = Math.max(MIN_SPAN_WIDTH, ratio * availableWidth);
                totalWidth += w + 10; // +10 for support gap
                return w;
            });

            canvas.width = Math.min(totalWidth, MAX_CANVAS_WIDTH);
            const height = 180;

            // Clear with light background
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, canvas.width, height);

            let x = CANVAS_PADDING;
            const beamY = 60;

            // Draw beams
            spans.forEach((span, i) => {
                const w = spanWidths[i];

                // Support symbol
                if (i === 0) {
                    drawSupport(ctx, x, beamY);
                    x += 5;
                }

                // Store bounds
                spanBounds.push({ x, y: beamY, width: w, height: BEAM_HEIGHT, index: i });

                // Draw beam segment
                const isHighlighted = i === highlightedSpanIndex;
                ctx.fillStyle = isHighlighted ? '#dbeafe' : '#e2e8f0';
                ctx.strokeStyle = isHighlighted ? '#3b82f6' : '#64748b';
                ctx.lineWidth = isHighlighted ? 2 : 1;
                ctx.fillRect(x, beamY, w, BEAM_HEIGHT);
                ctx.strokeRect(x, beamY, w, BEAM_HEIGHT);

                // Draw rebar lines
                drawRebarLines(ctx, x, beamY, w, span);

                // Span label
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(span.SpanId, x + w / 2, beamY + BEAM_HEIGHT / 2 + 4);

                // Dimension
                ctx.fillStyle = '#64748b';
                ctx.font = '10px sans-serif';
                ctx.fillText(`${(span.Length || 0).toFixed(2)}m`, x + w / 2, beamY + BEAM_HEIGHT + 12);
                ctx.fillText(`${span.Width || 0}√ó${span.Height || 0}`, x + w / 2, beamY - 5);

                x += w;

                // Support between spans
                drawSupport(ctx, x, beamY);
                x += 10;
            });

            // Scroll to highlighted span
            if (highlightedSpanIndex >= 0 && spanBounds[highlightedSpanIndex]) {
                const bound = spanBounds[highlightedSpanIndex];
                const container = document.getElementById('canvasContainer');
                const scrollTarget = bound.x - container.clientWidth / 2 + bound.width / 2;
                container.scrollTo({ left: scrollTarget, behavior: 'smooth' });
            }
        }

        function drawSupport(ctx, x, y) {
            ctx.fillStyle = '#475569';
            ctx.beginPath();
            ctx.moveTo(x, y + BEAM_HEIGHT);
            ctx.lineTo(x - 6, y + BEAM_HEIGHT + 15);
            ctx.lineTo(x + 6, y + BEAM_HEIGHT + 15);
            ctx.closePath();
            ctx.fill();
        }

        function drawRebarLines(ctx, x, y, w, span) {
            const topY = y + 8;
            const botY = y + BEAM_HEIGHT - 8;

            // Draw backbone (continuous red line)
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);

            // Top backbone
            ctx.beginPath();
            ctx.moveTo(x + 3, topY);
            ctx.lineTo(x + w - 3, topY);
            ctx.stroke();

            // Bottom backbone
            ctx.strokeStyle = '#3b82f6';
            ctx.beginPath();
            ctx.moveTo(x + 3, botY);
            ctx.lineTo(x + w - 3, botY);
            ctx.stroke();

            // Draw addon bars (dashed) if different from backbone
            const topRebar = span.TopRebar?.[0];
            const botRebar = span.BotRebar?.[0];

            ctx.setLineDash([4, 2]);
            ctx.lineWidth = 1.5;

            if (topRebar?.[0]) {
                ctx.strokeStyle = '#f97316';
                ctx.beginPath();
                ctx.moveTo(x + 3, topY + 4);
                ctx.lineTo(x + w * 0.3, topY + 4);
                ctx.stroke();
            }
            if (topRebar?.[2]) {
                ctx.strokeStyle = '#f97316';
                ctx.beginPath();
                ctx.moveTo(x + w * 0.7, topY + 4);
                ctx.lineTo(x + w - 3, topY + 4);
                ctx.stroke();
            }

            ctx.setLineDash([]);
        }

        // ============ TABLE RENDERING ============
        function renderTable() {
            const tbody = document.getElementById('spanTableBody');
            tbody.innerHTML = '';

            if (!currentGroup?.Spans) return;

            currentGroup.Spans.forEach((span, i) => {
                const tr = document.createElement('tr');
                tr.className = `span-row border-b border-slate-100 ${span.IsActive === false ? 'opacity-40' : ''} ${i === highlightedSpanIndex ? 'highlighted' : ''}`;
                tr.dataset.spanIndex = i;

                // Mouse events for sync
                tr.addEventListener('mouseenter', () => highlightSpan(i));
                tr.addEventListener('mouseleave', clearHighlight);

                tr.innerHTML = `
                    <td class="p-2 font-medium">${span.SpanId}</td>
                    <td class="p-2 text-center">
                        <input type="checkbox" ${span.IsActive !== false ? 'checked' : ''} 
                            onchange="toggleSpanActive(${i}, this.checked)" class="w-3.5 h-3.5">
                    </td>
                    <td class="p-2 text-center text-slate-600">${(span.Length || 0).toFixed(2)}</td>
                    <td class="p-2 text-center text-slate-600">${span.Width || 0}√ó${span.Height || 0}</td>
                    ${renderRebarInputs(i, span, 'Top', 3)}
                    ${renderRebarInputs(i, span, 'Bot', 3)}
                    ${renderStirrupInputs(i, span)}
                    <td class="p-2">
                        <input type="text" value="${span.SideBar || ''}" 
                            onchange="updateSideBar(${i}, this.value)"
                            class="w-full border border-slate-200 rounded px-1 py-0.5 text-center text-xs">
                    </td>
                `;

                tbody.appendChild(tr);
            });
        }

        function renderRebarInputs(spanIndex, span, type, count) {
            const arr = type === 'Top' ? span.TopRebar?.[0] : span.BotRebar?.[0];
            const bgClass = type === 'Top' ? 'bg-red-50' : 'bg-blue-50';
            let html = '';
            const positions = [0, 2, 4]; // Left, Mid, Right

            positions.slice(0, count).forEach((p, idx) => {
                const val = arr?.[p] || '';
                html += `<td class="p-1 ${bgClass}">
                    <input type="text" value="${val}" 
                        onchange="updateRebar(${spanIndex}, '${type}', ${p}, this.value)"
                        class="w-full border border-slate-200 rounded px-1 py-0.5 text-center text-xs bg-white">
                </td>`;
            });
            return html;
        }

        function renderStirrupInputs(spanIndex, span) {
            let html = '';
            for (let p = 0; p < 3; p++) {
                const val = span.Stirrup?.[p] || '';
                html += `<td class="p-1">
                    <input type="text" value="${val}" 
                        onchange="updateStirrup(${spanIndex}, ${p}, this.value)"
                        class="w-full border border-slate-200 rounded px-1 py-0.5 text-center text-xs">
                </td>`;
            }
            return html;
        }

        // ============ DATA UPDATE FUNCTIONS ============
        function toggleSpanActive(index, active) {
            currentGroup.Spans[index].IsActive = active;
            renderTable();
        }

        function updateRebar(spanIndex, type, pos, value) {
            const span = currentGroup.Spans[spanIndex];
            const arr = type === 'Top' ? 'TopRebar' : 'BotRebar';
            if (!span[arr]) span[arr] = [[], [], []];
            if (!span[arr][0]) span[arr][0] = [];
            span[arr][0][pos] = value;

            // Auto apply
            if (document.getElementById('autoApply').checked) {
                for (let i = spanIndex + 1; i < currentGroup.Spans.length; i++) {
                    if (currentGroup.Spans[i].IsActive !== false) {
                        if (!currentGroup.Spans[i][arr]) currentGroup.Spans[i][arr] = [[], [], []];
                        if (!currentGroup.Spans[i][arr][0]) currentGroup.Spans[i][arr][0] = [];
                        currentGroup.Spans[i][arr][0][pos] = value;
                    }
                }
                renderTable();
            }
            renderCanvas();
        }

        function updateStirrup(spanIndex, pos, value) {
            const span = currentGroup.Spans[spanIndex];
            if (!span.Stirrup) span.Stirrup = [];
            span.Stirrup[pos] = value;
        }

        function updateSideBar(spanIndex, value) {
            currentGroup.Spans[spanIndex].SideBar = value;
        }

        function selectAllSpans() {
            currentGroup.Spans.forEach(s => s.IsActive = true);
            renderTable();
        }

        function selectNoneSpans() {
            currentGroup.Spans.forEach(s => s.IsActive = false);
            renderTable();
        }

        function applyStirrupPattern() {
            const pattern = document.getElementById('stirrupPattern').value;
            const parts = pattern.replace(/[a-zA-Z]/g, '').split('/');
            const dia = pattern.match(/d(\d+)/)?.[1] || '8';

            currentGroup.Spans.forEach(span => {
                if (span.IsActive !== false) {
                    span.Stirrup = [
                        `d${dia}a${parts[0] || 100}`,
                        `d${dia}a${parts[1] || 150}`,
                        `d${dia}a${parts[2] || 100}`
                    ];
                }
            });
            renderTable();
            showToast('‚úì ƒê√£ apply stirrup pattern');
        }

        // ============ HIGHLIGHT & SYNC ============
        function highlightSpan(index) {
            highlightedSpanIndex = index;
            document.querySelectorAll('.span-row').forEach((tr, i) => {
                tr.classList.toggle('highlighted', i === index);
            });
            renderCanvas();

            // AUTO HIGHLIGHT IN CAD: send handles to C#
            const span = currentGroup?.Spans?.[index];
            if (span?.Segments?.length > 0) {
                const handles = span.Segments.map(s => s.EntityHandle).filter(h => h);
                if (handles.length > 0) {
                    window.chrome.webview.postMessage('HIGHLIGHT|' + JSON.stringify(handles));
                }
            }
        }

        function clearHighlight() {
            highlightedSpanIndex = -1;
            document.querySelectorAll('.span-row').forEach(tr => tr.classList.remove('highlighted'));
            renderCanvas();
        }

        // ============ MATERIAL GRADE SELECTION ============
        function setGroupConcrete(grade) {
            if (currentGroup) {
                currentGroup.ConcreteGrade = grade;
                showToast(`‚úì ƒê√£ ch·ªçn b√™ t√¥ng ${grade}`);
            }
        }

        function setGroupSteel(grade) {
            if (currentGroup) {
                currentGroup.SteelGrade = grade;
                showToast(`‚úì ƒê√£ ch·ªçn th√©p ${grade}`);
            }
        }

        function loadMaterialSelects() {
            const concreteSelect = document.getElementById('concreteGradeSelect');
            const steelSelect = document.getElementById('steelGradeSelect');

            if (currentGroup?.ConcreteGrade) {
                concreteSelect.value = currentGroup.ConcreteGrade;
            }
            if (currentGroup?.SteelGrade) {
                steelSelect.value = currentGroup.SteelGrade;
            }
        }

        // ============ CAD INTEGRATION ============
        function highlightInCAD() {
            if (!currentGroup?.EntityHandles?.length) {
                showToast('‚ö†Ô∏è Kh√¥ng c√≥ d·∫ßm ƒë·ªÉ highlight');
                return;
            }
            // Send message to C# to highlight beams
            window.chrome.webview.postMessage('HIGHLIGHT|' + JSON.stringify(currentGroup.EntityHandles));
            showToast('‚úì ƒê√£ highlight ' + currentGroup.EntityHandles.length + ' d·∫ßm tr√™n CAD');
        }

        // ============ COPY FORMAT ============
        let copyFormatMode = false;
        let copySourceSpan = null;

        function copyFormat() {
            copyFormatMode = true;
            copySourceSpan = null;
            document.body.style.cursor = 'crosshair';
            showToast('Click nh·ªãp ngu·ªìn ƒë·ªÉ copy format...');
        }

        // ============ ACTIONS ============
        function doSave() { window.chrome.webview.postMessage('SAVE|' + JSON.stringify(data)); }
        function doExport() { window.chrome.webview.postMessage('EXPORT'); }
        function doImport() { window.chrome.webview.postMessage('IMPORT'); }
        function doCancel() { window.chrome.webview.postMessage('CANCEL'); }
        function applyToDrawing() { window.chrome.webview.postMessage('APPLY|' + JSON.stringify(data)); }

        // ============ TOAST ============
        function showToast(msg) {
            const existing = document.querySelector('.toast');
            if (existing) existing.remove();

            const toast = document.createElement('div');
            toast.className = 'toast fixed bottom-16 left-1/2 -translate-x-1/2 bg-slate-900 text-white px-4 py-2 rounded shadow-lg text-sm z-50';
            toast.textContent = msg;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // ============ CANVAS EVENTS ============
        document.getElementById('beamCanvas').addEventListener('click', function (e) {
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            for (const bound of spanBounds) {
                if (x >= bound.x && x <= bound.x + bound.width && y >= bound.y && y <= bound.y + bound.height) {
                    if (copyFormatMode) {
                        if (!copySourceSpan) {
                            copySourceSpan = currentGroup.Spans[bound.index];
                            showToast('Ch·ªçn nh·ªãp ƒë√≠ch...');
                        } else {
                            const dest = currentGroup.Spans[bound.index];
                            dest.TopRebar = JSON.parse(JSON.stringify(copySourceSpan.TopRebar || []));
                            dest.BotRebar = JSON.parse(JSON.stringify(copySourceSpan.BotRebar || []));
                            dest.Stirrup = [...(copySourceSpan.Stirrup || [])];
                            copyFormatMode = false;
                            document.body.style.cursor = 'default';
                            renderTable();
                            showToast('‚úì Copied format to ' + dest.SpanId);
                        }
                    } else {
                        // Scroll table to row
                        const row = document.querySelector(`tr[data-span-index="${bound.index}"]`);
                        if (row) {
                            row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            highlightSpan(bound.index);
                        }
                    }
                    break;
                }
            }
        });

        // Init
        init();
    </script>
</body>

</html>