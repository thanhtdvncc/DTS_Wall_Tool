<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <title>DTS Beam Group Viewer</title>
    <style>
        :root {
            --bg: #1a1a2e;
            --surface: #16213e;
            --card: #1f2940;
            --primary: #0f3460;
            --accent: #e94560;
            --text: #f1f1f1;
            --muted: #8892a0;
            --success: #4ade80;
            --warning: #fbbf24;
            --danger: #ef4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        header {
            background: var(--surface);
            padding: 12px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .header-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--accent);
        }

        .nav-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-btn {
            background: var(--primary);
            border: none;
            color: var(--text);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .nav-btn:hover {
            background: var(--accent);
        }

        select {
            background: var(--card);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            min-width: 180px;
        }

        .tools-group {
            margin-left: auto;
            display: flex;
            gap: 8px;
        }

        .tool-btn {
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .tool-btn:hover {
            background: var(--accent);
            color: white;
        }

        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .canvas-container {
            flex: 0 0 280px;
            background: var(--surface);
            overflow-x: auto;
            overflow-y: hidden;
            position: relative;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        #beamCanvas {
            display: block;
            min-width: 100%;
        }

        .metrics-bar {
            background: var(--card);
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 30px;
            font-size: 13px;
            flex-wrap: wrap;
        }

        .metric {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .metric-label {
            color: var(--muted);
        }

        .metric-value {
            font-weight: 600;
        }

        .metric-value.good {
            color: var(--success);
        }

        .metric-value.warn {
            color: var(--warning);
        }

        .warning-tag {
            background: var(--warning);
            color: #000;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
        }

        .input-section {
            flex: 1;
            overflow-y: auto;
            padding: 15px 20px;
        }

        .input-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .input-header label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 13px;
        }

        .span-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .span-table th {
            background: var(--primary);
            padding: 8px 6px;
            text-align: center;
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .span-table td {
            padding: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .span-table input[type="text"] {
            width: 60px;
            background: var(--card);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text);
            padding: 4px 6px;
            border-radius: 3px;
            text-align: center;
            font-size: 11px;
        }

        .span-table input[type="text"]:focus {
            border-color: var(--accent);
            outline: none;
        }

        .span-table .inactive {
            opacity: 0.4;
        }

        .span-table .section-label {
            background: var(--primary);
            font-weight: 600;
            text-align: left;
            padding-left: 10px;
        }

        footer {
            background: var(--surface);
            padding: 12px 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .footer-left,
        .footer-right {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
        }

        .btn-secondary {
            background: var(--card);
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn:hover {
            opacity: 0.9;
        }

        .stirrup-row {
            margin-top: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .stirrup-row input {
            width: 140px;
            background: var(--card);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 4px;
        }

        /* Highlight states for bidirectional sync */
        .span-table tr.highlighted {
            background: rgba(233, 69, 96, 0.3) !important;
        }

        .span-table tr:hover {
            background: rgba(233, 69, 96, 0.15);
        }

        /* Quick Picker Popup */
        .quick-picker {
            position: fixed;
            background: var(--card);
            border: 1px solid var(--accent);
            border-radius: 6px;
            padding: 8px;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .quick-picker.show {
            display: block;
        }

        .quick-picker-title {
            font-size: 11px;
            color: var(--muted);
            margin-bottom: 5px;
        }

        .quick-picker-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
        }

        .quick-picker-btn {
            background: var(--primary);
            border: none;
            color: var(--text);
            padding: 6px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        .quick-picker-btn:hover {
            background: var(--accent);
        }

        /* Bulk Edit Mode */
        .bulk-mode .span-table tr.selected {
            background: rgba(74, 222, 128, 0.2);
        }
    </style>
</head>

<body>
    <header>
        <span class="header-title">DTS Beam Group Viewer</span>

        <div class="nav-group">
            <button class="nav-btn" onclick="prevGroup()">‚óÄ</button>
            <select id="groupSelect" onchange="loadGroup(this.value)"></select>
            <button class="nav-btn" onclick="nextGroup()">‚ñ∂</button>
        </div>

        <div class="nav-group">
            <label>Ph∆∞∆°ng √°n:</label>
            <select id="optionSelect" onchange="selectOption(this.value)"></select>
        </div>

        <div class="tools-group">
            <button class="tool-btn" onclick="copyFormat()">üñå Copy Format</button>
            <button class="tool-btn" onclick="bulkEdit()">Bulk Edit</button>
        </div>
    </header>

    <main>
        <div class="canvas-container">
            <canvas id="beamCanvas" height="260"></canvas>
        </div>

        <div class="metrics-bar">
            <div class="metric">
                <span class="metric-label">Backbone:</span>
                <span class="metric-value" id="metricBackbone">2D22</span>
            </div>
            <div class="metric">
                <span class="metric-label">As:</span>
                <span class="metric-value" id="metricAs">7.6 cm¬≤</span>
            </div>
            <div class="metric">
                <span class="metric-label">Waste:</span>
                <span class="metric-value" id="metricWaste">8.5%</span>
            </div>
            <div class="metric">
                <span class="metric-label">Weight:</span>
                <span class="metric-value" id="metricWeight">245 kg</span>
            </div>
            <div class="metric">
                <span class="metric-label">Score:</span>
                <span class="metric-value good" id="metricScore">92</span>
            </div>
            <div id="warningsContainer"></div>
        </div>

        <div class="input-section">
            <div class="input-header">
                <label><input type="checkbox" id="autoApply" checked> Auto Apply (ƒë·ªìng b·ªô th√©p su·ªët)</label>
                <button class="tool-btn" onclick="selectAllSpans()">Select All</button>
                <button class="tool-btn" onclick="selectNoneSpans()">Select None</button>
            </div>

            <table class="span-table" id="spanTable">
                <thead>
                    <tr>
                        <th rowspan="2">Nh·ªãp</th>
                        <th rowspan="2">Active</th>
                        <th colspan="5">TH√âP TR√äN (Top)</th>
                        <th colspan="5">TH√âP D∆Ø·ªöI (Bot)</th>
                        <th colspan="3">Stirrup</th>
                        <th rowspan="2">Side</th>
                    </tr>
                    <tr>
                        <th>G·ªëiT</th>
                        <th>L/4T</th>
                        <th>Gi·ªØa</th>
                        <th>L/4P</th>
                        <th>G·ªëiP</th>
                        <th>G·ªëiT</th>
                        <th>L/4T</th>
                        <th>Gi·ªØa</th>
                        <th>L/4P</th>
                        <th>G·ªëiP</th>
                        <th>ƒê·∫ßu</th>
                        <th>Gi·ªØa</th>
                        <th>Cu·ªëi</th>
                    </tr>
                </thead>
                <tbody id="spanTableBody">
                </tbody>
            </table>

            <div class="stirrup-row">
                <label>Stirrup pattern:</label>
                <input type="text" id="stirrupPattern" value="a100/150/100" placeholder="a100/150/100">
                <button class="tool-btn" onclick="applyStirrupPattern()">Apply to Active</button>
            </div>
        </div>
    </main>

    <footer>
        <div class="footer-left">
            <button class="btn btn-secondary" onclick="doSave()">Save</button>
            <button class="btn btn-secondary" onclick="doExport()">Export</button>
            <button class="btn btn-secondary" onclick="doImport()">Import</button>
        </div>
        <div class="footer-right">
            <button class="btn btn-secondary" onclick="doCancel()">Cancel</button>
            <button class="btn btn-primary" onclick="applyToDrawing()">Apply to Drawing</button>
        </div>
    </footer>

    <!-- Quick Picker Popups -->
    <div class="quick-picker" id="diameterPicker">
        <div class="quick-picker-title">ƒê∆∞·ªùng k√≠nh th√©p ch·ªß:</div>
        <div class="quick-picker-grid">
            <button class="quick-picker-btn" onclick="pickDiameter('2D14')">2D14</button>
            <button class="quick-picker-btn" onclick="pickDiameter('2D16')">2D16</button>
            <button class="quick-picker-btn" onclick="pickDiameter('2D18')">2D18</button>
            <button class="quick-picker-btn" onclick="pickDiameter('2D20')">2D20</button>
            <button class="quick-picker-btn" onclick="pickDiameter('2D22')">2D22</button>
            <button class="quick-picker-btn" onclick="pickDiameter('2D25')">2D25</button>
            <button class="quick-picker-btn" onclick="pickDiameter('3D20')">3D20</button>
            <button class="quick-picker-btn" onclick="pickDiameter('3D22')">3D22</button>
        </div>
    </div>

    <div class="quick-picker" id="stirrupPicker">
        <div class="quick-picker-title">B∆∞·ªõc ƒëai:</div>
        <div class="quick-picker-grid">
            <button class="quick-picker-btn" onclick="pickStirrup('d8a100')">d8a100</button>
            <button class="quick-picker-btn" onclick="pickStirrup('d8a150')">d8a150</button>
            <button class="quick-picker-btn" onclick="pickStirrup('d8a200')">d8a200</button>
            <button class="quick-picker-btn" onclick="pickStirrup('d10a100')">d10a100</button>
            <button class="quick-picker-btn" onclick="pickStirrup('d10a150')">d10a150</button>
            <button class="quick-picker-btn" onclick="pickStirrup('d10a200')">d10a200</button>
        </div>
    </div>

    <script>
        // Data from C#
        const data = __DATA_JSON__;
        let currentGroupIndex = 0;
        let currentGroup = null;

        const MIN_SPAN_WIDTH = 250;
        const PIXELS_PER_METER = 80;
        const CANVAS_PADDING = 40;
        const BEAM_HEIGHT = 80;
        const SUPPORT_HEIGHT = 120;

        function init() {
            populateGroupSelect();
            if (data.groups && data.groups.length > 0) {
                loadGroup(0);
            }
        }

        function populateGroupSelect() {
            const sel = document.getElementById('groupSelect');
            sel.innerHTML = '';
            if (!data.groups) return;
            data.groups.forEach((g, i) => {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = g.GroupName || `Group ${i + 1}`;
                sel.appendChild(opt);
            });
        }

        function loadGroup(index) {
            currentGroupIndex = parseInt(index);
            currentGroup = data.groups[currentGroupIndex];
            document.getElementById('groupSelect').value = currentGroupIndex;

            populateOptionSelect();
            renderCanvas();
            renderTable();
            updateMetrics();
        }

        function prevGroup() {
            if (currentGroupIndex > 0) loadGroup(currentGroupIndex - 1);
        }

        function nextGroup() {
            if (currentGroupIndex < data.groups.length - 1) loadGroup(currentGroupIndex + 1);
        }

        function populateOptionSelect() {
            const sel = document.getElementById('optionSelect');
            sel.innerHTML = '';
            if (!currentGroup.BackboneOptions) return;
            currentGroup.BackboneOptions.forEach((opt, i) => {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `${opt.OptionName} - ${opt.Description}${i === 0 ? ' (Best)' : ''}`;
                sel.appendChild(option);
            });
            sel.value = currentGroup.SelectedBackboneIndex || 0;
        }

        function selectOption(index) {
            currentGroup.SelectedBackboneIndex = parseInt(index);
            updateMetrics();
        }

        function renderCanvas() {
            const canvas = document.getElementById('beamCanvas');
            const ctx = canvas.getContext('2d');

            if (!currentGroup || !currentGroup.Spans) return;

            // Calculate total width
            let totalWidth = CANVAS_PADDING * 2;
            currentGroup.Spans.forEach(span => {
                totalWidth += Math.max(span.Length * PIXELS_PER_METER, MIN_SPAN_WIDTH);
            });
            totalWidth += currentGroup.Supports ? currentGroup.Supports.length * 30 : 0;

            canvas.width = Math.max(totalWidth, 800);
            const height = canvas.height;

            // Clear
            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, canvas.width, height);

            let x = CANVAS_PADDING;
            const beamY = 80;

            // Draw supports and spans
            currentGroup.Spans.forEach((span, i) => {
                const spanWidth = Math.max(span.Length * PIXELS_PER_METER, MIN_SPAN_WIDTH);

                // Left support
                if (i === 0 && currentGroup.Supports && currentGroup.Supports[0]) {
                    drawSupport(ctx, x, beamY, currentGroup.Supports[0]);
                    x += 15;
                }

                // Beam span
                drawSpan(ctx, x, beamY, spanWidth, span);
                x += spanWidth;

                // Right support
                if (currentGroup.Supports && currentGroup.Supports[i + 1]) {
                    drawSupport(ctx, x, beamY, currentGroup.Supports[i + 1]);
                    x += 15;
                }
            });

            // Dimension line
            drawDimensions(ctx, beamY + BEAM_HEIGHT + 40);
        }

        function drawSupport(ctx, x, y, support) {
            const w = 20;
            const h = SUPPORT_HEIGHT;

            ctx.fillStyle = support.Type === 3 ? '#444' : '#0f3460'; // FreeEnd darker
            ctx.fillRect(x - w / 2, y - 20, w, h);

            ctx.fillStyle = '#fff';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(support.GridName || support.SupportId, x, y + h - 30);
        }

        function drawSpan(ctx, x, y, width, span) {
            // Beam rect
            ctx.fillStyle = '#1f4068';
            ctx.strokeStyle = '#e94560';
            ctx.lineWidth = 2;
            ctx.fillRect(x, y, width, BEAM_HEIGHT);
            ctx.strokeRect(x, y, width, BEAM_HEIGHT);

            // Span label
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(span.SpanId, x + width / 2, y + 20);

            // Dimensions text
            ctx.fillStyle = '#8892a0';
            ctx.font = '11px sans-serif';
            ctx.fillText(`${span.Width}x${span.Height}`, x + width / 2, y + 35);
            ctx.fillText(`L=${span.Length.toFixed(2)}m`, x + width / 2, y + 50);

            // Step change indicator
            if (span.IsStepChange) {
                ctx.fillStyle = '#fbbf24';
                ctx.fillText('‚ö†Ô∏è', x + width - 15, y + 15);
            }
        }

        function drawDimensions(ctx, y) {
            if (!currentGroup.Spans) return;

            let x = CANVAS_PADDING;
            ctx.strokeStyle = '#555';
            ctx.fillStyle = '#aaa';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';

            currentGroup.Spans.forEach(span => {
                const w = Math.max(span.Length * PIXELS_PER_METER, MIN_SPAN_WIDTH);

                // Dimension line
                ctx.beginPath();
                ctx.moveTo(x + 15, y);
                ctx.lineTo(x + w - 15, y);
                ctx.stroke();

                // Arrows
                ctx.beginPath();
                ctx.moveTo(x + 15, y);
                ctx.lineTo(x + 20, y - 3);
                ctx.lineTo(x + 20, y + 3);
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(x + w - 15, y);
                ctx.lineTo(x + w - 20, y - 3);
                ctx.lineTo(x + w - 20, y + 3);
                ctx.fill();

                // Text
                ctx.fillText(`${span.Length.toFixed(2)}m`, x + w / 2, y - 5);

                x += w + 30;
            });
        }

        /// <summary>
        /// V·∫Ω ƒëi·ªÉm ƒë√°nh d·∫•u m·ªëi n·ªëi th√©p - ellipse nghi√™ng 45¬∞
        /// </summary>
        function drawSpliceMarker(ctx, x, y, color) {
            ctx.save();

            // Di chuy·ªÉn ƒë·∫øn v·ªã tr√≠ marker
            ctx.translate(x, y);

            // Xoay 45 ƒë·ªô (PI/4 radians)
            ctx.rotate(Math.PI / 4);

            // V·∫Ω ellipse
            ctx.beginPath();
            ctx.ellipse(0, 0, 8, 4, 0, 0, Math.PI * 2);

            // Style: n√©t m·∫£nh, kh√¥ng fill
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Optional: v·∫Ω ƒë∆∞·ªùng ch√©o nh·ªè trong ellipse
            ctx.beginPath();
            ctx.moveTo(-4, 0);
            ctx.lineTo(4, 0);
            ctx.stroke();

            ctx.restore();
        }

        function renderTable() {
            const tbody = document.getElementById('spanTableBody');
            tbody.innerHTML = '';

            if (!currentGroup || !currentGroup.Spans) return;

            currentGroup.Spans.forEach((span, i) => {
                const tr = document.createElement('tr');
                tr.className = span.IsActive === false ? 'inactive' : '';
                tr.dataset.spanIndex = i;

                // Span ID
                tr.innerHTML = `<td>${span.SpanId}</td>`;

                // Active checkbox
                tr.innerHTML += `<td><input type="checkbox" ${span.IsActive !== false ? 'checked' : ''} 
                    onchange="toggleSpanActive(${i}, this.checked)"></td>`;

                // Top rebar (5 positions)
                for (let p = 0; p < 5; p++) {
                    const val = span.TopRebar && span.TopRebar[0] ? span.TopRebar[0][p] || '' : '';
                    tr.innerHTML += `<td><input type="text" value="${val}" 
                        onchange="updateRebar(${i}, 'Top', ${p}, this.value)"></td>`;
                }

                // Bot rebar (5 positions)
                for (let p = 0; p < 5; p++) {
                    const val = span.BotRebar && span.BotRebar[0] ? span.BotRebar[0][p] || '' : '';
                    tr.innerHTML += `<td><input type="text" value="${val}" 
                        onchange="updateRebar(${i}, 'Bot', ${p}, this.value)"></td>`;
                }

                // Stirrup (3 positions)
                for (let p = 0; p < 3; p++) {
                    const val = span.Stirrup ? span.Stirrup[p] || '' : '';
                    tr.innerHTML += `<td><input type="text" value="${val}" 
                        onchange="updateStirrup(${i}, ${p}, this.value)"></td>`;
                }

                // Side bar
                tr.innerHTML += `<td><input type="text" value="${span.SideBar || ''}" 
                    onchange="updateSideBar(${i}, this.value)"></td>`;

                tbody.appendChild(tr);
            });
        }

        function updateMetrics() {
            if (!currentGroup) return;

            const opt = currentGroup.BackboneOptions?.[currentGroup.SelectedBackboneIndex || 0];
            if (opt) {
                document.getElementById('metricBackbone').textContent = opt.OptionName;
                document.getElementById('metricAs').textContent = `${opt.As_Backbone_Top?.toFixed(1) || 0} cm¬≤`;
                document.getElementById('metricWaste').textContent = `${opt.WastePercentage?.toFixed(1) || 0}%`;
                document.getElementById('metricWeight').textContent = `${opt.TotalSteelWeight?.toFixed(0) || 0} kg`;
                document.getElementById('metricScore').textContent = opt.EfficiencyScore?.toFixed(0) || '-';
            }

            // Warnings
            const warnings = [];
            if (currentGroup.HasStepChange) warnings.push('Gi·∫≠t c·∫•p');
            if (currentGroup.RequiresSplice) warnings.push('C·∫ßn n·ªëi th√©p');
            if (currentGroup.HasConsole) warnings.push('C√≥ ƒë·∫ßu th·ª´a');

            document.getElementById('warningsContainer').innerHTML = warnings
                .map(w => `<span class="warning-tag">‚ö†Ô∏è ${w}</span>`).join(' ');
        }

        function toggleSpanActive(index, active) {
            currentGroup.Spans[index].IsActive = active;
            renderTable();
        }

        function updateRebar(spanIndex, type, pos, value) {
            const span = currentGroup.Spans[spanIndex];
            const arr = type === 'Top' ? 'TopRebar' : 'BotRebar';
            if (!span[arr]) span[arr] = [[], [], []];
            if (!span[arr][0]) span[arr][0] = [];
            span[arr][0][pos] = value;

            // Auto apply
            if (document.getElementById('autoApply').checked && pos < 5) {
                for (let i = spanIndex + 1; i < currentGroup.Spans.length; i++) {
                    if (currentGroup.Spans[i].IsActive !== false) {
                        if (!currentGroup.Spans[i][arr]) currentGroup.Spans[i][arr] = [[], [], []];
                        if (!currentGroup.Spans[i][arr][0]) currentGroup.Spans[i][arr][0] = [];
                        currentGroup.Spans[i][arr][0][pos] = value;
                    }
                }
                renderTable();
            }
        }

        function updateStirrup(spanIndex, pos, value) {
            const span = currentGroup.Spans[spanIndex];
            if (!span.Stirrup) span.Stirrup = [];
            span.Stirrup[pos] = value;
        }

        function updateSideBar(spanIndex, value) {
            currentGroup.Spans[spanIndex].SideBar = value;
        }

        function selectAllSpans() {
            currentGroup.Spans.forEach(s => s.IsActive = true);
            renderTable();
        }

        function selectNoneSpans() {
            currentGroup.Spans.forEach(s => s.IsActive = false);
            renderTable();
        }

        function applyStirrupPattern() {
            const pattern = document.getElementById('stirrupPattern').value;
            const parts = pattern.replace('a', '').split('/');

            currentGroup.Spans.forEach(span => {
                if (span.IsActive !== false) {
                    span.Stirrup = [
                        `d8a${parts[0] || 100}`,
                        `d8a${parts[1] || 150}`,
                        `d8a${parts[2] || 100}`
                    ];
                }
            });
            renderTable();
        }

        function copyFormat() {
            alert('Click nh·ªãp ngu·ªìn, sau ƒë√≥ click nh·ªãp ƒë√≠ch ƒë·ªÉ copy format');
        }

        function bulkEdit() {
            alert('Ch·ªçn nhi·ªÅu nh·ªãp (Ctrl+Click trong b·∫£ng), sau ƒë√≥ s·ª≠a 1 √¥ ƒë·ªÉ ƒë·ªìng b·ªô');
        }

        function doSave() {
            window.chrome.webview.postMessage('SAVE|' + JSON.stringify(data));
        }

        function doExport() {
            window.chrome.webview.postMessage('EXPORT');
        }

        function doImport() {
            window.chrome.webview.postMessage('IMPORT');
        }

        function doCancel() {
            window.chrome.webview.postMessage('CANCEL');
        }

        function applyToDrawing() {
            window.chrome.webview.postMessage('APPLY|' + JSON.stringify(data));
        }

        // ============ ENHANCED: Copy Format Mode ============
        let copyFormatMode = false;
        let copySourceSpan = null;

        function copyFormat() {
            copyFormatMode = true;
            copySourceSpan = null;
            document.body.style.cursor = 'crosshair';
            showToast('Click nh·ªãp ngu·ªìn ƒë·ªÉ copy format...');
        }

        function handleCopyFormatClick(spanIndex) {
            if (copySourceSpan === null) {
                copySourceSpan = currentGroup.Spans[spanIndex];
                showToast('Ch·ªçn nh·ªãp ngu·ªìn: ' + copySourceSpan.SpanId + '. Click nh·ªãp ƒë√≠ch...');
            } else {
                // Copy format to destination
                const dest = currentGroup.Spans[spanIndex];
                dest.TopRebar = JSON.parse(JSON.stringify(copySourceSpan.TopRebar || []));
                dest.BotRebar = JSON.parse(JSON.stringify(copySourceSpan.BotRebar || []));
                dest.Stirrup = [...(copySourceSpan.Stirrup || [])];
                dest.SideBar = copySourceSpan.SideBar;

                copyFormatMode = false;
                copySourceSpan = null;
                document.body.style.cursor = 'default';
                renderTable();
                showToast('\u2705 ƒê√£ copy format sang ' + dest.SpanId);
            }
        }

        // ============ ENHANCED: Bulk Edit Mode ============
        let bulkEditMode = false;
        let selectedSpanIndices = [];

        function bulkEdit() {
            bulkEditMode = !bulkEditMode;
            selectedSpanIndices = [];
            document.body.classList.toggle('bulk-mode', bulkEditMode);

            if (bulkEditMode) {
                showToast('Bulk Edit ON: Ctrl+Click ch·ªçn nhi·ªÅu nh·ªãp, s·ª≠a 1 √¥ ƒë·ªÉ ƒë·ªìng b·ªô');
            } else {
                showToast('Bulk Edit OFF');
            }
            renderTable();
        }

        function toggleSpanSelection(index, event) {
            if (!bulkEditMode) return;

            if (event.ctrlKey || event.metaKey) {
                const idx = selectedSpanIndices.indexOf(index);
                if (idx >= 0) {
                    selectedSpanIndices.splice(idx, 1);
                } else {
                    selectedSpanIndices.push(index);
                }
                renderTable();
            }
        }

        // ============ ENHANCED: Bidirectional Sync (Table <-> Canvas) ============
        let highlightedSpanIndex = -1;
        let spanBounds = []; // Store span bounds for canvas click detection

        function highlightSpan(index) {
            highlightedSpanIndex = index;

            // Highlight table row
            document.querySelectorAll('#spanTableBody tr').forEach((tr, i) => {
                tr.classList.toggle('highlighted', i === index);
            });

            // Redraw canvas with highlight
            renderCanvas();
        }

        function clearHighlight() {
            highlightedSpanIndex = -1;
            document.querySelectorAll('#spanTableBody tr').forEach(tr => {
                tr.classList.remove('highlighted');
            });
            renderCanvas();
        }

        // ============ ENHANCED: Quick Picker ============
        let activeInput = null;
        let activeInputType = null; // 'diameter' or 'stirrup'

        function showQuickPicker(input, type) {
            activeInput = input;
            activeInputType = type;

            const picker = document.getElementById(type === 'stirrup' ? 'stirrupPicker' : 'diameterPicker');
            const rect = input.getBoundingClientRect();

            picker.style.left = rect.left + 'px';
            picker.style.top = (rect.bottom + 5) + 'px';
            picker.classList.add('show');
        }

        function hideQuickPickers() {
            document.querySelectorAll('.quick-picker').forEach(p => p.classList.remove('show'));
        }

        function pickDiameter(val) {
            if (activeInput) {
                activeInput.value = val;
                activeInput.dispatchEvent(new Event('change'));
            }
            hideQuickPickers();
        }

        function pickStirrup(val) {
            if (activeInput) {
                activeInput.value = val;
                activeInput.dispatchEvent(new Event('change'));
            }
            hideQuickPickers();
        }

        // ============ ENHANCED: Keyboard Navigation ============
        function handleKeyDown(event, input) {
            const td = input.closest('td');
            const tr = input.closest('tr');
            const tbody = document.getElementById('spanTableBody');
            const tds = Array.from(tr.querySelectorAll('td'));
            const colIndex = tds.indexOf(td);
            const rows = Array.from(tbody.querySelectorAll('tr'));
            const rowIndex = rows.indexOf(tr);

            switch (event.key) {
                case 'Enter':
                    // Move to same column, next row
                    event.preventDefault();
                    if (rowIndex < rows.length - 1) {
                        const nextRow = rows[rowIndex + 1];
                        const nextInput = nextRow.querySelectorAll('td')[colIndex]?.querySelector('input');
                        if (nextInput) nextInput.focus();
                    }
                    break;
                case 'Tab':
                    // Default Tab behavior is fine
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    if (rowIndex < rows.length - 1) {
                        const nextRow = rows[rowIndex + 1];
                        const nextInput = nextRow.querySelectorAll('td')[colIndex]?.querySelector('input');
                        if (nextInput) nextInput.focus();
                    }
                    break;
                case 'ArrowUp':
                    event.preventDefault();
                    if (rowIndex > 0) {
                        const prevRow = rows[rowIndex - 1];
                        const prevInput = prevRow.querySelectorAll('td')[colIndex]?.querySelector('input');
                        if (prevInput) prevInput.focus();
                    }
                    break;
            }
        }

        // ============ Toast notification ============
        function showToast(msg) {
            const existing = document.querySelector('.toast');
            if (existing) existing.remove();

            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = msg;
            toast.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: var(--accent);
                color: white;
                padding: 10px 20px;
                border-radius: 6px;
                font-size: 13px;
                z-index: 2000;
                animation: fadeOut 3s forwards;
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // ============ UPDATED: renderTable with enhanced features ============
        function renderTable() {
            const tbody = document.getElementById('spanTableBody');
            tbody.innerHTML = '';

            if (!currentGroup || !currentGroup.Spans) return;

            currentGroup.Spans.forEach((span, i) => {
                const tr = document.createElement('tr');
                tr.className = span.IsActive === false ? 'inactive' : '';
                if (bulkEditMode && selectedSpanIndices.includes(i)) {
                    tr.classList.add('selected');
                }
                if (i === highlightedSpanIndex) {
                    tr.classList.add('highlighted');
                }
                tr.dataset.spanIndex = i;

                // Mouse events for bidirectional sync
                tr.addEventListener('mouseenter', () => highlightSpan(i));
                tr.addEventListener('mouseleave', clearHighlight);
                tr.addEventListener('click', (e) => {
                    if (copyFormatMode) {
                        handleCopyFormatClick(i);
                    } else {
                        toggleSpanSelection(i, e);
                    }
                });

                // Span ID
                tr.innerHTML = `<td>${span.SpanId}</td>`;

                // Active checkbox
                tr.innerHTML += `<td><input type="checkbox" ${span.IsActive !== false ? 'checked' : ''} 
                    onchange="toggleSpanActive(${i}, this.checked)"></td>`;

                // Top rebar (5 positions) with quick picker
                for (let p = 0; p < 5; p++) {
                    const val = span.TopRebar && span.TopRebar[0] ? span.TopRebar[0][p] || '' : '';
                    tr.innerHTML += `<td><input type="text" value="${val}" 
                        onchange="updateRebarBulk(${i}, 'Top', ${p}, this.value)"
                        ondblclick="showQuickPicker(this, 'diameter')"
                        onkeydown="handleKeyDown(event, this)"></td>`;
                }

                // Bot rebar (5 positions)
                for (let p = 0; p < 5; p++) {
                    const val = span.BotRebar && span.BotRebar[0] ? span.BotRebar[0][p] || '' : '';
                    tr.innerHTML += `<td><input type="text" value="${val}" 
                        onchange="updateRebarBulk(${i}, 'Bot', ${p}, this.value)"
                        ondblclick="showQuickPicker(this, 'diameter')"
                        onkeydown="handleKeyDown(event, this)"></td>`;
                }

                // Stirrup (3 positions) with quick picker
                for (let p = 0; p < 3; p++) {
                    const val = span.Stirrup ? span.Stirrup[p] || '' : '';
                    tr.innerHTML += `<td><input type="text" value="${val}" 
                        onchange="updateStirrupBulk(${i}, ${p}, this.value)"
                        ondblclick="showQuickPicker(this, 'stirrup')"
                        onkeydown="handleKeyDown(event, this)"></td>`;
                }

                // Side bar
                tr.innerHTML += `<td><input type="text" value="${span.SideBar || ''}" 
                    onchange="updateSideBar(${i}, this.value)"
                    onkeydown="handleKeyDown(event, this)"></td>`;

                tbody.appendChild(tr);
            });
        }

        // Bulk-aware update functions
        function updateRebarBulk(spanIndex, type, pos, value) {
            const indicesToUpdate = bulkEditMode && selectedSpanIndices.length > 0
                ? selectedSpanIndices
                : [spanIndex];

            indicesToUpdate.forEach(idx => {
                const span = currentGroup.Spans[idx];
                const arr = type === 'Top' ? 'TopRebar' : 'BotRebar';
                if (!span[arr]) span[arr] = [[], [], []];
                if (!span[arr][0]) span[arr][0] = [];
                span[arr][0][pos] = value;
            });

            // Auto apply if enabled
            if (document.getElementById('autoApply').checked && !bulkEditMode) {
                updateRebar(spanIndex, type, pos, value);
            }

            if (bulkEditMode && selectedSpanIndices.length > 0) {
                renderTable();
            }
        }

        function updateStirrupBulk(spanIndex, pos, value) {
            const indicesToUpdate = bulkEditMode && selectedSpanIndices.length > 0
                ? selectedSpanIndices
                : [spanIndex];

            indicesToUpdate.forEach(idx => {
                const span = currentGroup.Spans[idx];
                if (!span.Stirrup) span.Stirrup = [];
                span.Stirrup[pos] = value;
            });

            if (bulkEditMode && selectedSpanIndices.length > 0) {
                renderTable();
            }
        }

        // ============ UPDATED: Canvas with click detection and highlighting ============
        function renderCanvas() {
            const canvas = document.getElementById('beamCanvas');
            const ctx = canvas.getContext('2d');

            if (!currentGroup || !currentGroup.Spans) return;

            spanBounds = []; // Reset bounds

            // Calculate total width
            let totalWidth = CANVAS_PADDING * 2;
            currentGroup.Spans.forEach(span => {
                totalWidth += Math.max(span.Length * PIXELS_PER_METER, MIN_SPAN_WIDTH);
            });
            totalWidth += currentGroup.Supports ? currentGroup.Supports.length * 30 : 0;

            canvas.width = Math.max(totalWidth, 800);
            const height = canvas.height;

            // Clear
            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, canvas.width, height);

            let x = CANVAS_PADDING;
            const beamY = 80;

            // Draw supports and spans
            currentGroup.Spans.forEach((span, i) => {
                const spanWidth = Math.max(span.Length * PIXELS_PER_METER, MIN_SPAN_WIDTH);

                // Left support
                if (i === 0 && currentGroup.Supports && currentGroup.Supports[0]) {
                    drawSupport(ctx, x, beamY, currentGroup.Supports[0]);
                    x += 15;
                }

                // Store span bounds for click detection
                spanBounds.push({ x: x, y: beamY, width: spanWidth, height: BEAM_HEIGHT, index: i });

                // Beam span (with highlight if selected)
                drawSpan(ctx, x, beamY, spanWidth, span, i === highlightedSpanIndex);
                x += spanWidth;

                // Right support
                if (currentGroup.Supports && currentGroup.Supports[i + 1]) {
                    drawSupport(ctx, x, beamY, currentGroup.Supports[i + 1]);
                    x += 15;
                }
            });

            // Dimension line
            drawDimensions(ctx, beamY + BEAM_HEIGHT + 40);
        }

        function drawSpan(ctx, x, y, width, span, isHighlighted) {
            // Beam rect with highlight
            ctx.fillStyle = isHighlighted ? '#2a5a8a' : '#1f4068';
            ctx.strokeStyle = isHighlighted ? '#ff6b8a' : '#e94560';
            ctx.lineWidth = isHighlighted ? 3 : 2;
            ctx.fillRect(x, y, width, BEAM_HEIGHT);
            ctx.strokeRect(x, y, width, BEAM_HEIGHT);

            // ============ REBAR VISUALIZATION ============
            const REBAR_OFFSET_TOP = 15;       // Distance from top edge
            const REBAR_OFFSET_BOT = 12;       // Distance from bottom edge
            const BACKBONE_Y_TOP = y + REBAR_OFFSET_TOP;
            const BACKBONE_Y_BOT = y + BEAM_HEIGHT - REBAR_OFFSET_BOT;

            // Get backbone from selected option
            const backbone = currentGroup.BackboneOptions?.[currentGroup.SelectedBackboneIndex || 0];

            // Draw Backbone bars (continuous - pink/red)
            if (backbone) {
                ctx.strokeStyle = '#ff6b8a'; // Pink for backbone
                ctx.lineWidth = 3;
                ctx.setLineDash([]);

                // Top backbone
                ctx.beginPath();
                ctx.moveTo(x + 5, BACKBONE_Y_TOP);
                ctx.lineTo(x + width - 5, BACKBONE_Y_TOP);
                ctx.stroke();

                // Bottom backbone
                ctx.beginPath();
                ctx.moveTo(x + 5, BACKBONE_Y_BOT);
                ctx.lineTo(x + width - 5, BACKBONE_Y_BOT);
                ctx.stroke();

                // Backbone label
                ctx.fillStyle = '#ff6b8a';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'left';
                if (backbone.OptionName) {
                    ctx.fillText(backbone.OptionName.replace('Top: ', ''), x + 8, BACKBONE_Y_TOP - 3);
                }
            }

            // Draw Addon bars (span-specific - blue) if defined
            const topRebar = span.TopRebar?.[0];
            const botRebar = span.BotRebar?.[0];

            ctx.strokeStyle = '#4db8ff'; // Blue for addon
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]); // Dashed for addon

            // Top addon - draw at positions 0 (left), 2 (mid), 4 (right)
            if (topRebar) {
                const hasLeft = topRebar[0] && topRebar[0] !== backbone?.OptionName?.split(',')[0];
                const hasMid = topRebar[2];
                const hasRight = topRebar[4] && topRebar[4] !== backbone?.OptionName?.split(',')[0];

                if (hasLeft) {
                    ctx.beginPath();
                    ctx.moveTo(x + 3, BACKBONE_Y_TOP + 5);
                    ctx.lineTo(x + width * 0.3, BACKBONE_Y_TOP + 5);
                    ctx.stroke();
                }
                if (hasMid) {
                    ctx.beginPath();
                    ctx.moveTo(x + width * 0.35, BACKBONE_Y_TOP + 5);
                    ctx.lineTo(x + width * 0.65, BACKBONE_Y_TOP + 5);
                    ctx.stroke();
                }
                if (hasRight) {
                    ctx.beginPath();
                    ctx.moveTo(x + width * 0.7, BACKBONE_Y_TOP + 5);
                    ctx.lineTo(x + width - 3, BACKBONE_Y_TOP + 5);
                    ctx.stroke();
                }
            }

            // Bottom addon
            if (botRebar) {
                const hasLeft = botRebar[0];
                const hasMid = botRebar[2];
                const hasRight = botRebar[4];

                if (hasLeft) {
                    ctx.beginPath();
                    ctx.moveTo(x + 3, BACKBONE_Y_BOT - 5);
                    ctx.lineTo(x + width * 0.3, BACKBONE_Y_BOT - 5);
                    ctx.stroke();
                }
                if (hasMid) {
                    ctx.beginPath();
                    ctx.moveTo(x + width * 0.35, BACKBONE_Y_BOT - 5);
                    ctx.lineTo(x + width * 0.65, BACKBONE_Y_BOT - 5);
                    ctx.stroke();
                }
                if (hasRight) {
                    ctx.beginPath();
                    ctx.moveTo(x + width * 0.7, BACKBONE_Y_BOT - 5);
                    ctx.lineTo(x + width - 3, BACKBONE_Y_BOT - 5);
                    ctx.stroke();
                }
            }

            ctx.setLineDash([]); // Reset dash

            // ============ SPLICE MARKERS (Ellipse 45¬∞) ============
            // Check if splice visualization is enabled (not SkipSplice mode)
            const skipSplice = data.settings?.Detailing?.SkipSplice || false;

            if (!skipSplice) {
                // Draw splice markers at bar ends (where bars would connect)
                // Position: at ~30% and ~70% of span for illustration

                // Top bar splice markers
                if (currentGroup.RequiresSplice) {
                    drawSpliceMarker(ctx, x + width * 0.35, BACKBONE_Y_TOP, '#ff6b8a');
                    drawSpliceMarker(ctx, x + width * 0.65, BACKBONE_Y_TOP, '#ff6b8a');
                }

                // Bottom bar splice markers  
                if (currentGroup.RequiresSplice) {
                    drawSpliceMarker(ctx, x + width * 0.25, BACKBONE_Y_BOT, '#ff6b8a');
                    drawSpliceMarker(ctx, x + width * 0.75, BACKBONE_Y_BOT, '#ff6b8a');
                }
            }

            // ============ END REBAR VISUALIZATION ============

            // Span label
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(span.SpanId, x + width / 2, y + BEAM_HEIGHT / 2 + 5);

            // Dimensions text (below beam)
            ctx.fillStyle = '#8892a0';
            ctx.font = '11px sans-serif';
            ctx.fillText(`${span.Width}x${span.Height}`, x + width / 2, y + BEAM_HEIGHT + 15);
            ctx.fillText(`L=${span.Length.toFixed(2)}m`, x + width / 2, y + BEAM_HEIGHT + 28);

            // Step change indicator
            if (span.IsStepChange) {
                ctx.fillStyle = '#fbbf24';
                ctx.fillText('‚ö†Ô∏è', x + width - 15, y + 15);
            }
        }

        // Canvas mouse events
        document.getElementById('beamCanvas').addEventListener('mousemove', function (e) {
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            let found = -1;
            for (const bound of spanBounds) {
                if (x >= bound.x && x <= bound.x + bound.width &&
                    y >= bound.y && y <= bound.y + bound.height) {
                    found = bound.index;
                    break;
                }
            }

            if (found !== highlightedSpanIndex) {
                if (found >= 0) {
                    highlightSpan(found);
                } else {
                    clearHighlight();
                }
            }
        });

        document.getElementById('beamCanvas').addEventListener('click', function (e) {
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            for (const bound of spanBounds) {
                if (x >= bound.x && x <= bound.x + bound.width &&
                    y >= bound.y && y <= bound.y + bound.height) {
                    if (copyFormatMode) {
                        handleCopyFormatClick(bound.index);
                    } else {
                        // Scroll to and focus the row
                        const row = document.querySelector(`tr[data-span-index="${bound.index}"]`);
                        if (row) {
                            row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            row.querySelector('input')?.focus();
                        }
                    }
                    break;
                }
            }
        });

        // Hide pickers on click outside
        document.addEventListener('click', function (e) {
            if (!e.target.closest('.quick-picker') && !e.target.matches('input[type="text"]')) {
                hideQuickPickers();
            }
        });

        // Initialize
        init();
    </script>
</body>

</html>