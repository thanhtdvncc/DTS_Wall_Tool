<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <title>DTS Beam Group Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- DTS Canvas Engine -->
    <script src="DtsCanvas.js"></script>
    <script src="BeamCanvas.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        accent: '#f59e0b',
                        danger: '#ef4444',
                        success: '#22c55e'
                    }
                }
            }
        }
    </script>
    <style>
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        .span-row.highlighted {
            background: rgba(59, 130, 246, 0.15) !important;
        }

        .span-row:hover {
            background: rgba(59, 130, 246, 0.08);
        }

        .span-row.selected {
            background: rgba(34, 197, 94, 0.15);
        }

        .toast {
            animation: slideUp 0.3s ease, fadeOut 2.5s 0.5s forwards;
        }

        @keyframes slideUp {
            from {
                transform: translate(-50%, 100%);
                opacity: 0;
            }

            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
            }
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
    </style>
</head>

<body class="bg-slate-100 text-slate-800 font-sans text-sm h-screen flex flex-col overflow-hidden">

    <!-- HEADER -->
    <header class="flex-none bg-slate-900 text-white shadow-md z-50">
        <div class="px-4 py-2 flex justify-between items-center gap-4">
            <div class="flex items-center gap-3">
                <i class="fa-solid fa-layer-group text-amber-500 text-xl"></i>
                <h1 class="text-lg font-bold">DTS Rebar Viewer</h1>
            </div>

            <div class="flex items-center gap-3">
                <button class="nav-btn px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded" onclick="prevGroup()">
                    <i class="fa-solid fa-chevron-left"></i>
                </button>
                <select id="groupSelect" onchange="loadGroup(this.value)"
                    class="bg-slate-800 border border-slate-600 text-white px-3 py-1 rounded min-w-[180px]"></select>
                <button class="nav-btn px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded" onclick="nextGroup()">
                    <i class="fa-solid fa-chevron-right"></i>
                </button>
            </div>

            <div class="flex items-center gap-2">
                <label class="text-xs text-slate-400">Ph∆∞∆°ng √°n:</label>
                <select id="optionSelect" onchange="selectOption(this.value)"
                    class="bg-slate-800 border border-slate-600 text-white px-2 py-1 rounded text-xs"></select>
                <button id="lockBtn" onclick="toggleLock()" title="Ch·ªët/M·ªü kh√≥a ph∆∞∆°ng √°n"
                    class="px-2 py-1 bg-amber-600 hover:bg-amber-500 text-white rounded text-xs flex items-center gap-1">
                    <i class="fa-solid fa-lock"></i> Ch·ªët
                </button>
                <button id="lockStatus" onclick="restoreLockedDesign()" title="Click ƒë·ªÉ restore ph∆∞∆°ng √°n ƒë√£ ch·ªët"
                    class="text-xs text-green-400 hover:text-green-300 cursor-pointer hidden flex items-center gap-1">
                    <i class="fa-solid fa-check-circle"></i> ƒê√£ ch·ªët
                </button>
            </div>

            <div class="flex gap-2 items-center">
                <!-- Undo/Redo Buttons -->
                <button onclick="Beam.History.undo()" title="Undo (Ctrl+Z)"
                    class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white rounded text-xs">
                    <i class="fa-solid fa-undo"></i>
                </button>
                <button onclick="Beam.History.redo()" title="Redo (Ctrl+Y)"
                    class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white rounded text-xs">
                    <i class="fa-solid fa-redo"></i>
                </button>
                <div class="w-px h-4 bg-slate-600"></div>
                <!-- Quick Calc Button -->
                <button onclick="quickCalc()" title="T√≠nh th√©p nhanh cho group n√†y"
                    class="px-2 py-1 bg-green-600 hover:bg-green-500 text-white rounded text-xs flex items-center gap-1">
                    <i class="fa-solid fa-calculator"></i> T√≠nh th√©p
                </button>
                <!-- Highlight CAD Toggle -->
                <label class="flex items-center gap-1 text-xs cursor-pointer">
                    <span class="text-slate-400">Highlight</span>
                    <div class="relative">
                        <input type="checkbox" id="highlightToggle" class="sr-only peer"
                            onchange="toggleHighlightMode(this.checked)">
                        <div class="w-8 h-4 bg-slate-600 rounded-full peer-checked:bg-blue-500 transition-colors"></div>
                        <div
                            class="absolute top-0.5 left-0.5 w-3 h-3 bg-white rounded-full peer-checked:translate-x-4 transition-transform">
                        </div>
                    </div>
                </label>
                <button class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white rounded text-xs"
                    onclick="copyFormat()"><i class="fa-solid fa-paintbrush"></i></button>
            </div>
        </div>
    </header>

    <!-- MAIN -->
    <main class="flex-1 flex flex-col overflow-hidden relative">
        <!-- CANVAS CONTAINER - Full height, table overlays on top -->
        <div class="absolute inset-0 bg-white border-b border-slate-200 overflow-hidden" id="canvasContainer">
            <canvas id="beamCanvas" height="360"></canvas>
            <!-- View Mode Toggle: Mode 1 = Section, Mode 2 = Long Rebar, Mode 3 = Shear-Web Bar -->
            <div class="absolute top-12 right-2 flex gap-1 z-20">
                <button onclick="setCanvasMode('section')" id="modeSection"
                    class="px-2 py-1 bg-slate-600 text-white text-[10px] rounded hover:bg-slate-500 shadow">Section</button>
                <button onclick="setCanvasMode('long')" id="modeLong"
                    class="px-2 py-1 bg-blue-600 text-white text-[10px] rounded hover:bg-blue-500 shadow">Long
                    Rebar</button>
                <button onclick="setCanvasMode('shear')" id="modeShear"
                    class="px-2 py-1 bg-slate-600 text-white text-[10px] rounded hover:bg-slate-500 shadow">Shear-Web</button>
            </div>
            <!-- Zoom indicator -->
            <div id="zoomIndicator"
                class="absolute bottom-2 right-2 bg-slate-800/70 text-white text-[10px] px-2 py-0.5 rounded">100%</div>
            <!-- Help overlay -->
            <div class="absolute bottom-2 left-2 text-[9px] text-slate-400 bg-white/70 px-1 rounded">Drag: Box Zoom |
                Alt+Drag: Pan | Wheel: Zoom | DblClick: Reset</div>
        </div>

        <!-- METRICS BAR - Overlay at top -->
        <div id="metricsBar"
            class="absolute top-0 left-0 right-0 bg-slate-50/95 backdrop-blur border-b border-slate-200 px-4 py-2 flex items-center gap-6 text-xs flex-wrap z-10">
            <div class="flex items-center gap-2">
                <span class="text-slate-500">Backbone:</span>
                <span class="font-bold text-blue-600" id="metricBackbone">-</span>
            </div>
            <div class="flex items-center gap-2">
                <span class="text-slate-500">As:</span>
                <span class="font-bold" id="metricAs">-</span>
            </div>
            <div class="flex items-center gap-2">
                <span class="text-slate-500">Waste:</span>
                <span class="font-bold" id="metricWaste">-</span>
            </div>
            <div class="flex items-center gap-2">
                <span class="text-slate-500">Weight:</span>
                <span class="font-bold" id="metricWeight">-</span>
            </div>
            <div class="flex items-center gap-2">
                <span class="text-slate-500">Score:</span>
                <span class="font-bold text-green-600" id="metricScore">-</span>
            </div>
            <div id="warningsContainer" class="flex gap-2"></div>
        </div>

        <!-- COLLAPSIBLE TABLE SECTION - Overlay at bottom -->
        <div id="tablePanel"
            class="absolute bottom-0 left-0 right-0 bg-slate-50/95 backdrop-blur border-t border-slate-300 transition-all duration-300 ease-in-out max-h-[300px] overflow-hidden z-10">
            <!-- Toggle Button -->
            <button onclick="toggleTablePanel()"
                class="w-full py-1 bg-slate-200 hover:bg-slate-300 flex items-center justify-center gap-2 text-xs text-slate-600">
                <i id="tablePanelIcon" class="fa-solid fa-chevron-down"></i>
                <span id="tablePanelLabel">B·∫£ng chi ti·∫øt nh·ªãp</span>
            </button>
            <div id="tablePanelContent" class="p-3 overflow-auto max-h-[260px]">
                <div class="flex items-center gap-3 mb-2">
                    <label class="flex items-center gap-1 text-xs">
                        <input type="checkbox" id="autoApply" checked class="w-3.5 h-3.5">
                        Auto Apply
                    </label>
                    <button class="px-2 py-1 bg-slate-200 hover:bg-slate-300 rounded text-xs"
                        onclick="selectAllSpans()">Select All</button>
                    <button class="px-2 py-1 bg-slate-200 hover:bg-slate-300 rounded text-xs"
                        onclick="selectNoneSpans()">Select None</button>
                    <div class="ml-auto text-xs text-slate-500">
                        <span id="groupInfo">-</span>
                    </div>
                </div>

                <div class="bg-white rounded border border-slate-200 overflow-hidden">
                    <table class="table-fixed w-max text-xs whitespace-nowrap">
                        <thead class="bg-slate-100 sticky top-0">
                            <tr>
                                <th class="p-1 text-left w-14" rowspan="2">Nh·ªãp</th>
                                <th class="p-1 text-center w-8" rowspan="2">‚úì</th>
                                <th class="p-1 text-center w-10" rowspan="2">L(m)</th>
                                <th class="p-1 text-center w-12" rowspan="2">b√óh</th>
                                <th class="p-1 text-center w-8" rowspan="2">L·ªõp</th>
                                <th colspan="3" class="p-1 text-center bg-red-50 text-red-700 text-[10px]">TH√âP TR√äN
                                </th>
                                <th colspan="3" class="p-1 text-center bg-blue-50 text-blue-700 text-[10px]">TH√âP D∆Ø·ªöI
                                </th>
                                <th colspan="3" class="p-1 text-center bg-slate-100 text-[10px]">ƒêAI</th>
                                <th class="p-1 text-center w-12" rowspan="2">Sidebar</th>
                            </tr>
                            <tr class="text-[10px] text-slate-500">
                                <th class="p-1 bg-red-50 w-12">G·ªëi T</th>
                                <th class="p-1 bg-red-50 w-12">Gi·ªØa</th>
                                <th class="p-1 bg-red-50 w-12">G·ªëi P</th>
                                <th class="p-1 bg-blue-50 w-12">G·ªëi T</th>
                                <th class="p-1 bg-blue-50 w-12">Gi·ªØa</th>
                                <th class="p-1 bg-blue-50 w-12">G·ªëi P</th>
                                <th class="p-1 w-12">L1</th>
                                <th class="p-1 w-12">Mid</th>
                                <th class="p-1 w-12">L2</th>
                            </tr>
                        </thead>
                        <tbody id="spanTableBody"></tbody>
                    </table>
                </div>

                <div class="mt-3 flex items-center gap-3">
                    <label class="text-xs text-slate-500">Stirrup pattern:</label>
                    <input type="text" id="stirrupPattern" value="d8a100/150/100"
                        class="border border-slate-300 rounded px-2 py-1 text-xs w-32">
                    <button class="px-2 py-1 bg-slate-200 hover:bg-slate-300 rounded text-xs"
                        onclick="applyStirrupPattern()">
                        Apply to Active
                    </button>
                </div>
            </div> <!-- End tablePanelContent -->
        </div> <!-- End tablePanel -->
    </main>

    <!-- FOOTER -->
    <footer class="flex-none bg-white border-t border-slate-200 px-4 py-2 flex justify-between items-center">
        <div class="flex gap-2">
            <button class="px-3 py-1.5 bg-slate-200 hover:bg-slate-300 rounded text-xs font-medium" onclick="doSave()">
                <i class="fa-solid fa-save mr-1"></i>Save
            </button>
            <button class="px-3 py-1.5 bg-slate-200 hover:bg-slate-300 rounded text-xs font-medium"
                onclick="doExport()">
                <i class="fa-solid fa-file-export mr-1"></i>Export
            </button>
            <button class="px-3 py-1.5 bg-slate-200 hover:bg-slate-300 rounded text-xs font-medium"
                onclick="doImport()">
                <i class="fa-solid fa-file-import mr-1"></i>Import
            </button>
        </div>
        <div class="flex gap-2">
            <button class="px-3 py-1.5 bg-slate-300 hover:bg-slate-400 rounded text-xs font-medium"
                onclick="doCancel()">
                Cancel
            </button>
            <button class="px-4 py-1.5 bg-blue-600 hover:bg-blue-500 text-white rounded text-xs font-bold"
                onclick="applyToDrawing()">
                <i class="fa-solid fa-check mr-1"></i>Apply to Drawing
            </button>
        </div>
    </footer>

    <script>
        // ============================================================
        // BEAM VIEWER - Modular Architecture
        // Uses Beam namespace for state and functions
        // Core modules (Dts.*) injected by C# if available
        // ============================================================

        // Data from C#
        const data = __DATA_JSON__;

        // ============ BEAM NAMESPACE ============
        window.Beam = window.Beam || {};

        // State management
        Beam.State = {
            currentGroupIndex: 0,
            currentGroup: null,
            selectedOptionKey: null, // 'locked' | numeric index as string
            highlightedSpanIndex: -1,
            spanBounds: [],

            // Canvas mode: 'section' | 'long' | 'shear'
            canvasMode: 'long',

            // Canvas interaction
            zoom: 1.0,
            panX: 0,
            panY: 0,
            isDragging: false,
            lastX: 0,
            lastY: 0,

            // Box zoom
            boxZoomActive: false,
            boxZoomStartX: 0,
            boxZoomStartY: 0,
            boxZoomEndX: 0,
            boxZoomEndY: 0,

            // UI
            tablePanelCollapsed: false,
            highlightModeEnabled: false
        };

        // Constants
        Beam.Constants = {
            MIN_SPAN_WIDTH: 80,
            MAX_CANVAS_WIDTH: 1600,
            CANVAS_PADDING: 30,
            BEAM_HEIGHT: 120
        };

        // ============ HISTORY (UNDO/REDO) ============
        Beam.History = {
            stack: [],
            ptr: -1,
            maxSize: 20,
            isLocked: false, // When locked, edits are disabled

            // Take snapshot of current group rebar state
            snapshot() {
                if (!currentGroup) return null;
                return JSON.stringify({
                    spans: currentGroup.Spans?.map(s => ({
                        SpanId: s.SpanId,
                        TopRebar: s.TopRebar,
                        BotRebar: s.BotRebar,
                        Stirrup: s.Stirrup,
                        WebBar: s.WebBar
                    })),
                    selectedBackbone: currentGroup.SelectedBackboneIndex
                });
            },

            push() {
                if (this.isLocked) return false;
                const snap = this.snapshot();
                if (!snap) return false;
                // Skip if same as current
                if (this.ptr > -1 && this.stack[this.ptr] === snap) return false;
                // Truncate redo stack
                if (this.ptr < this.stack.length - 1) {
                    this.stack = this.stack.slice(0, this.ptr + 1);
                }
                this.stack.push(snap);
                this.ptr++;
                // Limit size
                if (this.stack.length > this.maxSize) {
                    this.stack.shift();
                    this.ptr--;
                }
                return true;
            },

            restore(snapshot) {
                if (!currentGroup || !snapshot) return;
                try {
                    const d = JSON.parse(snapshot);
                    if (d.spans) {
                        d.spans.forEach(sr => {
                            const span = currentGroup.Spans?.find(s => s.SpanId === sr.SpanId);
                            if (span) {
                                span.TopRebar = sr.TopRebar;
                                span.BotRebar = sr.BotRebar;
                                span.Stirrup = sr.Stirrup;
                                span.WebBar = sr.WebBar;
                            }
                        });
                    }
                    if (d.selectedBackbone !== undefined) {
                        currentGroup.SelectedBackboneIndex = d.selectedBackbone;
                    }
                    renderCanvas();
                    maybeRenderTable();
                    updateMetrics();
                } catch (e) { console.error('History restore error', e); }
            },

            undo() {
                if (this.ptr > 0) {
                    this.ptr--;
                    this.restore(this.stack[this.ptr]);
                }
            },

            redo() {
                if (this.ptr < this.stack.length - 1) {
                    this.ptr++;
                    this.restore(this.stack[this.ptr]);
                }
            },

            clear() {
                this.stack = [];
                this.ptr = -1;
            }
        };

        // ============ LOCK/UNLOCK ============
        let lockedSnapshot = null; // Snapshot at lock time

        function toggleLock() {
            if (!currentGroup) return;

            if (currentGroup.SelectedDesign) {
                // Unlock
                currentGroup.SelectedDesign = null;
                currentGroup.LockedAt = null;
                Beam.History.isLocked = false;
                lockedSnapshot = null;
                // Notify C# to update _groups
                window.chrome.webview?.postMessage('UNLOCK_DESIGN|' + currentGroupIndex);
            } else {
                // Lock current design
                const opt = getSelectedOption();
                if (!opt) return;
                currentGroup.SelectedDesign = JSON.parse(JSON.stringify(opt));
                currentGroup.LockedAt = new Date().toISOString();
                Beam.History.isLocked = true;
                lockedSnapshot = Beam.History.snapshot();
                // Notify C# to update _groups with SelectedDesign
                window.chrome.webview?.postMessage('LOCK_DESIGN|' + currentGroupIndex + '|' + JSON.stringify(currentGroup.SelectedDesign));
            }
            updateLockStatus();
            populateOptionSelect();
        }

        function restoreLockedDesign() {
            if (!currentGroup?.SelectedDesign || !lockedSnapshot) return;
            Beam.History.restore(lockedSnapshot);
        }

        function updateLockStatus() {
            const btn = document.getElementById('lockBtn');
            const status = document.getElementById('lockStatus');
            if (!currentGroup) return;

            const isLocked = !!currentGroup.SelectedDesign;
            Beam.History.isLocked = isLocked;

            if (isLocked) {
                btn.innerHTML = '<i class="fa-solid fa-lock-open"></i> M·ªü';
                btn.className = 'px-2 py-1 bg-slate-600 hover:bg-slate-500 text-white rounded text-xs flex items-center gap-1';
                status.classList.remove('hidden');
            } else {
                btn.innerHTML = '<i class="fa-solid fa-lock"></i> Ch·ªët';
                btn.className = 'px-2 py-1 bg-amber-600 hover:bg-amber-500 text-white rounded text-xs flex items-center gap-1';
                status.classList.add('hidden');
            }
        }

        // Aliases for backward compatibility (refactor gradually)
        let currentGroupIndex = 0;
        let currentGroup = null;
        let selectedOptionKey = null;
        let highlightedSpanIndex = -1;
        let spanBounds = [];
        let rebarLabelBounds = [];
        const MIN_SPAN_WIDTH = 80;
        const MAX_CANVAS_WIDTH = 1600;
        const CANVAS_PADDING = 30;
        const BEAM_HEIGHT = 120;
        const FIXED_SPAN_WIDTH = 473; // -25% from 630

        // Inline canvas label editor (DOM overlay)
        let labelEditorEl = null;
        let activeLabelEdit = null;
        let highlightModeEnabled = false;
        let canvasMode = 'long';
        let canvasZoom = 1.0;
        let canvasPanX = 0;
        let canvasPanY = 0;
        let canvasDragging = false;
        let canvasLastX = 0;
        let canvasLastY = 0;
        let boxZoomActive = false;
        let boxZoomStartX = 0;
        let boxZoomStartY = 0;
        let boxZoomEndX = 0;
        let boxZoomEndY = 0;
        let tablePanelCollapsed = false;

        function maybeRenderTable() {
            // Avoid heavy table re-render during canvas-first workflow when panel is collapsed.
            // When user expands the panel, we'll re-render once.
            if (!tablePanelCollapsed) renderTable();
        }

        function toggleTablePanel() {
            tablePanelCollapsed = !tablePanelCollapsed;
            const panel = document.getElementById('tablePanel');
            const icon = document.getElementById('tablePanelIcon');
            const content = document.getElementById('tablePanelContent');

            if (tablePanelCollapsed) {
                panel.classList.remove('max-h-[300px]');
                panel.classList.add('max-h-[32px]');
                content.classList.add('hidden');
                icon.classList.remove('fa-chevron-down');
                icon.classList.add('fa-chevron-up');
            } else {
                panel.classList.remove('max-h-[32px]');
                panel.classList.add('max-h-[300px]');
                content.classList.remove('hidden');
                icon.classList.remove('fa-chevron-up');
                icon.classList.add('fa-chevron-down');

                // Panel just expanded: refresh table to reflect any canvas edits made while collapsed.
                renderTable();
            }
        }

        function setCanvasMode(mode) {
            canvasMode = mode;
            // Toggle active state for 3 buttons
            const btnSection = document.getElementById('modeSection');
            const btnLong = document.getElementById('modeLong');
            const btnShear = document.getElementById('modeShear');

            btnSection.classList.toggle('bg-blue-600', mode === 'section');
            btnSection.classList.toggle('bg-slate-600', mode !== 'section');
            btnLong.classList.toggle('bg-blue-600', mode === 'long');
            btnLong.classList.toggle('bg-slate-600', mode !== 'long');
            btnShear.classList.toggle('bg-blue-600', mode === 'shear');
            btnShear.classList.toggle('bg-slate-600', mode !== 'shear');

            renderCanvas();
        }

        function autoLockOnEdit() {
            // Block edits when locked
            if (Beam.History.isLocked) return false;

            // Push to history stack BEFORE change
            Beam.History.push();

            // When user manually edits, mark span as user-edited
            if (currentGroup && highlightedSpanIndex >= 0) {
                const span = currentGroup.Spans[highlightedSpanIndex];
                if (span) span._userEdited = true;
            }
            return true;
        }

        function toggleHighlightMode(enabled) {
            highlightModeEnabled = enabled;
            if (enabled) {
                // Immediately set 80% transparent when toggle ON
                window.chrome.webview.postMessage('SET_OPACITY|0.2');
                showToast('‚úì Highlight mode ON - form 80% trong su·ªët');
            } else {
                // Reset to full opacity when toggle OFF
                window.chrome.webview.postMessage('SET_OPACITY|1.0');
                showToast('Highlight mode OFF');
            }
        }

        // Resize canvas to fill container (proper pixel sizing, no CSS stretch)
        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            const canvas = document.getElementById('beamCanvas');
            if (container && canvas) {
                // Remove CSS sizing to prevent stretching
                canvas.style.width = '';
                canvas.style.height = '';
                // Set actual canvas resolution based on container size
                const w = container.clientWidth || 800;
                const h = container.clientHeight || 300;
                if (canvas.width !== w || canvas.height !== h) {
                    canvas.width = w;
                    canvas.height = h;
                    renderCanvas();
                }
            }
        }

        function init() {
            // Resize canvas with multiple fallbacks for reliable sizing
            // Container may not have size immediately on WebView2 load
            resizeCanvas();
            requestAnimationFrame(resizeCanvas);
            setTimeout(resizeCanvas, 100);
            setTimeout(resizeCanvas, 300);
            window.addEventListener('resize', () => { hideInlineLabelEditor(); resizeCanvas(); });

            const canvasContainer = document.getElementById('canvasContainer');
            if (canvasContainer) {
                canvasContainer.addEventListener('scroll', () => hideInlineLabelEditor());
                canvasContainer.addEventListener('wheel', () => hideInlineLabelEditor(), { passive: true });
            }

            // Sync material grades from DtsSettings to read-only display
            if (data.settings) {
                const concreteDisp = document.getElementById('concreteDisplay');
                const steelDisp = document.getElementById('steelDisplay');
                if (concreteDisp && data.settings.ConcreteGradeName) {
                    concreteDisp.textContent = data.settings.ConcreteGradeName;
                }
                if (steelDisp && data.settings.SteelGradeName) {
                    // Map CB400-V to CB400, etc.
                    const grade = data.settings.SteelGradeName.replace('-V', '');
                    steelDisp.textContent = grade;
                }
            }

            // Initialize canvas interaction system (inline, no external dependency)
            const canvas = document.getElementById('beamCanvas');
            if (canvas) {
                // Inline label editor overlay (canvas-first editing)
                const canvasContainer = document.getElementById('canvasContainer');
                if (canvasContainer && !labelEditorEl) {
                    // ensure positioning context
                    if (!canvasContainer.style.position) canvasContainer.style.position = 'relative';
                    labelEditorEl = document.createElement('input');
                    labelEditorEl.type = 'text';
                    labelEditorEl.className = 'hidden absolute z-50 border border-slate-300 rounded px-1 py-0.5 text-[11px] bg-white';
                    labelEditorEl.style.minWidth = '60px';
                    labelEditorEl.style.height = '20px';
                    labelEditorEl.addEventListener('keydown', (ev) => {
                        if (ev.key === 'Enter') {
                            commitInlineLabelEdit();
                        } else if (ev.key === 'Escape') {
                            cancelInlineLabelEdit();
                        }
                        ev.stopPropagation();
                    });
                    labelEditorEl.addEventListener('blur', () => {
                        if (labelEditorEl && !labelEditorEl.classList.contains('hidden')) commitInlineLabelEdit();
                    });
                    canvasContainer.appendChild(labelEditorEl);
                }

                // Click: label edit (priority) or span select/copy-format
                canvas.addEventListener('click', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left - canvasPanX) / canvasZoom;
                    const y = (e.clientY - rect.top - canvasPanY) / canvasZoom;

                    // Label hit => edit
                    for (let i = 0; i < rebarLabelBounds.length; i++) {
                        const lb = rebarLabelBounds[i];
                        if (x >= lb.x && x <= lb.x + lb.width && y >= lb.y && y <= lb.y + lb.height) {
                            startInlineLabelEdit(lb);
                            return;
                        }
                    }

                    for (let i = 0; i < spanBounds.length; i++) {
                        const b = spanBounds[i];
                        if (x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height) {
                            const spanIndex = b.index;
                            // Copy format mode
                            if (copyFormatMode) {
                                if (!copySourceSpan) {
                                    copySourceSpan = currentGroup.Spans[spanIndex];
                                    showToast('Ch·ªçn nh·ªãp ƒë√≠ch...');
                                } else {
                                    const dest = currentGroup.Spans[spanIndex];
                                    dest.TopRebar = JSON.parse(JSON.stringify(copySourceSpan.TopRebar || []));
                                    dest.BotRebar = JSON.parse(JSON.stringify(copySourceSpan.BotRebar || []));
                                    dest.Stirrup = [...(copySourceSpan.Stirrup || [])];
                                    copyFormatMode = false;
                                    copySourceSpan = null;
                                    document.body.style.cursor = 'default';
                                    renderCanvas();
                                    renderTable();
                                    showToast('‚úì Copied format to ' + dest.SpanId);
                                }
                                return;
                            }

                            highlightSpan(spanIndex);

                            // Expand table panel if collapsed
                            const panel = document.getElementById('tablePanel');
                            if (panel && panel.classList.contains('max-h-8')) {
                                toggleTablePanel(); // Expand it
                            }

                            // Scroll to row within tablePanelContent
                            const row = document.querySelector(`[data-span-index="${spanIndex}"]`);
                            if (row) {
                                const container = document.getElementById('tablePanelContent');
                                if (container) {
                                    // Calculate scroll position to center row
                                    const rowTop = row.offsetTop;
                                    const containerHeight = container.clientHeight;
                                    container.scrollTo({
                                        top: rowTop - containerHeight / 2 + row.offsetHeight / 2,
                                        behavior: 'smooth'
                                    });
                                }
                            }
                            break;
                        }
                    }
                });

                // Hover to highlight span + Box zoom drag update
                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();

                    // Handle box zoom drag
                    if (boxZoomActive) {
                        boxZoomEndX = e.clientX - rect.left;
                        boxZoomEndY = e.clientY - rect.top;
                        renderCanvas(); // Will draw selection box
                        return;
                    }

                    // Handle pan drag
                    if (canvasDragging) {
                        const dx = e.clientX - canvasLastX;
                        const dy = e.clientY - canvasLastY;
                        canvasPanX += dx;
                        canvasPanY += dy;
                        canvasLastX = e.clientX;
                        canvasLastY = e.clientY;
                        renderCanvas();
                    } else {
                        // Hover detection
                        const x = (e.clientX - rect.left - canvasPanX) / canvasZoom;
                        const y = (e.clientY - rect.top - canvasPanY) / canvasZoom;

                        // Hover label => pointer cursor
                        let overLabel = false;
                        for (let i = 0; i < rebarLabelBounds.length; i++) {
                            const lb = rebarLabelBounds[i];
                            if (x >= lb.x && x <= lb.x + lb.width && y >= lb.y && y <= lb.y + lb.height) {
                                overLabel = true;
                                break;
                            }
                        }
                        if (overLabel) {
                            canvas.style.cursor = 'pointer';
                        } else if (!canvasDragging && !boxZoomActive) {
                            canvas.style.cursor = 'default';
                        }
                        let found = -1;
                        for (let i = 0; i < spanBounds.length; i++) {
                            const b = spanBounds[i];
                            if (x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height) {
                                found = b.index;
                                break;
                            }
                        }
                        if (found !== highlightedSpanIndex) {
                            highlightedSpanIndex = found;
                            renderCanvas();
                            renderTable();
                        }
                    }
                });

                // Middle click or Alt+click to start pan, Ctrl+click or left-click-hold to start box zoom
                let boxZoomTimer = null;
                canvas.addEventListener('mousedown', (e) => {
                    hideInlineLabelEditor();
                    const rect = canvas.getBoundingClientRect();

                    // Ctrl+Left click = Immediate Box Zoom
                    if (e.button === 0 && e.ctrlKey) {
                        boxZoomActive = true;
                        boxZoomStartX = e.clientX - rect.left;
                        boxZoomStartY = e.clientY - rect.top;
                        boxZoomEndX = boxZoomStartX;
                        boxZoomEndY = boxZoomStartY;
                        canvas.style.cursor = 'crosshair';
                        e.preventDefault();
                        return;
                    }

                    // Left click = start timer for box zoom (hold 200ms to activate)
                    if (e.button === 0 && !e.altKey) {
                        const startX = e.clientX - rect.left;
                        const startY = e.clientY - rect.top;
                        boxZoomTimer = setTimeout(() => {
                            boxZoomActive = true;
                            boxZoomStartX = startX;
                            boxZoomStartY = startY;
                            boxZoomEndX = startX;
                            boxZoomEndY = startY;
                            canvas.style.cursor = 'crosshair';
                        }, 200); // 200ms hold to start box zoom
                    }

                    // Middle click or Alt+Left click = Pan
                    if (e.button === 1 || (e.button === 0 && e.altKey)) {
                        if (boxZoomTimer) { clearTimeout(boxZoomTimer); boxZoomTimer = null; }
                        canvasDragging = true;
                        canvasLastX = e.clientX;
                        canvasLastY = e.clientY;
                        canvas.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                });

                canvas.addEventListener('mouseup', (e) => {
                    // Clear box zoom timer if quick click
                    if (boxZoomTimer) {
                        clearTimeout(boxZoomTimer);
                        boxZoomTimer = null;
                    }

                    // Finish box zoom
                    if (boxZoomActive) {
                        boxZoomActive = false;
                        canvas.style.cursor = 'default';

                        // Calculate box dimensions
                        const x1 = Math.min(boxZoomStartX, boxZoomEndX);
                        const y1 = Math.min(boxZoomStartY, boxZoomEndY);
                        const x2 = Math.max(boxZoomStartX, boxZoomEndX);
                        const y2 = Math.max(boxZoomStartY, boxZoomEndY);
                        const boxW = x2 - x1;
                        const boxH = y2 - y1;

                        // Only zoom if box is reasonable size (min 20px)
                        if (boxW > 20 && boxH > 20) {
                            // Convert screen coords to world coords (before zoom)
                            const worldX1 = (x1 - canvasPanX) / canvasZoom;
                            const worldY1 = (y1 - canvasPanY) / canvasZoom;
                            const worldX2 = (x2 - canvasPanX) / canvasZoom;
                            const worldY2 = (y2 - canvasPanY) / canvasZoom;
                            const worldW = worldX2 - worldX1;
                            const worldH = worldY2 - worldY1;

                            // Calculate new zoom to fit box
                            const canvasW = canvas.width;
                            const canvasH = canvas.height;
                            const zoomX = canvasW / worldW;
                            const zoomY = canvasH / worldH;
                            const newZoom = Math.min(zoomX, zoomY, 5) * 0.9; // Max 5x, 90% margin

                            // Center the box
                            const worldCenterX = (worldX1 + worldX2) / 2;
                            const worldCenterY = (worldY1 + worldY2) / 2;

                            canvasZoom = Math.max(0.5, newZoom);
                            canvasPanX = canvasW / 2 - worldCenterX * canvasZoom;
                            canvasPanY = canvasH / 2 - worldCenterY * canvasZoom;

                            renderCanvas();
                        }
                        return;
                    }

                    canvasDragging = false;
                    canvas.style.cursor = 'default';
                });

                canvas.addEventListener('mouseleave', () => {
                    if (boxZoomTimer) { clearTimeout(boxZoomTimer); boxZoomTimer = null; }
                    canvasDragging = false;
                    boxZoomActive = false;
                    canvas.style.cursor = 'default';
                    highlightedSpanIndex = -1;
                    renderCanvas();
                    renderTable();
                });

                // Wheel to zoom
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    const newZoom = Math.max(0.5, Math.min(5, canvasZoom * delta));
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    canvasPanX = mouseX - (mouseX - canvasPanX) * (newZoom / canvasZoom);
                    canvasPanY = mouseY - (mouseY - canvasPanY) * (newZoom / canvasZoom);
                    canvasZoom = newZoom;
                    renderCanvas();
                }, { passive: false });

                // Double click: label edit (priority) or reset view
                canvas.addEventListener('dblclick', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left - canvasPanX) / canvasZoom;
                    const y = (e.clientY - rect.top - canvasPanY) / canvasZoom;
                    for (let i = 0; i < rebarLabelBounds.length; i++) {
                        const lb = rebarLabelBounds[i];
                        if (x >= lb.x && x <= lb.x + lb.width && y >= lb.y && y <= lb.y + lb.height) {
                            startInlineLabelEdit(lb);
                            return;
                        }
                    }

                    canvasZoom = 1.0;
                    canvasPanX = 0;
                    canvasPanY = 0;
                    renderCanvas();
                    centerCanvas();
                });

                console.log('Canvas interaction system initialized');
            }

            // Handle error mode (from C# when data too large or serialization failed)
            if (data.mode === 'error') {
                const canvas = document.getElementById('beamCanvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 600;
                ctx.fillStyle = '#fef2f2';
                ctx.fillRect(0, 0, 600, 360);
                ctx.fillStyle = '#dc2626';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('‚ö†Ô∏è L·ªói kh·ªüi t·∫°o d·ªØ li·ªáu', 300, 140);
                ctx.font = '12px sans-serif';
                ctx.fillStyle = '#b91c1c';
                ctx.fillText(data.error || 'Unknown error', 300, 170);
                ctx.fillStyle = '#64748b';
                ctx.fillText('Vui l√≤ng ch·ªçn √≠t ƒë·ªëi t∆∞·ª£ng h∆°n ho·∫∑c ki·ªÉm tra d·ªØ li·ªáu.', 300, 200);
                document.getElementById('groupSelect').style.display = 'none';
                console.error('Data error:', data.error);
                return;
            }

            // Handle view mode: 'groups' vs 'single'
            if (data.mode === 'single' || !data.groups || data.groups.length === 0) {
                // Single beam mode - show message in canvas
                const canvas = document.getElementById('beamCanvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 600;
                ctx.fillStyle = '#f8fafc';
                ctx.fillRect(0, 0, 600, 360);
                ctx.fillStyle = '#64748b';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('üì¶ D·∫ßm ƒë∆°n ch∆∞a ƒë∆∞·ª£c gom nh√≥m', 300, 150);
                ctx.font = '12px sans-serif';
                ctx.fillStyle = '#94a3b8';
                ctx.fillText('S·ª≠ d·ª•ng l·ªánh DTS_REBAR_GROUP ƒë·ªÉ gom d·∫ßm v√†o nh√≥m', 300, 180);
                ctx.fillText('ho·∫∑c ch·ªçn ph·∫ßn t·ª≠ thu·ªôc nh√≥m ƒë·ªÉ xem', 300, 200);

                // Hide group controls
                document.getElementById('groupSelect').style.display = 'none';
                console.log('Single beam mode - no groups to display');
                return;
            }

            populateGroupSelect();
            if (data.groups && data.groups.length > 0) {
                loadGroup(0);
            }
        }

        function populateGroupSelect() {
            const sel = document.getElementById('groupSelect');
            sel.innerHTML = '';
            if (!data.groups) return;
            data.groups.forEach((g, i) => {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = `${g.GroupName || 'Group ' + (i + 1)} (${g.Spans?.length || 0} nh·ªãp)`;
                sel.appendChild(opt);
            });
        }

        function loadGroup(index) {
            currentGroupIndex = parseInt(index);
            currentGroup = data.groups[currentGroupIndex];
            document.getElementById('groupSelect').value = currentGroupIndex;

            selectedOptionKey = currentGroup?.SelectedDesign ? 'locked' : String(currentGroup?.SelectedBackboneIndex || 0);

            populateOptionSelect();

            // Apply selected option to spans (populate table with rebar data)
            const opt = getSelectedOption();
            if (opt) applyOptionToSpans(opt);

            // Reset zoom/pan and center view
            canvasZoom = 1.0;
            canvasPanX = 0;
            canvasPanY = 0;

            renderCanvas();
            centerCanvas(); // Center after first render
            renderTable();
            updateMetrics();
            updateGroupInfo();
            loadMaterialSelects();
            updateLockStatus();

            // Initialize history for this group
            Beam.History.clear();
            Beam.History.push();

            // Restore locked snapshot if design is locked
            if (currentGroup?.SelectedDesign) {
                lockedSnapshot = Beam.History.snapshot();
            }
        }

        // Center canvas viewport on content
        function centerCanvas() {
            const canvas = document.getElementById('beamCanvas');
            if (!canvas || spanBounds.length === 0) return;

            // Calculate content bounds
            const minX = Math.min(...spanBounds.map(b => b.x));
            const maxX = Math.max(...spanBounds.map(b => b.x + b.width));
            const minY = Math.min(...spanBounds.map(b => b.y));
            const maxY = Math.max(...spanBounds.map(b => b.y + b.height));

            const contentW = maxX - minX;
            const contentH = maxY - minY;
            const contentCenterX = (minX + maxX) / 2;
            const contentCenterY = (minY + maxY) / 2;

            // Center content only (DO NOT change zoom). This keeps each span's visual length stable.
            canvasPanX = canvas.width / 2 - contentCenterX * canvasZoom;
            canvasPanY = canvas.height / 2 - contentCenterY * canvasZoom;

            renderCanvas();
            updateZoomIndicator();
        }

        function updateZoomIndicator() {
            const el = document.getElementById('zoomIndicator');
            if (el) el.textContent = Math.round(canvasZoom * 100) + '%';
        }

        function startInlineLabelEdit(label) {
            if (!label || !currentGroup?.Spans?.[label.spanIndex]) return;
            if (!labelEditorEl) {
                // Fallback to prompt-based edit if overlay couldn't be created
                const span = currentGroup.Spans[label.spanIndex];
                if (label.type === 'Stirrup' || label.type === 'WebBar') {
                    const idx = Number.isFinite(label.pos) ? label.pos : 0;
                    const isStirrup = label.type === 'Stirrup';
                    const currentVal = (isStirrup ? (span?.Stirrup?.[idx] || '') : (span?.WebBar?.[idx] || '')).toString();
                    const title = `${isStirrup ? 'ƒêAI' : 'S∆Ø·ªúN'} - Nh·ªãp ${span.SpanId || (label.spanIndex + 1)} (${idx === 0 ? 'L1' : (idx === 1 ? 'Gi·ªØa' : 'L2')})`;
                    const nextVal = prompt(title, currentVal);
                    if (nextVal === null) return;
                    if (isStirrup) updateStirrup(label.spanIndex, idx, nextVal);
                    else updateWebBar(label.spanIndex, idx, nextVal);
                    maybeRenderTable();
                    return;
                }
                const layer = Number.isFinite(label.layer) ? label.layer : 0;
                const pos = Number.isFinite(label.pos) ? label.pos : 2;
                const currentVal = getLayerRebarText(span, label.type, layer, pos);
                const posName = (pos === 0 ? 'Tr√°i' : (pos === 4 ? 'Ph·∫£i' : 'Gi·ªØa'));
                const title = `${label.type === 'Top' ? 'TH√âP TR√äN' : 'TH√âP D∆Ø·ªöI'} - Nh·ªãp ${span.SpanId || (label.spanIndex + 1)} (Layer ${layer + 1}, ${posName})`;
                const nextVal = prompt(title, currentVal);
                if (nextVal === null) return;
                updateLayerRebar(label.spanIndex, label.type, layer, pos, nextVal);
                maybeRenderTable();
                return;
            }

            activeLabelEdit = label;

            const canvas = document.getElementById('beamCanvas');
            const container = document.getElementById('canvasContainer');
            if (!canvas || !container) return;

            const rect = canvas.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();

            // Convert label world coords to canvas screen coords
            const sx = label.x * canvasZoom + canvasPanX;
            const sy = label.y * canvasZoom + canvasPanY;
            const sw = label.width * canvasZoom;
            const sh = label.height * canvasZoom;

            // Position relative to container
            const left = (rect.left - containerRect.left) + sx;
            const top = (rect.top - containerRect.top) + sy;

            labelEditorEl.style.left = Math.max(0, left) + 'px';
            labelEditorEl.style.top = Math.max(0, top) + 'px';
            labelEditorEl.style.width = Math.max(60, sw) + 'px';
            labelEditorEl.style.height = Math.max(18, sh) + 'px';

            const span = currentGroup.Spans[label.spanIndex];
            if (label.type === 'Stirrup') {
                const idx = Number.isFinite(label.pos) ? label.pos : 0;
                labelEditorEl.value = (span?.Stirrup?.[idx] || '').toString();
            } else if (label.type === 'WebBar') {
                const idx = Number.isFinite(label.pos) ? label.pos : 0;
                labelEditorEl.value = (span?.WebBar?.[idx] || '').toString();
            } else {
                const layer = Number.isFinite(label.layer) ? label.layer : 0;
                const pos = Number.isFinite(label.pos) ? label.pos : 2;
                labelEditorEl.value = getLayerRebarText(span, label.type, layer, pos);
            }
            labelEditorEl.classList.remove('hidden');
            labelEditorEl.focus();
            labelEditorEl.select();
        }

        function commitInlineLabelEdit() {
            if (!activeLabelEdit || !labelEditorEl) {
                hideInlineLabelEditor();
                return;
            }
            const nextVal = labelEditorEl.value;
            if (activeLabelEdit.type === 'Stirrup') {
                const idx = Number.isFinite(activeLabelEdit.pos) ? activeLabelEdit.pos : 0;
                updateStirrup(activeLabelEdit.spanIndex, idx, nextVal);
                maybeRenderTable();
                renderCanvas();
                hideInlineLabelEditor();
                return;
            }
            if (activeLabelEdit.type === 'WebBar') {
                const idx = Number.isFinite(activeLabelEdit.pos) ? activeLabelEdit.pos : 0;
                updateWebBar(activeLabelEdit.spanIndex, idx, nextVal);
                maybeRenderTable();
                renderCanvas();
                hideInlineLabelEditor();
                return;
            }
            const layer = Number.isFinite(activeLabelEdit.layer) ? activeLabelEdit.layer : 0;
            const pos = Number.isFinite(activeLabelEdit.pos) ? activeLabelEdit.pos : 2;
            updateLayerRebar(activeLabelEdit.spanIndex, activeLabelEdit.type, layer, pos, nextVal);
            maybeRenderTable();
            renderCanvas(); // Ensure canvas refreshes to clear old labels
            hideInlineLabelEditor();
        }

        function cancelInlineLabelEdit() {
            hideInlineLabelEditor();
        }

        function hideInlineLabelEditor() {
            activeLabelEdit = null;
            if (!labelEditorEl) return;
            labelEditorEl.classList.add('hidden');
            labelEditorEl.value = '';
        }

        function getLayerRebarText(span, type, layer, pos) {
            if (!span) return '';
            const arr = (type === 'Top') ? span.TopRebar : span.BotRebar;
            const layerArr = arr?.[layer] || [];
            const v = layerArr?.[pos];
            return (v === undefined || v === null) ? '' : String(v);
        }

        // Backward compatible helper (kept for other UI pieces)
        function getSpanRebarText(span, type) {
            const t = getLayerRebarText(span, type, 0, 2);
            if (t && t.trim().length > 0) return t;
            const l = getLayerRebarText(span, type, 0, 0);
            if (l && l.trim().length > 0) return l;
            const r = getLayerRebarText(span, type, 0, 4);
            return r;
        }

        function drawEditableLabel(ctx, text, centerX, centerY, color, meta) {
            const raw = (text === undefined || text === null) ? '' : String(text);
            const t = raw.trim();
            const isEmpty = t.length === 0;
            ctx.save();
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const padX = 4;
            const showText = isEmpty ? '' : t;
            const w = Math.max(24, ctx.measureText(showText || '00').width + padX * 2);
            const h = 14;
            const x = centerX - w / 2;
            const y = centerY - h / 2;

            // Background pill
            ctx.fillStyle = isEmpty ? 'rgba(255,255,255,0.55)' : 'rgba(255,255,255,0.85)';
            ctx.strokeStyle = isEmpty ? 'rgba(203,213,225,0.9)' : 'rgba(148,163,184,0.9)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            const r = 6;
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            if (!isEmpty) {
                ctx.fillStyle = color;
                ctx.fillText(showText, centerX, centerY);
            }
            ctx.restore();

            rebarLabelBounds.push({ x, y, width: w, height: h, ...meta });
        }

        function drawInfoLabel(ctx, text, centerX, centerY, color) {
            const raw = (text === undefined || text === null) ? '' : String(text);
            const t = raw.trim();
            if (t.length === 0) return;

            ctx.save();
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const padX = 4;
            const w = Math.max(26, ctx.measureText(t).width + padX * 2);
            const h = 14;
            const x = centerX - w / 2;
            const y = centerY - h / 2;

            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.strokeStyle = 'rgba(148,163,184,0.9)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            const r = 6;
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = color;
            ctx.fillText(t, centerX, centerY);
            ctx.restore();
        }

        // ===== UNIFIED ROUNDING: <1 ‚Üí 4 decimals, ‚â•1 ‚Üí 2 decimals =====
        function formatRebarValue(n) {
            if (!Number.isFinite(n) || n <= 0) return '-';
            if (n < 1) return n.toFixed(4);
            return n.toFixed(2);
        }

        // Calculate As_prov from rebar string (e.g., "3D20" ‚Üí 9.42 cm¬≤)
        function parseRebarArea(rebarStr) {
            if (!rebarStr || typeof rebarStr !== 'string') return 0;
            let total = 0;
            // Split by '+' for combined bars (e.g., "2D16+2D18")
            const parts = rebarStr.split('+');
            for (const part of parts) {
                const match = part.trim().match(/(\d+)D(\d+)/i);
                if (match) {
                    const count = parseInt(match[1]) || 0;
                    const dia = parseInt(match[2]) || 0;
                    total += count * Math.PI * (dia / 10) * (dia / 10) / 4; // cm¬≤
                }
            }
            return total;
        }

        // Get As_prov/As_req text for display (replaces getAsReqText)
        function getAsRatioText(span, type, posName) {
            // As_req from XData
            const reqArr = (type === 'Top') ? span?.As_Top : span?.As_Bot;
            const idx = (posName === 'L') ? 0 : (posName === 'R' ? 4 : 2);
            const asReq = Number(reqArr?.[idx]) || 0;

            // As_prov from rebar strings
            const rebarArr = (type === 'Top') ? span?.TopRebar : span?.BotRebar;
            const rebarStr = rebarArr?.[0]?.[idx] || ''; // Layer 0, position idx
            const asProv = parseRebarArea(rebarStr);

            // Format display
            const reqText = formatRebarValue(asReq);
            const provText = formatRebarValue(asProv);

            if (asReq <= 0 && asProv <= 0) return '';
            if (asProv > 0 && asReq > 0) return `${provText}/${reqText}`;
            if (asReq > 0) return reqText;
            return provText;
        }

        // Get Stirrup/WebBar requirement text with As_prov/As_req format
        function getShearRatioText(span, provKind, reqKind, idx) {
            // provKind: 'Stirrup' or 'WebBar'
            // reqKind: 'StirrupReq' or 'WebReq'
            const provArr = span?.[provKind];
            const reqArr = span?.[reqKind];

            const provStr = Array.isArray(provArr) ? (provArr[idx] || '') : '';
            const reqVal = Number(Array.isArray(reqArr) ? reqArr[idx] : 0) || 0;

            // For stirrup/web, parse asProv differently (e.g., "D8@150" not bar area)
            // Just show strings as-is with req value
            const reqText = formatRebarValue(reqVal);

            if (provStr && reqVal > 0) return `${provStr} (${reqText})`;
            if (provStr) return provStr;
            if (reqVal > 0) return `req:${reqText}`;
            return '';
        }

        function editCanvasRebarLabel(label) {
            if (labelEditorEl) {
                startInlineLabelEdit(label);
                return;
            }
            if (!label || !currentGroup?.Spans?.[label.spanIndex]) return;
            if (label.type === 'Stirrup') {
                const span = currentGroup.Spans[label.spanIndex];
                const idx = Number.isFinite(label.pos) ? label.pos : 0;
                const currentVal = (span?.Stirrup?.[idx] || '').toString();
                const title = `ƒêAI - Nh·ªãp ${span.SpanId || (label.spanIndex + 1)} (${idx === 0 ? 'L1' : (idx === 1 ? 'Gi·ªØa' : 'L2')})`;
                const nextVal = prompt(title, currentVal);
                if (nextVal === null) return;
                updateStirrup(label.spanIndex, idx, nextVal);
                maybeRenderTable();
                renderCanvas();
                return;
            }
            if (label.type === 'WebBar') {
                const span = currentGroup.Spans[label.spanIndex];
                const idx = Number.isFinite(label.pos) ? label.pos : 0;
                const currentVal = (span?.WebBar?.[idx] || '').toString();
                const title = `S∆Ø·ªúN - Nh·ªãp ${span.SpanId || (label.spanIndex + 1)} (${idx === 0 ? 'L1' : (idx === 1 ? 'Gi·ªØa' : 'L2')})`;
                const nextVal = prompt(title, currentVal);
                if (nextVal === null) return;
                updateWebBar(label.spanIndex, idx, nextVal);
                maybeRenderTable();
                renderCanvas();
                return;
            }
            const span = currentGroup.Spans[label.spanIndex];
            const layer = Number.isFinite(label.layer) ? label.layer : 0;
            const pos = Number.isFinite(label.pos) ? label.pos : 2;
            const currentVal = getLayerRebarText(span, label.type, layer, pos);
            const posName = (pos === 0 ? 'Tr√°i' : (pos === 4 ? 'Ph·∫£i' : 'Gi·ªØa'));
            const title = `${label.type === 'Top' ? 'TH√âP TR√äN' : 'TH√âP D∆Ø·ªöI'} - Nh·ªãp ${span.SpanId || (label.spanIndex + 1)} (Layer ${layer + 1}, ${posName})`;
            const nextVal = prompt(title, currentVal);
            if (nextVal === null) return;
            updateLayerRebar(label.spanIndex, label.type, layer, pos, nextVal);
            maybeRenderTable();
        }

        function prevGroup() { if (currentGroupIndex > 0) loadGroup(currentGroupIndex - 1); }
        function nextGroup() { if (currentGroupIndex < data.groups.length - 1) loadGroup(currentGroupIndex + 1); }

        function populateOptionSelect() {
            const sel = document.getElementById('optionSelect');
            sel.innerHTML = '';

            const getOptionScore = (opt) => {
                if (!opt) return Number.NEGATIVE_INFINITY;
                const v = (opt.TotalScore ?? opt.ConstructabilityScore ?? opt.EfficiencyScore);
                const n = Number(v);
                return Number.isFinite(n) ? n : Number.NEGATIVE_INFINITY;
            };

            // DEBUG: Log SelectedDesign status
            console.log('populateOptionSelect:', {
                groupName: currentGroup?.GroupName,
                hasSelectedDesign: !!currentGroup?.SelectedDesign,
                selectedDesign: currentGroup?.SelectedDesign,
                backboneOptionsCount: currentGroup?.BackboneOptions?.length || 0
            });

            // N·∫øu c√≥ SelectedDesign (ƒë√£ ch·ªët), lu√¥n hi·ªÉn th·ªã ƒë·∫ßu ti√™n v·ªõi ‚≠ê
            if (currentGroup?.SelectedDesign) {
                const lockedOpt = document.createElement('option');
                lockedOpt.value = 'locked';
                const isInvalid = currentGroup.SelectedDesign.IsValid === false;
                const designName = currentGroup.SelectedDesign.OptionName || 'Ph∆∞∆°ng √°n ƒë√£ ch·ªët';
                lockedOpt.textContent = `‚≠ê ${designName} ${isInvalid ? '‚ö†Ô∏è THI·∫æU TH√âP' : '(ƒêang ch·ªët)'}`;
                sel.appendChild(lockedOpt);
                console.log('Added locked option:', designName);
            }

            // Ki·ªÉm tra BackboneOptions
            const options = currentGroup?.BackboneOptions || [];

            if (options.length === 0) {
                // Kh√¥ng c√≥ ph∆∞∆°ng √°n t√≠nh to√°n
                const noCalcOpt = document.createElement('option');
                noCalcOpt.value = 'none';
                noCalcOpt.textContent = '‚è≥ Ch∆∞a t√≠nh (Nh·∫•n "T√≠nh th√©p")';
                noCalcOpt.disabled = true;
                sel.appendChild(noCalcOpt);
            } else {
                // Th√™m c√°c ph∆∞∆°ng √°n m√°y ƒë·ªÅ xu·∫•t (sort theo Score gi·∫£m d·∫ßn)
                const ranked = options
                    .map((opt, originalIndex) => ({ opt, originalIndex, score: getOptionScore(opt) }))
                    .sort((a, b) => (b.score - a.score) || (a.originalIndex - b.originalIndex));

                const bestOriginalIndex = ranked.length > 0 ? ranked[0].originalIndex : 0;

                ranked.forEach((r, rankIdx) => {
                    const opt = r.opt;
                    const option = document.createElement('option');
                    option.value = String(r.originalIndex);
                    const score = getOptionScore(opt);
                    const scoreText = Number.isFinite(score) ? ` | Score ${score.toFixed(0)}` : '';
                    const bestTag = (r.originalIndex === bestOriginalIndex) ? ' ‚òÖBest' : '';
                    option.textContent = `#${rankIdx + 1} ${opt.OptionName || ('Option ' + (r.originalIndex + 1))} - D${opt.BackboneDiameter || '?'}${scoreText}${bestTag}`;
                    sel.appendChild(option);
                });
            }

            // Ch·ªçn SelectedDesign n·∫øu c√≥, kh√¥ng th√¨ ch·ªçn theo index
            if (selectedOptionKey == null) {
                selectedOptionKey = currentGroup?.SelectedDesign ? 'locked' : String(currentGroup?.SelectedBackboneIndex || 0);
            }

            // N·∫øu selectedOptionKey kh√¥ng t·ªìn t·∫°i trong dropdown (vd: ch∆∞a t√≠nh), fallback v·ªÅ option ƒë·∫ßu
            const validValues = Array.from(sel.options).map(o => o.value);
            if (selectedOptionKey != null && !validValues.includes(String(selectedOptionKey))) {
                selectedOptionKey = sel.options.length > 0 ? sel.options[0].value : null;
            }
            sel.value = selectedOptionKey ?? '';
        }

        function selectOption(index) {
            selectedOptionKey = String(index);
            if (selectedOptionKey !== 'locked') {
                const parsed = parseInt(selectedOptionKey);
                if (!isNaN(parsed)) currentGroup.SelectedBackboneIndex = parsed;
            }

            // V3.4 FIX: Reset _userEdited so proposal can apply to all spans
            if (currentGroup?.Spans) {
                currentGroup.Spans.forEach(span => span._userEdited = false);
            }

            const opt = getSelectedOption();
            applyOptionToSpans(opt);

            updateMetrics();
            renderCanvas();
            renderTable();
        }

        function getSelectedOption() {
            if (!currentGroup) return null;
            if (selectedOptionKey === 'locked') return currentGroup.SelectedDesign || null;
            const idx = parseInt(selectedOptionKey);
            if (isNaN(idx)) return currentGroup.BackboneOptions?.[0] || null;
            return currentGroup.BackboneOptions?.[idx] || null;
        }

        function applyOptionToSpans(opt) {
            if (!currentGroup?.Spans?.length || !opt) return;

            const backbone = `${opt.BackboneCount_Top}D${opt.BackboneDiameter}`;
            const botBackbone = `${opt.BackboneCount_Bot}D${opt.BackboneDiameter}`;

            // Helper to get reinforcement suffix from solution
            const getReinf = (spanId, pos) => {
                const reinf = opt.Reinforcements;
                if (!reinf) return '';
                const key = `${spanId}_${pos}`;
                const spec = reinf[key];
                if (spec && spec.Count > 0) {
                    return `+${spec.Count}D${spec.Diameter}`;
                }
                return '';
            };

            currentGroup.Spans.forEach(span => {
                // Only update if not manually edited
                if (!span._userEdited) {
                    if (!span.TopRebar) span.TopRebar = [[], [], []];
                    if (!span.BotRebar) span.BotRebar = [[], [], []];

                    const sid = span.SpanId;

                    // TOP: backbone + reinforcement at each position
                    span.TopRebar[0][0] = backbone + getReinf(sid, 'Top_Left');
                    span.TopRebar[0][2] = backbone + getReinf(sid, 'Top_Mid');
                    span.TopRebar[0][4] = backbone + getReinf(sid, 'Top_Right');

                    // BOT: backbone + reinforcement at each position
                    span.BotRebar[0][0] = botBackbone + getReinf(sid, 'Bot_Left');
                    span.BotRebar[0][2] = botBackbone + getReinf(sid, 'Bot_Mid');
                    span.BotRebar[0][4] = botBackbone + getReinf(sid, 'Bot_Right');
                }
            });
        }

        // ===== QUICK CALC (T√≠nh th√©p nhanh) =====
        function quickCalc() {
            if (!currentGroup) return;
            // Send message to C# to run rebar calculation
            window.chrome.webview?.postMessage('QUICK_CALC|' + currentGroupIndex);
        }

        // Called from C# after Quick Calc finished
        function onGroupUpdated(groupIndex, groupJson) {
            try {
                const updated = (typeof groupJson === 'string') ? JSON.parse(groupJson) : groupJson;
                if (!data.groups || groupIndex < 0 || groupIndex >= data.groups.length) return;
                data.groups[groupIndex] = updated;

                if (currentGroupIndex === groupIndex) {
                    currentGroup = updated;
                    selectedOptionKey = currentGroup?.SelectedDesign ? 'locked' : String(currentGroup?.SelectedBackboneIndex || 0);
                    populateOptionSelect();
                    updateLockStatus();
                    updateGroupInfo();
                    updateMetrics();
                    renderCanvas();
                    renderTable();

                    // Reinitialize history for updated group
                    Beam.History.clear();
                    Beam.History.push();
                }
            } catch (e) {
                console.log('onGroupUpdated error', e);
            }
        }

        // NOTE: lockDesign, unlockDesign, toggleLock, restoreLockedDesign, updateLockStatus 
        // are now defined in the Beam.History section at the top of the script

        // Wrapper ƒë·ªÉ g·ªçi khi b·∫•t k·ª≥ edit n√†o x·∫£y ra
        function onManualEdit(spanIndex, field, value) {
            // Th·ª±c hi·ªán edit...
            console.log(`Manual edit: span ${spanIndex}, ${field} = ${value}`);

            // Auto-lock
            autoLockOnEdit();

            // Update UI
            renderCanvas();
            renderTable();
        }

        function updateGroupInfo() {
            const info = document.getElementById('groupInfo');
            if (!currentGroup) { info.textContent = '-'; return; }
            const totalL = currentGroup.TotalLength?.toFixed(2) || '-';
            const beamCount = currentGroup.EntityHandles?.length || 0;
            info.textContent = `T·ªïng: ${totalL}m | ${beamCount} d·∫ßm | ${currentGroup.Spans?.length || 0} nh·ªãp`;
        }

        function updateMetrics() {
            if (!currentGroup) return;
            const opt = getSelectedOption() || currentGroup.BackboneOptions?.[currentGroup.SelectedBackboneIndex || 0];
            if (opt) {
                document.getElementById('metricBackbone').textContent = opt.OptionName || '-';
                document.getElementById('metricAs').textContent = `${opt.As_Backbone_Top?.toFixed(1) || 0} cm¬≤`;
                document.getElementById('metricWaste').textContent = `${opt.WastePercentage?.toFixed(1) || 0}%`;
                document.getElementById('metricWeight').textContent = `${opt.TotalSteelWeight?.toFixed(0) || 0} kg`;
                const scoreVal = (opt.TotalScore ?? opt.ConstructabilityScore ?? opt.EfficiencyScore);
                document.getElementById('metricScore').textContent = (scoreVal !== undefined && scoreVal !== null)
                    ? Number(scoreVal).toFixed(0)
                    : '-';
            }

            // Warnings
            const warnings = [];
            if (currentGroup.HasStepChange) warnings.push({ icon: '‚ö†Ô∏è', text: 'Gi·∫≠t c·∫•p', cls: 'bg-amber-100 text-amber-700' });
            if (currentGroup.RequiresSplice) warnings.push({ icon: 'üîó', text: 'N·ªëi th√©p', cls: 'bg-blue-100 text-blue-700' });
            if (currentGroup.HasConsole) warnings.push({ icon: 'üìê', text: 'Console', cls: 'bg-purple-100 text-purple-700' });

            document.getElementById('warningsContainer').innerHTML = warnings
                .map(w => `<span class="px-2 py-0.5 rounded text-[10px] font-bold ${w.cls}">${w.icon} ${w.text}</span>`).join('');
        }

        // ============ CANVAS RENDERING (RELATIVE LENGTHS) ============
        function renderCanvas() {
            const canvas = document.getElementById('beamCanvas');
            const ctx = canvas.getContext('2d');

            if (!currentGroup?.Spans?.length) {
                canvas.width = 400;
                ctx.fillStyle = '#f8fafc';
                ctx.fillRect(0, 0, 400, 180);
                ctx.fillStyle = '#94a3b8';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Kh√¥ng c√≥ d·ªØ li·ªáu nh·ªãp', 200, 90);
                return;
            }

            spanBounds = [];
            rebarLabelBounds = [];
            const spans = currentGroup.Spans;

            // FIXED SPAN WIDTHS: all spans have the SAME visual width (independent of span count)
            const SUPPORT_GAP = 15; // Gap for support symbols
            const equalSpanWidth = FIXED_SPAN_WIDTH;

            let totalWidth = CANVAS_PADDING * 2;
            const spanWidths = spans.map(() => {
                totalWidth += equalSpanWidth + SUPPORT_GAP;
                return equalSpanWidth;
            });

            // Use canvas size from resizeCanvas (don't override here)
            // Clear with light background (full canvas, before transform)
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply zoom and pan transform
            ctx.save();
            ctx.translate(canvasPanX, canvasPanY);
            ctx.scale(canvasZoom, canvasZoom);

            let x = CANVAS_PADDING;
            // Give more vertical room for outside required labels
            const beamY = 90;

            // Draw beams
            spans.forEach((span, i) => {
                const w = spanWidths[i];

                // Support symbol
                if (i === 0) {
                    drawSupport(ctx, x, beamY);
                    x += 5;
                }

                // Store bounds
                spanBounds.push({ x, y: beamY, width: w, height: BEAM_HEIGHT, index: i });

                // Draw beam segment
                const isHighlighted = i === highlightedSpanIndex;
                ctx.fillStyle = isHighlighted ? '#dbeafe' : '#e2e8f0';
                ctx.strokeStyle = isHighlighted ? '#3b82f6' : '#64748b';
                ctx.lineWidth = isHighlighted ? 2 : 1;
                ctx.fillRect(x, beamY, w, BEAM_HEIGHT);
                ctx.strokeRect(x, beamY, w, BEAM_HEIGHT);

                // Draw rebar lines
                drawRebarLines(ctx, x, beamY, w, span);

                const labelXs = [x + w * 0.20, x + w * 0.50, x + w * 0.80];
                const labelPos = [0, 2, 4];

                if (canvasMode === 'long') {
                    // Editable long rebar labels: backbone (layer 0) + reinforcement layers (1..MaxLayers-1)
                    const maxLayers = data.settings?.MaxLayers || 2;

                    // Backbone label rows (inside beam)
                    const topBaseY = beamY + 12;
                    const botBaseY = beamY + BEAM_HEIGHT - 12;
                    for (let li = 0; li < labelXs.length; li++) {
                        const cx = labelXs[li];
                        const pos = labelPos[li];
                        drawEditableLabel(ctx, getLayerRebarText(span, 'Top', 0, pos), cx, topBaseY, '#ef4444', { spanIndex: i, type: 'Top', layer: 0, pos });
                        drawEditableLabel(ctx, getLayerRebarText(span, 'Bot', 0, pos), cx, botBaseY, '#3b82f6', { spanIndex: i, type: 'Bot', layer: 0, pos });
                    }

                    // Reinforcement layers (gia c∆∞·ªùng) - per span
                    // Stack inward to avoid collisions; typically MaxLayers=2 so only one extra row.
                    for (let layer = 1; layer < maxLayers; layer++) {
                        const dy = 14 * layer;
                        const topY = topBaseY + dy;
                        const botY = botBaseY - dy;
                        for (let li = 0; li < labelXs.length; li++) {
                            const cx = labelXs[li];
                            const pos = labelPos[li];
                            drawEditableLabel(ctx, getLayerRebarText(span, 'Top', layer, pos), cx, topY, '#f97316', { spanIndex: i, type: 'Top', layer, pos });
                            drawEditableLabel(ctx, getLayerRebarText(span, 'Bot', layer, pos), cx, botY, '#0ea5e9', { spanIndex: i, type: 'Bot', layer, pos });
                        }
                    }

                    // Required labels (outside beam): 6 positions
                    const reqTopY = beamY - 24;
                    const reqBotY = beamY + BEAM_HEIGHT + 24;
                    const posNames = ['L', 'M', 'R'];
                    for (let li = 0; li < labelXs.length; li++) {
                        const cx = labelXs[li];
                        const pn = posNames[li];
                        drawInfoLabel(ctx, getAsRatioText(span, 'Top', pn), cx, reqTopY, '#b91c1c');
                        drawInfoLabel(ctx, getAsRatioText(span, 'Bot', pn), cx, reqBotY, '#1d4ed8');
                    }
                } else if (canvasMode === 'shear') {
                    // Shear-web mode: editable stirrup labels (provided) outside beam
                    const stirrupY = beamY + BEAM_HEIGHT + 22;
                    const webY = stirrupY + 18;
                    const stirrup = span.Stirrup || [];
                    const webBar = span.WebBar || [];
                    const stirrupXs = [x + w * 0.125, x + w * 0.50, x + w * 0.875];
                    for (let si = 0; si < stirrupXs.length; si++) {
                        drawEditableLabel(
                            ctx,
                            (stirrup[si] || ''),
                            stirrupXs[si],
                            stirrupY,
                            '#475569',
                            { spanIndex: i, type: 'Stirrup', layer: 0, pos: si }
                        );
                        drawEditableLabel(
                            ctx,
                            (webBar[si] || ''),
                            stirrupXs[si],
                            webY,
                            '#0f766e',
                            { spanIndex: i, type: 'WebBar', layer: 0, pos: si }
                        );
                    }

                    // Optional required labels (outside beam): up to 6 positions if data exists
                    // - StirrupReq at top
                    // - WebReq at bottom
                    const reqTopY = beamY - 24;
                    const reqBotY = webY + 36;
                    for (let si = 0; si < stirrupXs.length; si++) {
                        drawInfoLabel(ctx, getShearRatioText(span, 'Stirrup', 'StirrupReq', si), stirrupXs[si], reqTopY, '#b45309');
                        drawInfoLabel(ctx, getShearRatioText(span, 'WebBar', 'WebReq', si), stirrupXs[si], reqBotY, '#0f766e');
                    }
                }

                // Span label
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(span.SpanId, x + w / 2, beamY + BEAM_HEIGHT / 2 + 4);

                // Removed size/dimension labels to free space for required labels

                x += w;

                // Support between spans
                drawSupport(ctx, x, beamY);
                x += 15;
            });

            // Restore canvas transform
            ctx.restore();

            // Draw box zoom selection rectangle (after restore, in screen coords)
            if (boxZoomActive) {
                const x1 = Math.min(boxZoomStartX, boxZoomEndX);
                const y1 = Math.min(boxZoomStartY, boxZoomEndY);
                const w = Math.abs(boxZoomEndX - boxZoomStartX);
                const h = Math.abs(boxZoomEndY - boxZoomStartY);

                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);
                ctx.strokeRect(x1, y1, w, h);
                ctx.setLineDash([]);

                // Fill with transparent blue
                ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
                ctx.fillRect(x1, y1, w, h);
            }

            // Update zoom indicator if exists
            const zoomIndicator = document.getElementById('zoomIndicator');
            if (zoomIndicator) {
                zoomIndicator.textContent = `${Math.round(canvasZoom * 100)}%`;
            }

            // Scroll to highlighted span (only when not interacting)
            if (!canvasDragging && !boxZoomActive && highlightedSpanIndex >= 0) {
                const bound = spanBounds.find(b => b.index === highlightedSpanIndex);
                const container = document.getElementById('canvasContainer');
                if (bound && container) {
                    const scrollTarget = (bound.x * canvasZoom + canvasPanX) - container.clientWidth / 2 + (bound.width * canvasZoom) / 2;
                    container.scrollTo({ left: scrollTarget, behavior: 'smooth' });
                }
            }
        }

        function drawSupport(ctx, x, y) {
            ctx.fillStyle = '#475569';
            ctx.beginPath();
            ctx.moveTo(x, y + BEAM_HEIGHT);
            ctx.lineTo(x - 6, y + BEAM_HEIGHT + 15);
            ctx.lineTo(x + 6, y + BEAM_HEIGHT + 15);
            ctx.closePath();
            ctx.fill();
        }

        function drawRebarLines(ctx, x, y, w, span) {
            const topY = y + 12;
            const botY = y + BEAM_HEIGHT - 12;
            const midX = x + w / 2;

            // Draw backbone (continuous lines)
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);

            // Top backbone (red)
            ctx.beginPath();
            ctx.moveTo(x + 3, topY);
            ctx.lineTo(x + w - 3, topY);
            ctx.stroke();

            // Bottom backbone (blue)
            ctx.strokeStyle = '#3b82f6';
            ctx.beginPath();
            ctx.moveTo(x + 3, botY);
            ctx.lineTo(x + w - 3, botY);
            ctx.stroke();

            // MODE-SPECIFIC RENDERING
            if (canvasMode === 'long') {
                // LONG REBAR MODE - Editable labels are already drawn above via drawEditableLabel().
                // No additional rendering needed here to avoid duplicate labels.
            } else if (canvasMode === 'shear') {
                // SHEAR/WEB BAR MODE - Show stirrup layout as vertical lines
                const stirrups = span.Stirrup || [];
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = 1;
                ctx.setLineDash([]);

                // Draw vertical stirrup lines across span (simplified representation)
                const zones = [
                    { start: 0, end: 0.25, spacing: stirrups[0] },   // L1 zone
                    { start: 0.25, end: 0.75, spacing: stirrups[1] }, // Mid zone
                    { start: 0.75, end: 1.0, spacing: stirrups[2] }   // L2 zone
                ];

                zones.forEach(zone => {
                    const spacing = zone.spacing ? parseFloat(zone.spacing.match(/a(\d+)/)?.[1] || '150') : 150;
                    const dia = zone.spacing ? parseFloat(zone.spacing.match(/d(\d+)/)?.[1] || '8') : 8;
                    const zoneStart = x + w * zone.start;
                    const zoneEnd = x + w * zone.end;
                    const zoneWidth = zoneEnd - zoneStart;
                    const numStirrups = Math.max(2, Math.floor(zoneWidth / (spacing / 10))); // Scale for display

                    ctx.strokeStyle = dia >= 10 ? '#475569' : '#94a3b8';
                    ctx.lineWidth = dia >= 10 ? 1.5 : 1;

                    for (let i = 0; i <= numStirrups; i++) {
                        const sx = zoneStart + (zoneWidth / numStirrups) * i;
                        ctx.beginPath();
                        ctx.moveTo(sx, topY - 2);
                        ctx.lineTo(sx, botY + 2);
                        ctx.stroke();
                    }
                });

                // Stirrup text labels are drawn as editable labels in renderCanvas() (canvas-first).
            } else {
                // SECTION mode - draw addon bars (dashed) like before
                const topRebar = span.TopRebar?.[0];
                const botRebar = span.BotRebar?.[0];

                ctx.setLineDash([4, 2]);
                ctx.lineWidth = 1.5;

                if (topRebar?.[0]) {
                    ctx.strokeStyle = '#f97316';
                    ctx.beginPath();
                    ctx.moveTo(x + 3, topY + 4);
                    ctx.lineTo(x + w * 0.3, topY + 4);
                    ctx.stroke();
                }
                if (topRebar?.[4]) {
                    ctx.strokeStyle = '#f97316';
                    ctx.beginPath();
                    ctx.moveTo(x + w * 0.7, topY + 4);
                    ctx.lineTo(x + w - 3, topY + 4);
                    ctx.stroke();
                }
            }

            ctx.setLineDash([]);
        }

        // ============ TABLE RENDERING (LAYER-BASED) ============
        function renderTable() {
            const tbody = document.getElementById('spanTableBody');
            tbody.innerHTML = '';

            if (!currentGroup?.Spans) return;

            // Get MaxLayers from settings (default 2)
            const maxLayers = data.settings?.MaxLayers || 2;

            currentGroup.Spans.forEach((span, spanIdx) => {
                // Create n rows for each span (n = maxLayers)
                for (let layer = 0; layer < maxLayers; layer++) {
                    const tr = document.createElement('tr');
                    const isFirstRow = layer === 0;
                    tr.className = `span-row border-b border-slate-100 ${span.IsActive === false ? 'opacity-40' : ''} ${spanIdx === highlightedSpanIndex ? 'highlighted' : ''}`;
                    tr.dataset.spanIndex = spanIdx;

                    // Mouse events for sync
                    tr.addEventListener('mouseenter', () => highlightSpan(spanIdx));
                    tr.addEventListener('mouseleave', clearHighlight);

                    // First row shows span info with rowspan, other rows only show layer data
                    if (isFirstRow) {
                        tr.innerHTML = `
                            <td class="p-1 font-medium" rowspan="${maxLayers}">${span.SpanId}</td>
                            <td class="p-1 text-center" rowspan="${maxLayers}">
                                <input type="checkbox" ${span.IsActive !== false ? 'checked' : ''} 
                                    onchange="toggleSpanActive(${spanIdx}, this.checked)" class="w-3 h-3">
                            </td>
                            <td class="p-1 text-center text-slate-600 text-[10px]" rowspan="${maxLayers}">${(span.Length || 0).toFixed(2)}</td>
                            <td class="p-1 text-center text-slate-500 text-[10px]" rowspan="${maxLayers}">${span.Width || 0}√ó${span.Height || 0}</td>
                            <td class="p-1 text-center text-xs font-bold ${layer === 0 ? 'bg-slate-200' : 'bg-slate-100'}">${layer + 1}</td>
                            ${renderLayerRebarInputs(spanIdx, span, 'Top', layer)}
                            ${renderLayerRebarInputs(spanIdx, span, 'Bot', layer)}
                            ${renderStirrupInputs(spanIdx, span, maxLayers)}
                            <td class="p-1" rowspan="${maxLayers}">
                                <input type="text" value="${span.SideBar || ''}" 
                                    onchange="updateSideBar(${spanIdx}, this.value)"
                                    placeholder="2D12"
                                    class="w-12 border border-slate-200 rounded px-0.5 py-0.5 text-center text-[10px]">
                            </td>
                        `;
                    } else {
                        tr.innerHTML = `
                            <td class="p-1 text-center text-xs font-bold ${layer === 0 ? 'bg-slate-200' : 'bg-slate-100'}">${layer + 1}</td>
                            ${renderLayerRebarInputs(spanIdx, span, 'Top', layer)}
                            ${renderLayerRebarInputs(spanIdx, span, 'Bot', layer)}
                        `;
                    }

                    tbody.appendChild(tr);
                }
            });
        }

        // Render rebar inputs for a specific layer
        function renderLayerRebarInputs(spanIndex, span, type, layer) {
            const rebarData = type === 'Top' ? span.TopRebar : span.BotRebar;
            const layerData = rebarData?.[layer] || [];
            const bgClass = type === 'Top' ? 'bg-red-50' : 'bg-blue-50';
            let html = '';
            const positions = [0, 2, 4]; // Left(G·ªëi T), Mid(Gi·ªØa), Right(G·ªëi P)
            const posNames = ['L', 'M', 'R'];

            positions.forEach((pos, idx) => {
                const val = layerData[pos] || '';
                const reqArr = (type === 'Top') ? span.As_Top : span.As_Bot;
                const reqIdx = (pos === 0) ? 0 : (pos === 4 ? 4 : 2);
                const asReq = Array.isArray(reqArr) ? (Number(reqArr[reqIdx]) || 0) : 0;

                // V3.4 FIX: Calculate isUnder based on parseRebarArea vs As_req with safety factor
                const safetyFactor = data.settings?.General?.SteelTolerance || 0.98;
                const asProv = parseRebarArea(val);
                const isUnder = asReq > 0 && asProv < asReq * safetyFactor;

                html += `<td class="p-0.5 ${bgClass} w-12">
                    <input type="text" value="${val}" 
                        onchange="updateLayerRebar(${spanIndex}, '${type}', ${layer}, ${pos}, this.value)"
                        placeholder=""
                        title="As_prov: ${asProv.toFixed(1)} / As_req: ${asReq > 0 ? asReq.toFixed(1) : '-'}"
                        class="w-full min-w-0 border ${isUnder ? 'border-red-500 bg-red-100' : 'border-slate-200'} rounded px-0.5 py-0.5 text-center text-[10px] ${isUnder ? 'bg-red-100 text-red-700 font-bold' : 'bg-white'}">
                </td>`;
            });
            return html;
        }

        // Render 3 stirrup input cells (L1, Mid, L2) with rowspan
        function renderStirrupInputs(spanIndex, span, maxLayers) {
            let html = '';
            const positions = [0, 1, 2]; // L1, Mid, L2
            const placeholders = ['d8a100', 'd8a150', 'd8a100'];

            positions.forEach((pos) => {
                const val = span.Stirrup?.[pos] || '';
                html += `<td class="p-0.5 w-12" rowspan="${maxLayers}">
                    <input type="text" value="${val}" 
                        onchange="updateStirrup(${spanIndex}, ${pos}, this.value)"
                        placeholder="${placeholders[pos]}"
                        class="w-full min-w-0 border border-slate-200 rounded px-0.5 py-0.5 text-center text-[10px]">
                </td>`;
            });
            return html;
        }

        // Update rebar value for a specific layer
        function updateLayerRebar(spanIndex, type, layer, pos, value) {
            const arr = type === 'Top' ? 'TopRebar' : 'BotRebar';

            // BACKBONE LOGIC: Layer 0 is continuous across ALL spans
            if (layer === 0) {
                // Update ALL spans, ALL positions (0, 2, 4) for Layer 0
                currentGroup.Spans.forEach(span => {
                    if (!span[arr]) span[arr] = [];
                    while (span[arr].length <= layer) span[arr].push([]);
                    if (!span[arr][layer]) span[arr][layer] = [];
                    span[arr][layer][0] = value; // Left
                    span[arr][layer][2] = value; // Mid
                    span[arr][layer][4] = value; // Right
                });
                autoLockOnEdit();
                showToast(`‚úì C·ªët ch·ªß ${type} ƒë√£ c·∫≠p nh·∫≠t to√†n b·ªô nh·ªãp: ${value}`);
                maybeRenderTable();
                renderCanvas();
                return;
            }

            // ADDON LOGIC: Layer 1+ is per-span, per-position
            const span = currentGroup.Spans[spanIndex];
            if (!span[arr]) span[arr] = [];
            while (span[arr].length <= layer) span[arr].push([]);
            if (!span[arr][layer]) span[arr][layer] = [];

            span[arr][layer][pos] = value;

            // Mark as user edited
            autoLockOnEdit();

            // Auto apply to subsequent spans (for Layer 1+)
            if (document.getElementById('autoApply').checked) {
                for (let i = spanIndex + 1; i < currentGroup.Spans.length; i++) {
                    if (currentGroup.Spans[i].IsActive !== false) {
                        const s = currentGroup.Spans[i];
                        if (!s[arr]) s[arr] = [];
                        while (s[arr].length <= layer) s[arr].push([]);
                        if (!s[arr][layer]) s[arr][layer] = [];
                        s[arr][layer][pos] = value;
                    }
                }
                maybeRenderTable();
            }
            renderCanvas();
        }

        // ============ DATA UPDATE FUNCTIONS ============
        function toggleSpanActive(index, active) {
            currentGroup.Spans[index].IsActive = active;
            renderTable();
        }

        function updateRebar(spanIndex, type, pos, value) {
            const span = currentGroup.Spans[spanIndex];
            const arr = type === 'Top' ? 'TopRebar' : 'BotRebar';
            if (!span[arr]) span[arr] = [[], [], []];
            if (!span[arr][0]) span[arr][0] = [];
            span[arr][0][pos] = value;

            // ===== AUTO-LOCK: T·ª± ƒë·ªông ch·ªët khi s·ª≠a tay =====
            autoLockOnEdit();

            // Auto apply
            if (document.getElementById('autoApply').checked) {
                for (let i = spanIndex + 1; i < currentGroup.Spans.length; i++) {
                    if (currentGroup.Spans[i].IsActive !== false) {
                        if (!currentGroup.Spans[i][arr]) currentGroup.Spans[i][arr] = [[], [], []];
                        if (!currentGroup.Spans[i][arr][0]) currentGroup.Spans[i][arr][0] = [];
                        currentGroup.Spans[i][arr][0][pos] = value;
                    }
                }
                maybeRenderTable();
            }
            renderCanvas();
        }

        function updateStirrup(spanIndex, pos, value) {
            const span = currentGroup.Spans[spanIndex];
            if (!span.Stirrup) span.Stirrup = [];
            span.Stirrup[pos] = value;

            // ===== AUTO-LOCK: T·ª± ƒë·ªông ch·ªët khi s·ª≠a tay =====
            autoLockOnEdit();

            maybeRenderTable();
            renderCanvas();
        }

        function updateWebBar(spanIndex, pos, value) {
            const span = currentGroup.Spans[spanIndex];
            if (!span.WebBar) span.WebBar = [];
            span.WebBar[pos] = value;

            // ===== AUTO-LOCK: T·ª± ƒë·ªông ch·ªët khi s·ª≠a tay =====
            autoLockOnEdit();

            maybeRenderTable();
            renderCanvas();
        }

        function updateSideBar(spanIndex, value) {
            currentGroup.Spans[spanIndex].SideBar = value;

            // ===== AUTO-LOCK: T·ª± ƒë·ªông ch·ªët khi s·ª≠a tay =====
            autoLockOnEdit();
        }

        function selectAllSpans() {
            currentGroup.Spans.forEach(s => s.IsActive = true);
            renderTable();
        }

        function selectNoneSpans() {
            currentGroup.Spans.forEach(s => s.IsActive = false);
            renderTable();
        }

        function applyStirrupPattern() {
            const pattern = document.getElementById('stirrupPattern').value;
            const parts = pattern.replace(/[a-zA-Z]/g, '').split('/');
            const dia = pattern.match(/d(\d+)/)?.[1] || '8';

            currentGroup.Spans.forEach(span => {
                if (span.IsActive !== false) {
                    span.Stirrup = [
                        `d${dia}a${parts[0] || 100}`,
                        `d${dia}a${parts[1] || 150}`,
                        `d${dia}a${parts[2] || 100}`
                    ];
                }
            });
            renderTable();
            showToast('‚úì ƒê√£ apply stirrup pattern');
        }

        // ============ HIGHLIGHT & SYNC ============
        function highlightSpan(index) {
            highlightedSpanIndex = index;
            document.querySelectorAll('.span-row').forEach((tr, i) => {
                tr.classList.toggle('highlighted', i === index);
            });
            renderCanvas();

            // AUTO HIGHLIGHT IN CAD: send handles to C#
            const span = currentGroup?.Spans?.[index];
            if (span?.Segments?.length > 0) {
                const handles = span.Segments.map(s => s.EntityHandle).filter(h => h);
                if (handles.length > 0) {
                    window.chrome.webview.postMessage('HIGHLIGHT|' + JSON.stringify(handles));
                }
            }
        }

        function clearHighlight() {
            highlightedSpanIndex = -1;
            document.querySelectorAll('.span-row').forEach(tr => tr.classList.remove('highlighted'));
            renderCanvas();
        }

        // ============ MATERIAL GRADE SELECTION ============
        function setGroupConcrete(grade) {
            if (currentGroup) {
                currentGroup.ConcreteGrade = grade;
                showToast(`‚úì ƒê√£ ch·ªçn b√™ t√¥ng ${grade}`);
            }
        }

        function setGroupSteel(grade) {
            if (currentGroup) {
                currentGroup.SteelGrade = grade;
                showToast(`‚úì ƒê√£ ch·ªçn th√©p ${grade}`);
            }
        }

        function loadMaterialSelects() {
            const concreteSelect = document.getElementById('concreteGradeSelect');
            const steelSelect = document.getElementById('steelGradeSelect');

            if (currentGroup?.ConcreteGrade) {
                concreteSelect.value = currentGroup.ConcreteGrade;
            }
            if (currentGroup?.SteelGrade) {
                steelSelect.value = currentGroup.SteelGrade;
            }
        }

        // ============ CAD INTEGRATION ============
        function highlightInCAD() {
            if (!currentGroup?.EntityHandles?.length) {
                showToast('‚ö†Ô∏è Kh√¥ng c√≥ d·∫ßm ƒë·ªÉ highlight');
                return;
            }
            // Send message to C# to highlight beams
            window.chrome.webview.postMessage('HIGHLIGHT|' + JSON.stringify(currentGroup.EntityHandles));
            showToast('‚úì ƒê√£ highlight ' + currentGroup.EntityHandles.length + ' d·∫ßm tr√™n CAD');
        }

        // ============ COPY FORMAT ============
        let copyFormatMode = false;
        let copySourceSpan = null;

        function copyFormat() {
            copyFormatMode = true;
            copySourceSpan = null;
            document.body.style.cursor = 'crosshair';
            showToast('Click nh·ªãp ngu·ªìn ƒë·ªÉ copy format...');
        }

        // ============ ACTIONS ============
        function doSave() { window.chrome.webview.postMessage('SAVE|' + JSON.stringify(data)); }
        function doExport() { window.chrome.webview.postMessage('EXPORT'); }
        function doImport() { window.chrome.webview.postMessage('IMPORT'); }
        function doCancel() { window.chrome.webview.postMessage('CANCEL'); }
        function applyToDrawing() { window.chrome.webview.postMessage('APPLY|' + JSON.stringify(data)); }

        // ============ TOAST ============
        // DISABLED per user request - no popup notifications to avoid disruption
        function showToast(msg) {
            // Intentionally do nothing - all popups disabled
            console.log('[Toast disabled]', msg);
        }

        // Init
        init();

        // ============ EXPORT TO BEAM NAMESPACE ============
        // This allows external access and future module extraction
        Object.assign(Beam, {
            // Navigation
            loadGroup,
            prevGroup,
            nextGroup,
            populateGroupSelect,

            // Options
            populateOptionSelect,
            selectOption,
            getSelectedOption,
            applyOptionToSpans,

            // Lock/Unlock
            toggleLock,
            restoreLockedDesign,
            updateLockStatus,

            // Rendering
            renderCanvas,
            renderTable,
            drawSupport,
            drawRebarLines,

            // Table editing
            toggleSpanActive,
            updateRebar,
            updateLayerRebar,
            updateStirrup,
            updateSideBar,
            renderLayerRebarInputs,
            renderStirrupInputs,

            // Highlight
            highlightSpan,
            clearHighlight,

            // Actions
            doSave,
            doExport,
            doImport,
            doCancel,
            applyToDrawing,
            quickCalc,
            copyFormat,

            // UI
            showToast,
            toggleTablePanel,
            setCanvasMode,
            toggleHighlightMode,

            // Material
            setGroupConcrete,
            setGroupSteel,

            // Utils
            resizeCanvas,
            selectAllSpans,
            selectNoneSpans,
            applyStirrupPattern
        });

        // Sync state to namespace
        Beam.State.currentGroupIndex = currentGroupIndex;
        Beam.State.currentGroup = currentGroup;

        // Keyboard shortcuts for Undo/Redo
        document.addEventListener('keydown', (e) => {
            // Skip if focus is in input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            if (e.ctrlKey && e.key === 'z') { e.preventDefault(); Beam.History.undo(); }
            if (e.ctrlKey && e.key === 'y') { e.preventDefault(); Beam.History.redo(); }
        });

        console.log('Beam Viewer initialized with namespace:', Object.keys(Beam));
    </script>
</body>

</html>