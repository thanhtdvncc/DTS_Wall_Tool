using DTS_Engine.Core.Data;
using DTS_Engine.Core.Engines; // ModelInventory
using DTS_Engine.Core.Interfaces; // ISapLoadReader
using DTS_Engine.Core.Primitives; // Vector3D
using SAP2000v1;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;  namespace DTS_Engine.Core.Utils {     /// <summary>     /// ROBUST SAP2000 DATA READER (HYBRID MODE) v2.9 - DEPENDENCY INJECTION READY     /// ROBUSTNESS:     /// - Nếu Table trả về 0 records nhưng model có data → Auto switch to API     /// - Nếu Table bị lỗi (locked/corrupted) → Auto switch to API     /// - Flag _useFallbackApi ghi nhớ trạng thái để tối ưu performance     ///      /// ARCHITECTURE COMPLIANCE:     /// - Implements ISapLoadReader interface (Dependency Inversion)     /// - Constructor Injection: Requires cSapModel and ModelInventory     /// - Single Responsibility: Chỉ đọc dữ liệu, không xử lý business logic     /// </summary>     public class SapDatabaseReader : ISapLoadReader     {         private readonly cSapModel _model;         private readonly Dictionary<string, TableSchema> _schemaCache;         private readonly ModelInventory _inventory;          // Flag to force using direct API fallback (persistent across calls)         private bool _useFallbackApi = false;          public SapDatabaseReader(cSapModel model, ModelInventory inventory = null)         {             _model = model ?? throw new ArgumentNullException(nameof(model));             _schemaCache = new Dictionary<string, TableSchema>();             _inventory = inventory;              // Health check on construction             CheckDataSourceHealth();         }          /// <summary>         /// Check if Database Tables are available and reliable.         ///          /// STRATEGY:         /// 1. Thử gọi GetAvailableTables() (Light-weight API)         /// 2. Nếu ret != 0 hoặc num == 0 → Table facility unavailable         /// 3. Set flag _useFallbackApi = true để dùng API mode cho các lần gọi sau         ///          /// RATIONALE:         /// - GetAvailableTables() nhanh và ít gây lỗi hơn GetTableForDisplayArray()         /// - Nếu SAP đang trong trạng thái locked/uninitialized, ta biết ngay         /// </summary>         private void CheckDataSourceHealth()         {             try             {                 int num = 0;                 string[] keys = null;                 string[] names = null;                 int[] types = null;                  // Light-weight call to verify table facility                 int ret = _model.DatabaseTables.GetAvailableTables(ref num, ref keys, ref names, ref types);                                  if (ret != 0 || num == 0)                 {                     System.Diagnostics.Debug.WriteLine("[SapDatabaseReader] Database Tables unavailable (Ret={0}, Num={1}). Switching to API Mode.", ret, num);                     _useFallbackApi = true;                 }                 else                 {                     System.Diagnostics.Debug.WriteLine("[SapDatabaseReader] Database Tables available ({0} tables detected). Using Hybrid Mode.", num);                 }             }             catch (Exception ex)             {                 System.Diagnostics.Debug.WriteLine("[SapDatabaseReader] Health check failed: {0}. Switching to API Mode.", ex.Message);                 _useFallbackApi = true;             }         }          /// <summary>         /// Main API: read all loads (Hybrid Mode với Smart Fallback)         ///          /// WORKFLOW:         /// 1. Nếu _useFallbackApi = true → Dùng Direct API ngay         /// 2. Nếu không, thử Table Mode trước         /// 3. Validate kết quả: Nếu Table trả về 0 nhưng SAP có Frame/Area → Fallback         /// 4. Cache kết quả để lần sau không phải check lại         ///          /// CRITICAL FIX:         /// - TRƯỚC: GetTableForDisplayArray trả về 0 → Return rỗng (Người dùng tưởng không có tải)         /// - SAU: Phát hiện inconsistency → Tự động chuyển API → Lấy được data         /// </summary>         public List<RawSapLoad> ReadAllLoads(string patternFilter)         {             // Fast path: Nếu đã biết Table không work → Dùng API luôn             if (_useFallbackApi)             {                 return ReadAllLoads_ViaDirectAPI(patternFilter);             }              var loads = new List<RawSapLoad>();             try             {                 // BƯỚC 1: Thử đọc Frame Loads qua Table                 var frameLoads = ReadFrameDistributedLoads(patternFilter);                  // BƯỚC 2: SMART VALIDATION                 // Nếu SAP model có Frame nhưng Table trả về 0 → Có vấn đề                 if (frameLoads.Count == 0 && SapUtils.CountFrames() > 0)                 {                     // Double-check: Thử đọc ALL patterns xem có data không                     if (ReadFrameDistributedLoads(null).Count == 0)                     {                         System.Diagnostics.Debug.WriteLine("[SapDatabaseReader] Tables returned empty but model has frames. Switching to API Fallback.");                         _useFallbackApi = true; // Ghi nhớ để lần sau không phải check                         return ReadAllLoads_ViaDirectAPI(patternFilter);                     }                 }                  // BƯỚC 3: Nếu Table OK → Tiếp tục đọc các loại tải khác                 loads.AddRange(frameLoads);                 loads.AddRange(ReadAreaUniformLoads(patternFilter));                 loads.AddRange(ReadAreaUniformToFrameLoads(patternFilter));                 loads.AddRange(ReadJointLoads(patternFilter));                  // Frame point loads handled via SapUtils helper (legacy compatibility)                 try { loads.AddRange(SapUtils.GetAllFramePointLoads(patternFilter)); } catch { }             }             catch (Exception ex)             {                 System.Diagnostics.Debug.WriteLine("[SapDatabaseReader] Table Read Error: {0}. Switching to API.", ex.Message);                 _useFallbackApi = true;                 return ReadAllLoads_ViaDirectAPI(patternFilter);             }              return loads;         }          #region Schema Detection          public class TableSchema         {             public string TableName { get; set; }             public Dictionary<string, int> ColumnMap { get; set; } = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);             public string[] FieldKeys { get; set; }             public string[] TableData { get; set; }             public int RecordCount { get; set; }             public int ColumnCount { get; set; }              public string GetString(int row, string columnName)             {                 if (row < 0 || row >= RecordCount) return null;                 if (!ColumnMap.TryGetValue(columnName, out int colIdx)) return null;                 int idx = row * ColumnCount + colIdx;                 if (TableData == null || idx < 0 || idx >= TableData.Length) return null;                 return TableData[idx];             }              public double GetDouble(int row, string columnName)             {                 var s = GetString(row, columnName);                 if (string.IsNullOrEmpty(s)) return 0.0;                 if (double.TryParse(s, NumberStyles.Any, CultureInfo.InvariantCulture, out double d)) return d;                 return 0.0;             }              /// <summary>             /// Smart Column Finder - Tìm cột theo nhiều pattern (fallback chain)             ///              /// STRATEGY:             /// - Thử tìm chính xác trước (exact match)             /// - Nếu không có, thử tìm contains (partial match)             /// - Case-insensitive             ///              /// EXAMPLE:             /// FindColumn("FOverLA", "FOverLB", "FOverL")             /// → Ưu tiên: FOverLA > FOverLB > FOverL             ///              /// USE CASE:             /// - SAP v21: Cột tên "FOverL"             /// - SAP v23: Cột tên "FOverLA" và "FOverLB"             /// - Hàm này xử lý được cả 2 version             /// </summary>             public string FindColumn(params string[] patterns)             {                 // PASS 1: Exact match (case-insensitive)                 foreach (var pattern in patterns)                 {                     foreach (var colName in ColumnMap.Keys)                     {                         if (colName.Equals(pattern, StringComparison.OrdinalIgnoreCase))                             return colName;                     }                 }                  // PASS 2: Partial match (contains, case-insensitive)                 foreach (var pattern in patterns)                 {                     foreach (var colName in ColumnMap.Keys)                     {                         if (colName.IndexOf(pattern, StringComparison.OrdinalIgnoreCase) >= 0)                             return colName;                     }                 }                  return null; // Not found             }         }          /// <summary>         /// Get table schema with robust error handling and auto-fallback.         ///          /// ENHANCEMENTS:         /// 1. Cache schema để tránh gọi lại (Performance)         /// 2. Nếu GetTableForDisplayArray() fail → Set _useFallbackApi = true         /// 3. Return empty schema thay vì throw exception (Fail-safe)         ///          /// CRITICAL:         /// - Nếu hàm này trả về schema rỗng (RecordCount = 0) và không có lỗi         ///   → Có thể Table thật sự rỗng HOẶC có vấn đề         /// - Caller phải validate kết quả và quyết định có nên fallback hay không         /// </summary>         public TableSchema GetTableSchema(string tableName, string patternFilter = null)         {             string cacheKey = $"{tableName}|{patternFilter ?? "ALL"}";             if (_schemaCache.TryGetValue(cacheKey, out var cached)) return cached;              var schema = new TableSchema { TableName = tableName };             try             {                 int tableVer = 0;                 string[] fields = null;                 int numRec = 0;                 string[] tableData = null;                 // Use string[] { "" } so SAP2000 treats this as 'All' (some versions require non-empty array)                 string[] input = new string[] { "" };                  int ret = _model.DatabaseTables.GetTableForDisplayArray(tableName, ref input, "All", ref tableVer, ref fields, ref numRec, ref tableData);                  if (ret != 0)                 {                     // Turn on fallback permanently when table access fails                     System.Diagnostics.Debug.WriteLine("[SapDatabaseReader] Table '{0}' access failed (ret={1}). Enabling API fallback.", tableName, ret);                     _useFallbackApi = true;                     return schema; // Return empty schema                 }                  if (numRec == 0 || fields == null || tableData == null)                  {                     // Table exists but empty → This might be legit (no loads) or a problem                     // Caller should validate                     return schema;                 }                  schema.FieldKeys = fields;                 schema.TableData = tableData;                 schema.RecordCount = numRec;                 schema.ColumnCount = fields.Length;                  // Build column map (case-insensitive)                 for (int i = 0; i < fields.Length; i++)                     if (!string.IsNullOrEmpty(fields[i]))                         schema.ColumnMap[fields[i].Trim()] = i;                  _schemaCache[cacheKey] = schema;             }             catch (Exception ex)             {                 System.Diagnostics.Debug.WriteLine("[SapDatabaseReader] Exception reading table '{0}': {1}. Enabling API fallback.", tableName, ex.Message);                 _useFallbackApi = true; // Enable fallback on exception too             }             return schema;         }          #endregion          #region Vector Calculation Helpers          private int ParseDirectionString(string direction)         {             if (string.IsNullOrEmpty(direction)) return 10; // Gravity default             string dir = direction.ToUpperInvariant().Trim();             if (dir == "1" || dir.Contains("LOCAL-1")) return 1;             if (dir == "2" || dir.Contains("LOCAL-2")) return 2;             if (dir == "3" || dir.Contains("LOCAL-3")) return 3;             if (dir.Contains("X")) return 4;             if (dir.Contains("Y")) return 5;             if (dir.Contains("Z")) return 6;             if (dir.Contains("GRAVITY")) return 10;             return 10;         }          /// <summary>         /// Calculate Force Vector in Global Coordinates (ENHANCED)         ///          /// STRATEGY:         /// 1. Xác định Direction Code (1=Local-1, 2=Local-2, 3=Local-3, 4=X, 5=Y, 6=Z, 10=Gravity)         /// 2. Nếu Global Direction (X/Y/Z/Gravity) → Trả về trực tiếp         /// 3. Nếu Local Direction (1/2/3) → Dùng Inventory để transform         /// 4. Fallback: Gravity nếu không xác định được         ///          /// CRITICAL FIXES:         /// - Gravity LUÔN hướng xuống → (0, 0, -magnitude)         /// - Local-3 của Area thường là Normal (hướng lên/xuống tùy hướng tấm)         /// - Dùng Inventory để transform chính xác (không đoán mò)         /// </summary>         private Vector3D CalculateForceVector(string elementName, double magnitude, string direction, string coordSys)         {             if (string.IsNullOrEmpty(direction)) direction = "Gravity";             string cs = coordSys?.ToUpperInvariant() ?? "GLOBAL";              // CASE 1: Global coordinate system (straightforward)             string dirUpper = direction.ToUpperInvariant();             if (cs.Contains("GLOBAL"))             {                 // Gravity always points downward in Global Z                 if (dirUpper.Contains("GRAVITY") || dirUpper.Contains("Z"))                      return new Vector3D(0, 0, -magnitude);                                  if (dirUpper.Contains("X"))                      return new Vector3D(magnitude, 0, 0);                                  if (dirUpper.Contains("Y"))                      return new Vector3D(0, magnitude, 0);             }              // CASE 2: Local coordinate system (requires Inventory)             if (_inventory != null)             {                 int axis = 3; // default Local-3 (often gravity for frames)                                  // Parse direction string to get axis number                 if (dirUpper.Contains("1")) axis = 1;                 else if (dirUpper.Contains("2")) axis = 2;                 else if (dirUpper.Contains("3")) axis = 3;                  var localAxisVec = _inventory.GetLocalAxis(elementName, axis);                 if (localAxisVec.HasValue)                 {                     // Transform: Local axis * magnitude = Global vector                     return magnitude * localAxisVec.Value;                 }             }              // CASE 3: Fallback - Assume gravity (safest default for structural loads)             System.Diagnostics.Debug.WriteLine("[SapDatabaseReader] Could not determine force direction for {0}. Defaulting to Gravity.", elementName);             return new Vector3D(0, 0, -magnitude);         }          #endregion          #region TABLE MODE: Readers          public List<RawSapLoad> ReadFrameDistributedLoads(string patternFilter = null)         {             if (_useFallbackApi) return GetFrameLoads_DirectAPI(patternFilter);              var loads = new List<RawSapLoad>();             var schema = GetTableSchema("Frame Loads - Distributed", patternFilter);             if (schema == null || schema.RecordCount == 0)             {                 // If table empty but model likely has frames, fallback to API                 if (SapUtils.CountFrames() > 0)                 {                     _useFallbackApi = true;                     return GetFrameLoads_DirectAPI(patternFilter);                 }                 return loads;             }              string colFrame = schema.FindColumn("Frame");             string colPattern = schema.FindColumn("LoadPat", "OutputCase");             string colDir = schema.FindColumn("Dir");             string colCoordSys = schema.FindColumn("CoordSys");             string colFOverLA = schema.FindColumn("FOverLA", "FOverL");             string colFOverLB = schema.FindColumn("FOverLB");             string colAbsDistA = schema.FindColumn("AbsDistA");             string colAbsDistB = schema.FindColumn("AbsDistB");              if (colFrame == null || colPattern == null)             {                 _useFallbackApi = true;                 return GetFrameLoads_DirectAPI(patternFilter);             }              var frameZMap = new Dictionary<string, double>(StringComparer.OrdinalIgnoreCase);             if (_inventory == null)             {                 var frames = SapUtils.GetAllFramesGeometry();                 if (frames != null)                 {                     foreach (var f in frames) frameZMap[f.Name] = f.AverageZ;                 }             }              for (int r = 0; r < schema.RecordCount; r++)             {                 string frameName = schema.GetString(r, colFrame);                 string pattern = schema.GetString(r, colPattern);                 if (string.IsNullOrEmpty(frameName) || string.IsNullOrEmpty(pattern)) continue;                 if (!string.IsNullOrEmpty(patternFilter) && !pattern.Equals(patternFilter, StringComparison.OrdinalIgnoreCase)) continue;                  double valA = colFOverLA != null ? schema.GetDouble(r, colFOverLA) : 0.0;                 double valB = colFOverLB != null ? schema.GetDouble(r, colFOverLB) : valA;                 double avgVal = (valA + valB) / 2.0;                 double magnitude = SapUtils.ConvertLoadToKnPerM(avgVal);                  string dir = schema.GetString(r, colDir) ?? "Gravity";                 string sys = schema.GetString(r, colCoordSys) ?? "Global";                  var vec = CalculateForceVector(frameName, magnitude, dir, sys);                  double z = 0;                 if (_inventory != null)                 {                     var info = _inventory.GetElement(frameName);                     if (info != null) z = info.AverageZ;                 }                 else if (frameZMap.ContainsKey(frameName)) z = frameZMap[frameName];                  var raw = new RawSapLoad                 {                     ElementName = frameName,                     LoadPattern = pattern,                     Value1 = magnitude,                     LoadType = "FrameDistributed",                     Direction = dir,                     CoordSys = sys,                     DistStart = schema.GetDouble(r, colAbsDistA),                     DistEnd = schema.GetDouble(r, colAbsDistB),                     ElementZ = z                 };                 raw.SetForceVector(vec);                 loads.Add(raw);             }              return loads;         }          public List<RawSapLoad> ReadAreaUniformLoads(string patternFilter = null)         {             if (_useFallbackApi) return GetAreaLoads_DirectAPI(patternFilter);              var loads = new List<RawSapLoad>();             var schema = GetTableSchema("Area Loads - Uniform", patternFilter);             if (schema == null || schema.RecordCount == 0)             {                 // Check model for areas                 try                 {                     int c = 0; string[] n = null; _model.AreaObj.GetNameList(ref c, ref n);                     if (c > 0) { _useFallbackApi = true; return GetAreaLoads_DirectAPI(patternFilter); }                 }                 catch { }                 return loads;             }              string colArea = schema.FindColumn("Area");             string colPat = schema.FindColumn("LoadPat", "OutputCase");             string colVal = schema.FindColumn("UnifLoad");             string colDir = schema.FindColumn("Dir");              if (colArea == null || colPat == null) { _useFallbackApi = true; return GetAreaLoads_DirectAPI(patternFilter); }              for (int r = 0; r < schema.RecordCount; r++)             {                 string area = schema.GetString(r, colArea);                 string pat = schema.GetString(r, colPat);                 if (string.IsNullOrEmpty(area) || string.IsNullOrEmpty(pat)) continue;                 if (!string.IsNullOrEmpty(patternFilter) && !pat.Equals(patternFilter, StringComparison.OrdinalIgnoreCase)) continue;                  double val = schema.GetDouble(r, colVal);                 double magnitude = SapUtils.ConvertLoadToKnPerM2(val);                 string dir = schema.GetString(r, colDir) ?? "Gravity";                  var vec = CalculateForceVector(area, magnitude, dir, "Local");                  double z = 0;                 if (_inventory != null) { var i = _inventory.GetElement(area); if (i != null) z = i.AverageZ; }                  var raw = new RawSapLoad                 {                     ElementName = area,                     LoadPattern = pat,                     Value1 = magnitude,                     LoadType = "AreaUniform",                     Direction = dir,                     ElementZ = z                 };                 raw.SetForceVector(vec);                 loads.Add(raw);             }              return loads;         }          public List<RawSapLoad> ReadAreaUniformToFrameLoads(string patternFilter = null)         {             if (_useFallbackApi) return GetAreaUniformToFrameLoads_DirectAPI(patternFilter);              var loads = new List<RawSapLoad>();             var schema = GetTableSchema("Area Loads - Uniform To Frame", patternFilter);             if (schema == null || schema.RecordCount == 0)             {                 try { int c = 0; string[] n = null; _model.AreaObj.GetNameList(ref c, ref n); if (c > 0) { _useFallbackApi = true; return GetAreaUniformToFrameLoads_DirectAPI(patternFilter); } }                 catch { }                 return loads;             }              string colArea = schema.FindColumn("Area");             string colPat = schema.FindColumn("LoadPat");             string colVal = schema.FindColumn("UnifLoad");             string colDir = schema.FindColumn("Dir");             string colDist = schema.FindColumn("DistType");              if (colArea == null || colPat == null) { _useFallbackApi = true; return GetAreaUniformToFrameLoads_DirectAPI(patternFilter); }              for (int r = 0; r < schema.RecordCount; r++)             {                 string area = schema.GetString(r, colArea);                 string pat = schema.GetString(r, colPat);                 if (string.IsNullOrEmpty(area) || string.IsNullOrEmpty(pat)) continue;                 if (!string.IsNullOrEmpty(patternFilter) && !pat.Equals(patternFilter, StringComparison.OrdinalIgnoreCase)) continue;                  double val = schema.GetDouble(r, colVal);                 double magnitude = SapUtils.ConvertLoadToKnPerM2(val);                 string dir = schema.GetString(r, colDir) ?? "Gravity";                  var vec = CalculateForceVector(area, magnitude, dir, "Global");                 double z = 0; if (_inventory != null) { var i = _inventory.GetElement(area); if (i != null) z = i.AverageZ; }                  var raw = new RawSapLoad                 {                     ElementName = area,                     LoadPattern = pat,                     Value1 = magnitude,                     LoadType = "AreaUniformToFrame",                     Direction = dir,                     ElementZ = z,                     DistributionType = schema.GetString(r, colDist)                 };                 raw.SetForceVector(vec);                 loads.Add(raw);             }              return loads;         }          public List<RawSapLoad> ReadJointLoads(string patternFilter = null)         {             if (_useFallbackApi) return GetJointLoads_DirectAPI(patternFilter);              var loads = new List<RawSapLoad>();             var schema = GetTableSchema("Joint Loads - Force", patternFilter);             if (schema == null || schema.RecordCount == 0) return loads;              string colJoint = schema.FindColumn("Joint");             string colPat = schema.FindColumn("LoadPat");             string colF1 = schema.FindColumn("F1");             string colF2 = schema.FindColumn("F2");             string colF3 = schema.FindColumn("F3");             string colSys = schema.FindColumn("CoordSys");              if (colJoint == null || colPat == null) { _useFallbackApi = true; return GetJointLoads_DirectAPI(patternFilter); }              for (int r = 0; r < schema.RecordCount; r++)             {                 string joint = schema.GetString(r, colJoint);                 string pat = schema.GetString(r, colPat);                 if (string.IsNullOrEmpty(joint) || string.IsNullOrEmpty(pat)) continue;                 if (!string.IsNullOrEmpty(patternFilter) && !pat.Equals(patternFilter, StringComparison.OrdinalIgnoreCase)) continue;                  double f1 = schema.GetDouble(r, colF1);                 double f2 = schema.GetDouble(r, colF2);                 double f3 = schema.GetDouble(r, colF3);                 string sys = schema.GetString(r, colSys) ?? "Global";                  double z = 0; if (_inventory != null) { var i = _inventory.GetElement(joint); if (i != null) z = i.AverageZ; }                  void AddComp(double val, string dirName, string localAxis)                 {                     if (Math.Abs(val) < 1e-6) return;                     double mag = SapUtils.ConvertForceToKn(val);                     var vec = CalculateForceVector(joint, mag, localAxis, sys);                     if (val < 0) vec = -vec;                      var raw = new RawSapLoad                     {                         ElementName = joint,                         LoadPattern = pat,                         Value1 = Math.Abs(mag),                         LoadType = "PointForce",                         Direction = dirName,                         CoordSys = sys,                         ElementZ = z                     };                     raw.SetForceVector(vec);                     loads.Add(raw);                 }                  AddComp(f1, "F1/X", "1");                 AddComp(f2, "F2/Y", "2");                 AddComp(f3, "F3/Z", "3");             }              return loads;         }          #endregion          #region FALLBACK MODE: Direct API Readers (Robustness)          /// <summary>         /// Orchestrator for Fallback Mode. Includes the new Area->Frame API reader.         /// </summary>         private List<RawSapLoad> ReadAllLoads_ViaDirectAPI(string patternFilter)         {             var results = new List<RawSapLoad>();              try { results.AddRange(GetFrameLoads_DirectAPI(patternFilter)); }              catch (Exception e) { System.Diagnostics.Debug.WriteLine("API Frame Load Error: " + e.Message); }              try { results.AddRange(GetAreaLoads_DirectAPI(patternFilter)); }              catch (Exception e) { System.Diagnostics.Debug.WriteLine("API Area Load Error: " + e.Message); }              // NEW: Area -> Frame API             try { results.AddRange(GetAreaUniformToFrameLoads_DirectAPI(patternFilter)); }              catch (Exception e) { System.Diagnostics.Debug.WriteLine("API AreaToFrame Error: " + e.Message); }              try { results.AddRange(GetJointLoads_DirectAPI(patternFilter)); }              catch (Exception e) { System.Diagnostics.Debug.WriteLine("API Joint Load Error: " + e.Message); }              // Frame point loads via SapUtils helper             try { results.AddRange(SapUtils.GetAllFramePointLoads(patternFilter)); } catch { }              return results;         }          /// <summary>         /// API Fallback: Frame Distributed Loads         /// </summary>         private List<RawSapLoad> GetFrameLoads_DirectAPI(string patternFilter)         {             var list = new List<RawSapLoad>();             int count = 0;             string[] frameNames = null;              _model.FrameObj.GetNameList(ref count, ref frameNames);             if (count == 0 || frameNames == null) return list;              foreach (var name in frameNames)             {                 int numItems = 0;                 string[] frameArr = null;                 string[] patArr = null;                 int[] typeArr = null;                 string[] csysArr = null;                 int[] dirArr = null;                 // According to SAP2000 API: RD1(), RD2(), Dist1(), Dist2(), Val1(), Val2()                 double[] rd1Arr = null;                 double[] rd2Arr = null;                 double[] dist1Arr = null;                 double[] dist2Arr = null;                 double[] val1Arr = null;                 double[] val2Arr = null;                  int ret = _model.FrameObj.GetLoadDistributed(name, ref numItems, ref frameArr, ref patArr,                     ref typeArr, ref csysArr, ref dirArr, ref rd1Arr, ref rd2Arr, ref dist1Arr, ref dist2Arr, ref val1Arr, ref val2Arr, eItemType.Objects);                  if (ret == 0 && numItems > 0 && patArr != null)                 {                     for (int i = 0; i < numItems; i++)                     {                         if (typeArr != null && i < typeArr.Length && typeArr[i] != 1) continue; // only force type                         if (!string.IsNullOrEmpty(patternFilter) && !patArr[i].Equals(patternFilter, StringComparison.OrdinalIgnoreCase)) continue;                          double v1 = (val1Arr != null && i < val1Arr.Length) ? val1Arr[i] : 0.0;                         double v2 = (val2Arr != null && i < val2Arr.Length) ? val2Arr[i] : v1;                         double magnitude = SapUtils.ConvertLoadToKnPerM((v1 + v2) / 2.0);                          string dirStr = GetApiDirectionString((dirArr != null && i < dirArr.Length) ? dirArr[i] : 10);                         string csys = (csysArr != null && i < csysArr.Length) ? csysArr[i] : "Global";                          var vec = CalculateForceVector(name, magnitude, dirStr, csys);                          double z = 0;                         if (_inventory != null) { var info = _inventory.GetElement(name); if (info != null) z = info.AverageZ; }                          // Determine distances: prefer Dist1/Dist2 if provided; else fallback to RD1/RD2 (relative)                         bool isRelative = (rd1Arr != null && i < rd1Arr.Length);                         double distStart = 0;                         double distEnd = 1;                         if (dist1Arr != null && i < dist1Arr.Length) distStart = dist1Arr[i];                         else if (isRelative) distStart = rd1Arr[i];                          if (dist2Arr != null && i < dist2Arr.Length) distEnd = dist2Arr[i];                         else if (isRelative) distEnd = rd2Arr[i];                          var raw = new RawSapLoad                         {                             ElementName = name,                             LoadPattern = patArr[i],                             Value1 = magnitude,                             LoadType = "FrameDistributed",                             Direction = dirStr,                             CoordSys = csys,                             ElementZ = z,                             DistStart = distStart,                             DistEnd = distEnd,                             IsRelative = isRelative                         };                         raw.SetForceVector(vec);                         list.Add(raw);                     }                 }             }             return list;         }          /// <summary>         /// API Fallback: Area Uniform Loads         /// </summary>         private List<RawSapLoad> GetAreaLoads_DirectAPI(string patternFilter)         {             var list = new List<RawSapLoad>();             int count = 0;             string[] names = null;             _model.AreaObj.GetNameList(ref count, ref names);             if (count == 0 || names == null) return list;              foreach (var name in names)             {                 int num = 0;                 string[] areaArr = null;                 string[] patArr = null;                 string[] csysArr = null;                 int[] dirArr = null;                 double[] valArr = null;                  int ret = _model.AreaObj.GetLoadUniform(name, ref num, ref areaArr, ref patArr, ref csysArr, ref dirArr, ref valArr, eItemType.Objects);                  if (ret == 0 && num > 0 && patArr != null)                 {                     for (int i = 0; i < num; i++)                     {                         if (!string.IsNullOrEmpty(patternFilter) && !patArr[i].Equals(patternFilter, StringComparison.OrdinalIgnoreCase)) continue;                          double magnitude = SapUtils.ConvertLoadToKnPerM2(valArr[i]);                         string dirStr = GetApiDirectionString((dirArr != null && i < dirArr.Length) ? dirArr[i] : 10);                         string csys = (csysArr != null && i < csysArr.Length) ? csysArr[i] : "Global";                          var vec = CalculateForceVector(name, magnitude, dirStr, csys);                         double z = 0;                         if (_inventory != null) { var info = _inventory.GetElement(name); if (info != null) z = info.AverageZ; }                          var raw = new RawSapLoad                         {                             ElementName = name,                             LoadPattern = patArr[i],                             Value1 = magnitude,                             LoadType = "AreaUniform",                             Direction = dirStr,                             CoordSys = csys,                             ElementZ = z                         };                         raw.SetForceVector(vec);                         list.Add(raw);                     }                 }             }             return list;         }          /// <summary>         /// API Fallback: Area Uniform To Frame (One-way / Two-way)         /// Uses AreaObj.GetLoadUniformToFrame         /// </summary>         private List<RawSapLoad> GetAreaUniformToFrameLoads_DirectAPI(string patternFilter)         {             var list = new List<RawSapLoad>();             int count = 0;             string[] names = null;             _model.AreaObj.GetNameList(ref count, ref names);             if (count == 0 || names == null) return list;              foreach (var name in names)             {                 int num = 0;                 string[] areaArr = null;                 string[] patArr = null;                 string[] csysArr = null;                 int[] dirArr = null;                 double[] valArr = null;                 int[] distTypeArr = null;                  int ret = _model.AreaObj.GetLoadUniformToFrame(name, ref num, ref areaArr, ref patArr, ref csysArr, ref dirArr, ref valArr, ref distTypeArr, eItemType.Objects);                 if (ret == 0 && num > 0 && patArr != null)                 {                     for (int i = 0; i < num; i++)                     {                         if (!string.IsNullOrEmpty(patternFilter) && !patArr[i].Equals(patternFilter, StringComparison.OrdinalIgnoreCase)) continue;                          double magnitude = SapUtils.ConvertLoadToKnPerM2(valArr[i]);                         string dirStr = GetApiDirectionString((dirArr != null && i < dirArr.Length) ? dirArr[i] : 10);                         string csys = (csysArr != null && i < csysArr.Length) ? csysArr[i] : "Global";                         string distStr = (distTypeArr != null && i < distTypeArr.Length && distTypeArr[i] == 1) ? "One Way" : "Two Way";                          var vec = CalculateForceVector(name, magnitude, dirStr, csys);                         double z = 0; if (_inventory != null) { var info = _inventory.GetElement(name); if (info != null) z = info.AverageZ; }                          var raw = new RawSapLoad                         {                             ElementName = name,                             LoadPattern = patArr[i],                             Value1 = magnitude,                             LoadType = "AreaUniformToFrame",                             Direction = dirStr,                             CoordSys = csys,                             DistributionType = distStr,                             ElementZ = z                         };                         raw.SetForceVector(vec);                         list.Add(raw);                     }                 }             }             return list;         }          /// <summary>         /// API Fallback: Joint Loads (Point forces at joints)         /// Note: GetLoadForce returns flattened arrays of 6 values per item (F1,F2,F3,M1,M2,M3)         /// </summary>         private List<RawSapLoad> GetJointLoads_DirectAPI(string patternFilter)         {             var list = new List<RawSapLoad>();             int count = 0;             string[] names = null;             _model.PointObj.GetNameList(ref count, ref names);             if (count == 0 || names == null) return list;              foreach (var name in names)             {                 int num = 0;                 string[] pointArr = null;                 string[] patArr = null;                 int[] lcStepArr = null;                 string[] csysArr = null;                 double[] f1Arr = null; // F1                 double[] f2Arr = null; // F2                 double[] f3Arr = null; // F3                 double[] m1Arr = null; // M1                 double[] m2Arr = null; // M2                 double[] m3Arr = null; // M3                  // API signature: GetLoadForce(Name, ref NumberItems, ref PointName(), ref LoadPat(), ref LCStep(), ref CSys(), ref F1(), ref F2(), ref F3(), ref M1(), ref M2(), ref M3(), ItemType)                 int ret = _model.PointObj.GetLoadForce(name, ref num, ref pointArr, ref patArr, ref lcStepArr, ref csysArr, ref f1Arr, ref f2Arr, ref f3Arr, ref m1Arr, ref m2Arr, ref m3Arr, eItemType.Objects);                 if (ret == 0 && num > 0 && patArr != null)                 {                     for (int i = 0; i < num; i++)                     {                         if (!string.IsNullOrEmpty(patternFilter) && !patArr[i].Equals(patternFilter, StringComparison.OrdinalIgnoreCase)) continue;                          double f1 = (f1Arr != null && i < f1Arr.Length) ? f1Arr[i] : 0.0;                         double f2 = (f2Arr != null && i < f2Arr.Length) ? f2Arr[i] : 0.0;                         double f3 = (f3Arr != null && i < f3Arr.Length) ? f3Arr[i] : 0.0;                         string csys = (csysArr != null && i < csysArr.Length) ? csysArr[i] : "Global";                          double z = 0; if (_inventory != null) { var info = _inventory.GetElement(name); if (info != null) z = info.AverageZ; }                          void AddF(double v, string dir)                         {                             if (Math.Abs(v) < 1e-6) return;                             double mag = SapUtils.ConvertForceToKn(v);                             var vec = CalculateForceVector(name, mag, dir, csys);                             if (v < 0) vec = -vec;                              var raw = new RawSapLoad                             {                                 ElementName = name,                                 LoadPattern = patArr[i],                                 Value1 = Math.Abs(mag),                                 LoadType = "PointForce",                                 Direction = dir,                                 CoordSys = csys,                                 ElementZ = z                             };                             raw.SetForceVector(vec);                             list.Add(raw);                         }                          AddF(f1, "1"); // local-1                         AddF(f2, "2"); // local-2                         AddF(f3, "3"); // local-3                     }                 }             }             return list;         }          private string GetApiDirectionString(int dirCode)         {             switch (dirCode)             {                 case 1: return "1"; // Local 1                 case 2: return "2"; // Local 2                 case 3: return "3"; // Local 3                 case 4: return "X";                 case 5: return "Y";                 case 6: return "Z";                 case 10: return "Gravity";                 case 11: return "GravityProj";                 default: return "Gravity";             }         }          #endregion     } } 