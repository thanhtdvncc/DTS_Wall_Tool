using DTS_Engine.Core.Data; using DTS_Engine.Core.Engines; // ModelInventory using DTS_Engine.Core.Primitives; // Vector3D using SAP2000v1; using System; using System.Collections.Generic; using System.Globalization; using System.Linq;  namespace DTS_Engine.Core.Utils {     /// <summary>     /// ROBUST SAP2000 DATA READER (HYBRID MODE) v2.7     /// - Hỗ trợ Fallback API hoàn toàn nếu Database Tables bị khóa.     /// - Đã bổ sung UniformToFrame (API).     /// </summary>     public class SapDatabaseReader     {         private readonly cSapModel _model;         private readonly Dictionary<string, TableSchema> _schemaCache;         private readonly ModelInventory _inventory;          // Flag to force using direct API fallback         private bool _useFallbackApi = false;          public SapDatabaseReader(cSapModel model, ModelInventory inventory = null)         {             _model = model ?? throw new ArgumentNullException(nameof(model));             _schemaCache = new Dictionary<string, TableSchema>();             _inventory = inventory;              // Health check on construction             CheckDataSourceHealth();         }          /// <summary>         /// Check if Database Tables are available. If not, enable API fallback.         /// </summary>         private void CheckDataSourceHealth()         {             try             {                 int num = 0;                 string[] keys = null;                 string[] names = null;                 int[] types = null;                  // Light-weight call to verify table facility                 int ret = _model.DatabaseTables.GetAvailableTables(ref num, ref keys, ref names, ref types);                 if (ret != 0)                 {                     System.Diagnostics.Debug.WriteLine("[SapDatabaseReader] Database Tables unavailable (Ret!=0). Switching to API Mode.");                     _useFallbackApi = true;                 }             }             catch             {                 _useFallbackApi = true;             }         }          /// <summary>         /// Main API: read all loads (tables preferred, fallback to Direct API)         /// </summary>         public List<RawSapLoad> ReadAllLoads(string patternFilter)         {             if (_useFallbackApi)             {                 return ReadAllLoads_ViaDirectAPI(patternFilter);             }              var loads = new List<RawSapLoad>();             try             {                 var frameLoads = ReadFrameDistributedLoads(patternFilter);                  // If SAP model has frames but table returned empty -> assume table issue -> fallback                 if (frameLoads.Count == 0 && SapUtils.CountFrames() > 0)                 {                     if (ReadFrameDistributedLoads(null).Count == 0)                     {                         System.Diagnostics.Debug.WriteLine("[SapDatabaseReader] Tables returned empty data. Switching to API Fallback.");                         return ReadAllLoads_ViaDirectAPI(patternFilter);                     }                 }                  loads.AddRange(frameLoads);                 loads.AddRange(ReadAreaUniformLoads(patternFilter));                 loads.AddRange(ReadAreaUniformToFrameLoads(patternFilter));                 loads.AddRange(ReadJointLoads(patternFilter));                  // Frame point loads handled via SapUtils helper (legacy)                 try { loads.AddRange(SapUtils.GetAllFramePointLoads(patternFilter)); } catch { }             }             catch (Exception ex)             {                 System.Diagnostics.Debug.WriteLine($"[SapDatabaseReader] Table Read Error: {ex.Message}. Switching to API.");                 return ReadAllLoads_ViaDirectAPI(patternFilter);             }              return loads;         }          #region Schema Detection          public class TableSchema         {             public string TableName { get; set; }             public Dictionary<string, int> ColumnMap { get; set; } = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);             public string[] FieldKeys { get; set; }             public string[] TableData { get; set; }             public int RecordCount { get; set; }             public int ColumnCount { get; set; }              public string GetString(int row, string columnName)             {                 if (row < 0 || row >= RecordCount) return null;                 if (!ColumnMap.TryGetValue(columnName, out int colIdx)) return null;                 int idx = row * ColumnCount + colIdx;                 if (TableData == null || idx < 0 || idx >= TableData.Length) return null;                 return TableData[idx];             }              public double GetDouble(int row, string columnName)             {                 var s = GetString(row, columnName);                 if (string.IsNullOrEmpty(s)) return 0.0;                 if (double.TryParse(s, NumberStyles.Any, CultureInfo.InvariantCulture, out double d)) return d;                 return 0.0;             }              public string FindColumn(params string[] patterns)             {                 foreach (var p in patterns)                 {                     foreach (var c in ColumnMap.Keys)                     {                         if (c.IndexOf(p, StringComparison.OrdinalIgnoreCase) >= 0) return c;                     }                 }                 return null;             }         }          public TableSchema GetTableSchema(string tableName, string patternFilter = null)         {             string cacheKey = $"{tableName}|{patternFilter ?? "ALL"}";             if (_schemaCache.TryGetValue(cacheKey, out var cached)) return cached;              var schema = new TableSchema { TableName = tableName };             try             {                 int tableVer = 0;                 string[] fields = null;                 int numRec = 0;                 string[] tableData = null;                 string[] input = new string[] { };                  int ret = _model.DatabaseTables.GetTableForDisplayArray(tableName, ref input, "All", ref tableVer, ref fields, ref numRec, ref tableData);                  if (ret != 0)                 {                     // Turn on fallback permanently when table access fails                     _useFallbackApi = true;                     return schema;                 }                  if (numRec == 0 || fields == null || tableData == null) return schema;                  schema.FieldKeys = fields;                 schema.TableData = tableData;                 schema.RecordCount = numRec;                 schema.ColumnCount = fields.Length;                  for (int i = 0; i < fields.Length; i++)                     if (!string.IsNullOrEmpty(fields[i]))                         schema.ColumnMap[fields[i].Trim()] = i;                  _schemaCache[cacheKey] = schema;             }             catch             {                 _useFallbackApi = true; // enable fallback on exception too             }             return schema;         }          #endregion          #region Vector Calculation Helpers          private int ParseDirectionString(string direction)         {             if (string.IsNullOrEmpty(direction)) return 10; // Gravity default             string dir = direction.ToUpperInvariant().Trim();             if (dir == "1" || dir.Contains("LOCAL-1")) return 1;             if (dir == "2" || dir.Contains("LOCAL-2")) return 2;             if (dir == "3" || dir.Contains("LOCAL-3")) return 3;             if (dir.Contains("X")) return 4;             if (dir.Contains("Y")) return 5;             if (dir.Contains("Z")) return 6;             if (dir.Contains("GRAVITY")) return 10;             return 10;         }          private Vector3D CalculateForceVector(string elementName, double magnitude, string direction, string coordSys)         {             if (string.IsNullOrEmpty(direction)) direction = "Gravity";             string cs = coordSys?.ToUpperInvariant() ?? "GLOBAL";              // Global handling             string dirUpper = direction.ToUpperInvariant();             if (cs.Contains("GLOBAL"))             {                 if (dirUpper.Contains("GRAVITY") || dirUpper.Contains("Z")) return new Vector3D(0, 0, -magnitude);                 if (dirUpper.Contains("X")) return new Vector3D(magnitude, 0, 0);                 if (dirUpper.Contains("Y")) return new Vector3D(0, magnitude, 0);             }              // Local handling using inventory             if (_inventory != null)             {                 int axis = 3; // default Local-3                 if (dirUpper.Contains("1")) axis = 1;                 else if (dirUpper.Contains("2")) axis = 2;                  var localAxisVec = _inventory.GetLocalAxis(elementName, axis);                 if (localAxisVec.HasValue)                 {                     return magnitude * localAxisVec.Value;                 }             }              // Fallback: gravity             return new Vector3D(0, 0, -magnitude);         }          #endregion          #region TABLE MODE: Readers          public List<RawSapLoad> ReadFrameDistributedLoads(string patternFilter = null)         {             var loads = new List<RawSapLoad>();             var schema = GetTableSchema("Frame Loads - Distributed", patternFilter);             if (schema.RecordCount == 0) return loads;              string colFrame = schema.FindColumn("Frame");             string colPattern = schema.FindColumn("LoadPat", "OutputCase");             string colDir = schema.FindColumn("Dir");             string colCoordSys = schema.FindColumn("CoordSys");             string colFOverLA = schema.FindColumn("FOverLA", "FOverL");             string colFOverLB = schema.FindColumn("FOverLB");             string colAbsDistA = schema.FindColumn("AbsDistA");             string colAbsDistB = schema.FindColumn("AbsDistB");              if (colFrame == null || colPattern == null) return loads;              // Cache Z positions             var frameZMap = new Dictionary<string, double>();             if (_inventory != null)             {                 // inventory preferred             }             else             {                 var frames = SapUtils.GetAllFramesGeometry();                 foreach (var f in frames) frameZMap[f.Name] = f.AverageZ;             }              for (int r = 0; r < schema.RecordCount; r++)             {                 string frameName = schema.GetString(r, colFrame);                 string pattern = schema.GetString(r, colPattern);                  if (string.IsNullOrEmpty(frameName) || string.IsNullOrEmpty(pattern)) continue;                 if (!string.IsNullOrEmpty(patternFilter) && !pattern.Equals(patternFilter, StringComparison.OrdinalIgnoreCase)) continue;                  double valA = colFOverLA != null ? schema.GetDouble(r, colFOverLA) : 0;                 double valB = colFOverLB != null ? schema.GetDouble(r, colFOverLB) : valA;                 double avgVal = (valA + valB) / 2.0;                 double magnitude = SapUtils.ConvertLoadToKnPerM(avgVal);                  string dir = schema.GetString(r, colDir) ?? "Gravity";                 string sys = schema.GetString(r, colCoordSys) ?? "Global";                  var vec = CalculateForceVector(frameName, magnitude, dir, sys);                 double z = 0;                 if (_inventory != null)                 {                     var info = _inventory.GetElement(frameName);                     if (info != null) z = info.AverageZ;                 }                 else if (frameZMap.ContainsKey(frameName)) z = frameZMap[frameName];                  var raw = new RawSapLoad                 {                     ElementName = frameName,                     LoadPattern = pattern,                     Value1 = magnitude,                     LoadType = "FrameDistributed",                     Direction = dir,                     CoordSys = sys,                     DistStart = schema.GetDouble(r, colAbsDistA),                     DistEnd = schema.GetDouble(r, colAbsDistB),                     ElementZ = z                 };                 raw.SetForceVector(vec);                 loads.Add(raw);             }             return loads;         }          public List<RawSapLoad> ReadAreaUniformLoads(string patternFilter = null)         {             var loads = new List<RawSapLoad>();             var schema = GetTableSchema("Area Loads - Uniform", patternFilter);             if (schema.RecordCount == 0) return loads;              string colArea = schema.FindColumn("Area");             string colPat = schema.FindColumn("LoadPat", "OutputCase");             string colVal = schema.FindColumn("UnifLoad");             string colDir = schema.FindColumn("Dir");              if (colArea == null || colPat == null) return loads;              for (int r = 0; r < schema.RecordCount; r++)             {                 string area = schema.GetString(r, colArea);                 string pat = schema.GetString(r, colPat);                 if (!string.IsNullOrEmpty(patternFilter) && !pat.Equals(patternFilter, StringComparison.OrdinalIgnoreCase)) continue;                  double val = schema.GetDouble(r, colVal);                 double magnitude = SapUtils.ConvertLoadToKnPerM2(val);                 string dir = schema.GetString(r, colDir) ?? "Gravity";                  var vec = CalculateForceVector(area, magnitude, dir, "Local");                  double z = 0;                 if (_inventory != null) { var i = _inventory.GetElement(area); if (i != null) z = i.AverageZ; }                  var raw = new RawSapLoad                 {                     ElementName = area,                     LoadPattern = pat,                     Value1 = magnitude,                     LoadType = "AreaUniform",                     Direction = dir,                     ElementZ = z                 };                 raw.SetForceVector(vec);                 loads.Add(raw);             }             return loads;         }          public List<RawSapLoad> ReadAreaUniformToFrameLoads(string patternFilter = null)         {             var loads = new List<RawSapLoad>();             var schema = GetTableSchema("Area Loads - Uniform To Frame", patternFilter);             if (schema.RecordCount == 0) return loads;              string colArea = schema.FindColumn("Area");             string colPat = schema.FindColumn("LoadPat");             string colVal = schema.FindColumn("UnifLoad");             string colDir = schema.FindColumn("Dir");             string colDist = schema.FindColumn("DistType");              if (colArea == null || colPat == null) return loads;              for (int r = 0; r < schema.RecordCount; r++)             {                 string area = schema.GetString(r, colArea);                 string pat = schema.GetString(r, colPat);                 if (!string.IsNullOrEmpty(patternFilter) && !pat.Equals(patternFilter, StringComparison.OrdinalIgnoreCase)) continue;                  double val = schema.GetDouble(r, colVal);                 double magnitude = SapUtils.ConvertLoadToKnPerM2(val);                 string dir = schema.GetString(r, colDir) ?? "Gravity";                  var vec = CalculateForceVector(area, magnitude, dir, "Global");                 double z = 0; if (_inventory != null) { var i = _inventory.GetElement(area); if (i != null) z = i.AverageZ; }                  var raw = new RawSapLoad                 {                     ElementName = area,                     LoadPattern = pat,                     Value1 = magnitude,                     LoadType = "AreaUniformToFrame",                     Direction = dir,                     ElementZ = z,                     DistributionType = schema.GetString(r, colDist)                 };                 raw.SetForceVector(vec);                 loads.Add(raw);             }             return loads;         }          public List<RawSapLoad> ReadJointLoads(string patternFilter = null)         {             var loads = new List<RawSapLoad>();             var schema = GetTableSchema("Joint Loads - Force", patternFilter);             if (schema.RecordCount == 0) return loads;              string colJoint = schema.FindColumn("Joint");             string colPat = schema.FindColumn("LoadPat");             string colF1 = schema.FindColumn("F1");             string colF2 = schema.FindColumn("F2");             string colF3 = schema.FindColumn("F3");             string colSys = schema.FindColumn("CoordSys");              if (colJoint == null || colPat == null) return loads;              for (int r = 0; r < schema.RecordCount; r++)             {                 string joint = schema.GetString(r, colJoint);                 string pat = schema.GetString(r, colPat);                 if (!string.IsNullOrEmpty(patternFilter) && !pat.Equals(patternFilter, StringComparison.OrdinalIgnoreCase)) continue;                  double f1 = schema.GetDouble(r, colF1);                 double f2 = schema.GetDouble(r, colF2);                 double f3 = schema.GetDouble(r, colF3);                 string sys = schema.GetString(r, colSys) ?? "Global";                  double z = 0;                 if (_inventory != null) { var i = _inventory.GetElement(joint); if (i != null) z = i.AverageZ; }                  void AddComp(double val, string dirName, string localAxis)                 {                     if (Math.Abs(val) < 1e-6) return;                     double mag = SapUtils.ConvertForceToKn(val);                     var vec = CalculateForceVector(joint, mag, localAxis, sys);                     if (val < 0) vec = -vec;                       var raw = new RawSapLoad                     {                         ElementName = joint,                         LoadPattern = pat,                         Value1 = Math.Abs(mag),                         LoadType = "PointForce",                         Direction = dirName,                         CoordSys = sys,                         ElementZ = z                     };                     raw.SetForceVector(vec);                     loads.Add(raw);                 }                  AddComp(f1, "F1/X", "1");                 AddComp(f2, "F2/Y", "2");                 AddComp(f3, "F3/Z", "3");             }             return loads;         }          #endregion          #region FALLBACK MODE: Direct API Readers (Robustness)          /// <summary>         /// Orchestrator for Fallback Mode. Includes the new Area->Frame API reader.         /// </summary>         private List<RawSapLoad> ReadAllLoads_ViaDirectAPI(string patternFilter)         {             var results = new List<RawSapLoad>();              try { results.AddRange(GetFrameLoads_DirectAPI(patternFilter)); }              catch (Exception e) { System.Diagnostics.Debug.WriteLine("API Frame Load Error: " + e.Message); }              try { results.AddRange(GetAreaLoads_DirectAPI(patternFilter)); }              catch (Exception e) { System.Diagnostics.Debug.WriteLine("API Area Load Error: " + e.Message); }              // NEW: Area -> Frame API             try { results.AddRange(GetAreaUniformToFrameLoads_DirectAPI(patternFilter)); }              catch (Exception e) { System.Diagnostics.Debug.WriteLine("API AreaToFrame Error: " + e.Message); }              try { results.AddRange(GetJointLoads_DirectAPI(patternFilter)); }              catch (Exception e) { System.Diagnostics.Debug.WriteLine("API Joint Load Error: " + e.Message); }              // Frame point loads via SapUtils helper             try { results.AddRange(SapUtils.GetAllFramePointLoads(patternFilter)); } catch { }              return results;         }          /// <summary>         /// API Fallback: Frame Distributed Loads         /// </summary>         private List<RawSapLoad> GetFrameLoads_DirectAPI(string patternFilter)         {             var list = new List<RawSapLoad>();             int count = 0;             string[] frameNames = null;              _model.FrameObj.GetNameList(ref count, ref frameNames);             if (count == 0 || frameNames == null) return list;              foreach (var name in frameNames)             {                 int numItems = 0;                 string[] frameArr = null;                 string[] patArr = null;                 int[] typeArr = null;                 string[] csysArr = null;                 int[] dirArr = null;                 // According to SAP2000 API: RD1(), RD2(), Dist1(), Dist2(), Val1(), Val2()                 double[] rd1Arr = null;                 double[] rd2Arr = null;                 double[] dist1Arr = null;                 double[] dist2Arr = null;                 double[] val1Arr = null;                 double[] val2Arr = null;                  int ret = _model.FrameObj.GetLoadDistributed(name, ref numItems, ref frameArr, ref patArr,                     ref typeArr, ref csysArr, ref dirArr, ref rd1Arr, ref rd2Arr, ref dist1Arr, ref dist2Arr, ref val1Arr, ref val2Arr, eItemType.Objects);                  if (ret == 0 && numItems > 0 && patArr != null)                 {                     for (int i = 0; i < numItems; i++)                     {                         if (typeArr != null && i < typeArr.Length && typeArr[i] != 1) continue; // only force type                         if (!string.IsNullOrEmpty(patternFilter) && !patArr[i].Equals(patternFilter, StringComparison.OrdinalIgnoreCase)) continue;                          double v1 = (val1Arr != null && i < val1Arr.Length) ? val1Arr[i] : 0.0;                         double v2 = (val2Arr != null && i < val2Arr.Length) ? val2Arr[i] : v1;                         double magnitude = SapUtils.ConvertLoadToKnPerM((v1 + v2) / 2.0);                          string dirStr = GetApiDirectionString((dirArr != null && i < dirArr.Length) ? dirArr[i] : 10);                         string csys = (csysArr != null && i < csysArr.Length) ? csysArr[i] : "Global";                          var vec = CalculateForceVector(name, magnitude, dirStr, csys);                          double z = 0;                         if (_inventory != null) { var info = _inventory.GetElement(name); if (info != null) z = info.AverageZ; }                          // Determine distances: prefer Dist1/Dist2 if provided; else fallback to RD1/RD2 (relative)                         bool isRelative = (rd1Arr != null && i < rd1Arr.Length);                         double distStart = 0;                         double distEnd = 1;                         if (dist1Arr != null && i < dist1Arr.Length) distStart = dist1Arr[i];                         else if (isRelative) distStart = rd1Arr[i];                          if (dist2Arr != null && i < dist2Arr.Length) distEnd = dist2Arr[i];                         else if (isRelative) distEnd = rd2Arr[i];                          var raw = new RawSapLoad                         {                             ElementName = name,                             LoadPattern = patArr[i],                             Value1 = magnitude,                             LoadType = "FrameDistributed",                             Direction = dirStr,                             CoordSys = csys,                             ElementZ = z,                             DistStart = distStart,                             DistEnd = distEnd,                             IsRelative = isRelative                         };                         raw.SetForceVector(vec);                         list.Add(raw);                     }                 }             }             return list;         }          /// <summary>         /// API Fallback: Area Uniform Loads         /// </summary>         private List<RawSapLoad> GetAreaLoads_DirectAPI(string patternFilter)         {             var list = new List<RawSapLoad>();             int count = 0;             string[] names = null;             _model.AreaObj.GetNameList(ref count, ref names);             if (count == 0 || names == null) return list;              foreach (var name in names)             {                 int num = 0;                 string[] areaArr = null;                 string[] patArr = null;                 string[] csysArr = null;                 int[] dirArr = null;                 double[] valArr = null;                  int ret = _model.AreaObj.GetLoadUniform(name, ref num, ref areaArr, ref patArr, ref csysArr, ref dirArr, ref valArr, eItemType.Objects);                  if (ret == 0 && num > 0 && patArr != null)                 {                     for (int i = 0; i < num; i++)                     {                         if (!string.IsNullOrEmpty(patternFilter) && !patArr[i].Equals(patternFilter, StringComparison.OrdinalIgnoreCase)) continue;                          double magnitude = SapUtils.ConvertLoadToKnPerM2(valArr[i]);                         string dirStr = GetApiDirectionString((dirArr != null && i < dirArr.Length) ? dirArr[i] : 10);                         string csys = (csysArr != null && i < csysArr.Length) ? csysArr[i] : "Global";                          var vec = CalculateForceVector(name, magnitude, dirStr, csys);                         double z = 0;                         if (_inventory != null) { var info = _inventory.GetElement(name); if (info != null) z = info.AverageZ; }                          var raw = new RawSapLoad                         {                             ElementName = name,                             LoadPattern = patArr[i],                             Value1 = magnitude,                             LoadType = "AreaUniform",                             Direction = dirStr,                             CoordSys = csys,                             ElementZ = z                         };                         raw.SetForceVector(vec);                         list.Add(raw);                     }                 }             }             return list;         }          /// <summary>         /// API Fallback: Area Uniform To Frame (One-way / Two-way)         /// Uses AreaObj.GetLoadUniformToFrame         /// </summary>         private List<RawSapLoad> GetAreaUniformToFrameLoads_DirectAPI(string patternFilter)         {             var list = new List<RawSapLoad>();             int count = 0;             string[] names = null;             _model.AreaObj.GetNameList(ref count, ref names);             if (count == 0 || names == null) return list;              foreach (var name in names)             {                 int num = 0;                 string[] areaArr = null;                 string[] patArr = null;                 string[] csysArr = null;                 int[] dirArr = null;                 double[] valArr = null;                 int[] distTypeArr = null;                  int ret = _model.AreaObj.GetLoadUniformToFrame(name, ref num, ref areaArr, ref patArr, ref csysArr, ref dirArr, ref valArr, ref distTypeArr, eItemType.Objects);                 if (ret == 0 && num > 0 && patArr != null)                 {                     for (int i = 0; i < num; i++)                     {                         if (!string.IsNullOrEmpty(patternFilter) && !patArr[i].Equals(patternFilter, StringComparison.OrdinalIgnoreCase)) continue;                          double magnitude = SapUtils.ConvertLoadToKnPerM2(valArr[i]);                         string dirStr = GetApiDirectionString((dirArr != null && i < dirArr.Length) ? dirArr[i] : 10);                         string csys = (csysArr != null && i < csysArr.Length) ? csysArr[i] : "Global";                         string distStr = (distTypeArr != null && i < distTypeArr.Length && distTypeArr[i] == 1) ? "One Way" : "Two Way";                          var vec = CalculateForceVector(name, magnitude, dirStr, csys);                         double z = 0; if (_inventory != null) { var info = _inventory.GetElement(name); if (info != null) z = info.AverageZ; }                          var raw = new RawSapLoad                         {                             ElementName = name,                             LoadPattern = patArr[i],                             Value1 = magnitude,                             LoadType = "AreaUniformToFrame",                             Direction = dirStr,                             CoordSys = csys,                             DistributionType = distStr,                             ElementZ = z                         };                         raw.SetForceVector(vec);                         list.Add(raw);                     }                 }             }             return list;         }          /// <summary>         /// API Fallback: Joint Loads (Point forces at joints)         /// Note: GetLoadForce returns flattened arrays of 6 values per item (F1,F2,F3,M1,M2,M3)         /// </summary>         private List<RawSapLoad> GetJointLoads_DirectAPI(string patternFilter)         {             var list = new List<RawSapLoad>();             int count = 0;             string[] names = null;             _model.PointObj.GetNameList(ref count, ref names);             if (count == 0 || names == null) return list;              foreach (var name in names)             {                 int num = 0;                 string[] pointArr = null;                 string[] patArr = null;                 int[] lcStepArr = null;                 string[] csysArr = null;                 double[] f1Arr = null; // F1                 double[] f2Arr = null; // F2                 double[] f3Arr = null; // F3                 double[] m1Arr = null; // M1                 double[] m2Arr = null; // M2                 double[] m3Arr = null; // M3                  // API signature: GetLoadForce(Name, ref NumberItems, ref PointName(), ref LoadPat(), ref LCStep(), ref CSys(), ref F1(), ref F2(), ref F3(), ref M1(), ref M2(), ref M3(), ItemType)                 int ret = _model.PointObj.GetLoadForce(name, ref num, ref pointArr, ref patArr, ref lcStepArr, ref csysArr, ref f1Arr, ref f2Arr, ref f3Arr, ref m1Arr, ref m2Arr, ref m3Arr, eItemType.Objects);                 if (ret == 0 && num > 0 && patArr != null)                 {                     for (int i = 0; i < num; i++)                     {                         if (!string.IsNullOrEmpty(patternFilter) && !patArr[i].Equals(patternFilter, StringComparison.OrdinalIgnoreCase)) continue;                          double f1 = (f1Arr != null && i < f1Arr.Length) ? f1Arr[i] : 0.0;                         double f2 = (f2Arr != null && i < f2Arr.Length) ? f2Arr[i] : 0.0;                         double f3 = (f3Arr != null && i < f3Arr.Length) ? f3Arr[i] : 0.0;                         string csys = (csysArr != null && i < csysArr.Length) ? csysArr[i] : "Global";                          double z = 0; if (_inventory != null) { var info = _inventory.GetElement(name); if (info != null) z = info.AverageZ; }                          void AddF(double v, string dir)                         {                             if (Math.Abs(v) < 1e-6) return;                             double mag = SapUtils.ConvertForceToKn(v);                             var vec = CalculateForceVector(name, mag, dir, csys);                             if (v < 0) vec = -vec;                              var raw = new RawSapLoad                             {                                 ElementName = name,                                 LoadPattern = patArr[i],                                 Value1 = Math.Abs(mag),                                 LoadType = "PointForce",                                 Direction = dir,                                 CoordSys = csys,                                 ElementZ = z                             };                             raw.SetForceVector(vec);                             list.Add(raw);                         }                          AddF(f1, "1"); // local-1                         AddF(f2, "2"); // local-2                         AddF(f3, "3"); // local-3                     }                 }             }             return list;         }          private string GetApiDirectionString(int dirCode)         {             switch (dirCode)             {                 case 1: return "1"; // Local 1                 case 2: return "2"; // Local 2                 case 3: return "3"; // Local 3                 case 4: return "X";                 case 5: return "Y";                 case 6: return "Z";                 case 10: return "Gravity";                 case 11: return "GravityProj";                 default: return "Gravity";             }         }          #endregion     } } 